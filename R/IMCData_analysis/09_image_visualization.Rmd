---
title: "Image visualization"
output: html_document
date: '2022-08-20'
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = "120%")
```

# Image visualization {#image-visualization}

The following section describes how to visualize the abundance of biomolecules
(e.g. protein or RNA) as well as cell-specific metadata on images. Section
\@ref(pixel-visualization) focuses on visualizing pixel-level information
including the generation of pseudo-color composite images. Section
\@ref(mask-visualization) highlights the visualization of cell metadata (e.g.
cell phenotype) as well as summarized pixel intensities on cell segmentation
masks.

The
[cytomapper](https://www.bioconductor.org/packages/release/bioc/html/cytomapper.html)
R/Bioconductor package was developed to support the handling and visualization
of multiple multi-channel images and segmentation masks [@Eling2020]. The main
data object for image handling is the
[CytoImageList](https://www.bioconductor.org/packages/release/bioc/vignettes/cytomapper/inst/doc/cytomapper.html#5_The_CytoImageList_object)
container which we used in Section \@ref(read-data) to store multi-channel
images and segmentation masks.

We will first read in the previously processed data and randomly select 3 images
for visualization purposes.

```{r read-data-img-viz, message=FALSE}
library(SpatialExperiment)
library(cytomapper)

path <- "/mnt/Multimodal_Imaging_Daria/_Data_Analysis/_tmp_daria/Image_analysis/20220723_Steinbock_Mesmer_IFbased"

spe <- readRDS(file.path(path,"data/spe_curated_pg.rds"))
images <- readRDS(file.path(path, "data/images.rds"))
channelNames(images) <- rowData(spe)$name
masks <- readRDS(file.path(path, "data/masks.rds"))


mcols(images) <- mcols(masks) <- DataFrame(sample_id = names(images))
```

```{r subset images, message=FALSE, fig.width=15}

library(dplyr)
library(tidyr)
library(dittoSeq)

# Find sample images you want to use
clusters <- sort(as.factor(unique(spe$pg_clusters)))
df <- data.frame(clusters)

for (s in unique(spe$sample)) {
  df[s] <- as.numeric(table(spe[,spe$sample %in% s]$pg_clusters))
}

df_stack <- df %>% 
    gather("sample", "count", -clusters)

cluster_col <- setNames(dittoColors(1)[1:length(unique(spe$pg_clusters))], sort(unique(spe$pg_clusters)))

ggplot(df_stack, aes(fill=clusters, y=count, x=sample)) + 
    geom_bar(position="stack", stat="identity") + 
    scale_fill_manual(values=cluster_col) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

df_t <- t(df)

```
We can see that sample 19-2548 has the highest number of tumor cells (cluster 15). Sample 11-0521 has 5 positive tumor cells, and these were also correctly detected. We will also look into cluster 14 as this one has a high expression of LUM, VIM and Ki-67. This cluster is best represented by sample 15-4020. We will also look at cluster 9 to see what those Ki-67+ Cl.PARP+ CXCR4+ cells are - therefore we will use sample 03-4975. And finally we will look at the B-cell cluster 6, which is best represented by sample 13-2083.



## Pixel visualization {#pixel-visualization}

The following section gives examples for visualizing individual channels or 
multiple channels as pseudo-color composite images. For this the `cytomapper`
package exports the `plotPixels` function which expects a `CytoImageList` object
storing one or multiple multi-channel images. In the simplest use case, a 
single channel can be visualized as follows:

```{r single-channel}
cur_images <- images[names(images) %in% c('20211230_19-2548_BM_ROI_002', '20220205_11-0521_BM_ROI_003')]
plotPixels(cur_images, 
           colour_by = "GD2",
           bcg = list(GD2 = c(0, 10, 1)))
```

The plot above shows the tissue expression of the tumor marker
GD2 on two selected images. The `bcg` parameter (default `c(0, 1, 1)`)
stands for "background", "contrast", "gamma" and controls these attributes of
the image. This parameter takes a named list where each entry specifies these
attributes per channel. The first value of the numeric vector will be added to
the pixel intensities (background); pixel intensities will be multiplied by the
second entry of the vector (contrast); pixel intensities will be exponentiated
by the third entry of the vector (gamma). In most cases, it is sufficient to
adjust the second (contrast) entry of the vector.

The following example highlights the visualization of 6 markers (maximum allowed
number of markers) at once per image. The markers indicate the spatial
distribution of tumor cells (E-caherin), T cells (CD3), B cells (CD20), CD8+ T
cells (CD8a), plasma cells (CD38) and proliferating cells (Ki67).

```{r 6-channel}

cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]

plotPixels(cur_images, 
           colour_by = c("CD3", "GD2", "CD20"),
           bcg = list(CD3 = c(0, 10, 1),
                      GD2 = c(0, 5, 1),
                      CD20 = c(0, 5, 2)))
```

### Adjusting colors

The default colors for visualization are chosen by the additive RGB (red, green,
blue) color model. For six markers the default colors are: red, green, blue,
cyan (green + blue), magenta (red + blue), yellow (green + red). These colors
are the easiest to distinguish by eye. However, you can select other colors for
each channel by setting the `colour` parameter:

```{r setting-colors}
cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]

plotPixels(cur_images, 
           colour_by = c("CD3", "GD2", "CD20"),
           bcg = list(CD3 = c(0, 10, 1),
                      GD2 = c(0, 5, 1),
                      CD20 = c(0, 15, 1)),
           colour = list(CD3 = c("black", "red"),
                         GD2 = c("black", "green"),
                         CD20 = c("black", "yellow")))
```

The `colour` parameter takes a named list in which each entry specifies the
colors from which a color gradient is constructed via `colorRampPalette`. These
are usually vectors of length 2 in which the first entry is `"black"` and the
second entry specifies the color of choice. Although not recommended, you can
also specify more than two colors to generate a more complex color gradient.

### Image normalization

As an alternative to setting the `bcg` parameter, images can first be
normalized. Normalization here means to scale the pixel intensities per channel
between 0 and 1 (or a range specified by the `ft` parameter in the `normalize`
function). By default, the `normalize` function scales pixel intensities across
**all** images contained in the `CytoImageList` object (`separateImages = FALSE`).
Each individual channel is scaled independently (`separateChannels = TRUE`).

After 0-1 normalization, maximum pixel intensities can be clipped to enhance the
contrast of the image (setting the `inputRange` parameter). In the following
example, the clipping to 0 and 0.2 is the same as multiplying the pixel
intensities by a factor of 5.

```{r default-normalization}
# 0 - 1 channel scaling across all images
cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]
norm_images <- normalize(cur_images)

# Clip channel at 0.2
norm_images <- normalize(norm_images, inputRange = c(0, 0.2))

plotPixels(norm_images, 
           colour_by = c("GD2", "CD3", "CD20", "CD8a", "Ki-67"))
```

The default setting of scaling pixel intensities across all images ensures 
comparable intensity levels across images. Pixel intensities can also be 
scaled **per image** therefore correcting for staining/expression differences
between images:

```{r individual-normalization}
# 0 - 1 channel scaling per image
norm_images <- normalize(cur_images, separateImages = TRUE)

# Clip channel at 0.2
norm_images <- normalize(norm_images, inputRange = c(0, 0.1))

plotPixels(norm_images, 
           colour_by = c("GD2", "CD3", "CD20", "CD8a", "Ki-67"))
```

As we can see, the marker Ki67 appears brighter on image 2 and 3 in comparison
to scaling the channel across all images.

Finally, the `normalize` function also accepts a named list input for the
`inputRange` argument. In this list, the clipping range per channel can be set
individually:

```{r setting-inputRange}
# 0 - 1 channel scaling per image

norm_images <- normalize(cur_images, separateImages = TRUE)


norm_images <- normalize(norm_images, 
                         inputRange = list(GD2 = c(0, 0.2), 
                                           CD3 = c(0, 0.2),
                                           CD20 = c(0, 0.1),
                                           CD8a = c(0, 0.1),
                                           'Ki-67' = c(0, 0.05)))

plotPixels(norm_images, 
           colour_by = c("GD2", "CD3", "CD20", "CD8a", "Ki-67"))
```

## Cell visualization {#mask-visualization}

In the following section, we will show examples on how to visualize single
cells either as segmentation masks or outlined on composite images. This type
of visualization allows to observe the spatial distribution of cell phenotypes,
the visual assessment of morphological features and quality control in terms
of cell segmentation and phenotyping.

### Visualzing metadata

The `cytomapper` package provides the `plotCells` function that accepts a
`CytoImageList` object containing segmentation masks. These are defined as
single channel images where sets of pixels with the same integer ID identify
individual cells. This integer ID can be found as an entry in the `colData(spe)`
slot and as pixel information in the segmentation masks. The entry in
`colData(spe)` needs to be specified via the `cell_id` argument to the
`plotCells` function. In that way, data contained in the `SpatialExperiment`
object can be mapped to segmentation masks. For the current dataset, the cell
IDs are stored in `colData(spe)$ObjectNumber`.

As cell IDs are only unique within a single image, the `plotCells` also requires
the `img_id` argument. This argument specifies the `colData(spe)` as well as the
`mcols(masks)` entry that stores the unique image name from which each cell was
extracted. In the current dataset the unique image names are stored in
`colData(spe)$sample_id` and `mcols(masks)$sample_id`.

Providing these two entries that allow mapping between the `SpatialExperiment`
object and segmentation masks, we can now color individual cells based on their
cell type:

```{r celltype}

#spe_all <- readRDS(file.path(path,"data/spe_all.rds"))
mcols(images) <- mcols(masks) <- DataFrame(sample_id = names(images))

cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]
cur_masks <- masks[names(masks) %in% c('20220128_13-2083_BM_ROI_002')]

plotCells(cur_masks,
          object = spe_all, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = "som_clusters_corrected")
```

For consistent visualization, the `plotCells` function takes a named list as
`color` argument. The entry name must match the `colour_by` argument. 

```{r setting-celltype-colors}
plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = "som_clusters_corrected",
          colour = list(som_clusters_corrected = cluster_col))
```

If only individual cell types should be visualized, the `SpatialExperiment`
object can be subsetted (e.g., to only contain CD8+ T cells). In the following
example CD8+ T cells are colored in red and all other cells that are not
contained in the dataset are colored in white (as set by the `missing_color`
argument).

```{r selective-visualization}

cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]
cur_masks <- masks[names(masks) %in% c('20220128_13-2083_BM_ROI_002')]

tumor_cells <- spe[,spe$som_clusters_corrected == "15"]

plotCells(cur_masks,
          object = tumor_cells, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = "som_clusters_corrected",
          colour = list(som_clusters_corrected = c('15' = "red")),
          missing_colour = "white")
```

We can see that we actually do not capture all GD2 positive cells. Let's look at cluster 10 which also has a high GD2 expression.

```{r selective-visualization-2}

cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]
cur_masks <- masks[names(masks) %in% c('20220128_13-2083_BM_ROI_002')]

tumor_cells <- spe[,spe$som_clusters_corrected == "10"]

plotCells(cur_masks,
          object = tumor_cells, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = "som_clusters_corrected",
          colour = list(som_clusters_corrected = c('10' = "red")),
          missing_colour = "white")
```
We can see that many tumor cells are among the cluster 10.
Let's see whether phenograph was better at capturing tumor cells. 

```{r selective-visualization-3}

cur_images <- images[names(images) %in% c('20220205_14-0734_BM_ROI_001')]
cur_masks <- masks[names(masks) %in% c('20220205_14-0734_BM_ROI_001')]

tumor_cells <- spe[,spe$pg_clusters_corrected == "22"]

plotCells(cur_masks,
          object = tumor_cells, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = "pg_clusters_corrected",
          colour = list(pg_clusters_corrected = c('22' = "red")),
          missing_colour = "white")
```
We see that phenograph cluster 10 captures the tumor cells much better.

Let's also check whether sticky cells were correctly captured.
```{r selective-visualization-sticky cells}

spe_all <- readRDS(file.path(path, 'data/spe_curated_pg.rds'))
cur_masks <- masks[names(masks) %in% c('20220104_18-1571_BM_ROI_002')]

sticky_cells <- spe[,spe_all$pg_clusters == "26"]

plotCells(cur_masks,
          object = sticky_cells, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = "pg_clusters",
          colour = list(pg_clusters = c('26' = "red")),
          missing_colour = "white")
```
```{r outlining-sticky-cells}

spe_all <- readRDS(file.path(path, 'data/spe_curated_pg.rds'))
cur_images <- images[names(images) %in% c('20220104_18-1571_BM_ROI_002')]
cur_masks <- masks[names(masks) %in% c('20220104_18-1571_BM_ROI_002')]

sticky_cells <- spe_all[,spe_all$pg_clusters == "26"]

plotPixels(image = cur_images,
           mask = cur_masks,
           object = sticky_cells, 
           cell_id = "ObjectNumber", img_id = "sample_id",
           colour_by = c("Fibronectin"),
           outline_by = "pg_clusters",
                      bcg = list(Fibronectin = c(0, 15, 1)),
           colour = list(celltype = c("sticky_cells" = "white")),
           thick = TRUE)
```
We see that we indeed capture all sticky cells with PG cluster 26 of non-integrated cells by comparing this sample to HistoCAT and seeing that indeed those cells express the typical sticky-cell markers (CXCR2, FN1, PRPH, ELAVL4 etc. )

In terms of visualizing metadata, any entry in the `colData(spe)` slot can be 
visualized the `plotCells` function automatically detects if the entry 
is continuous or discrete. In this fashion, we can now visualize the area of each 
cell:

```{r area}
idx_largest_cell <- which.max(colData(spe)$area)
image <- spe$sample_id[idx_largest_cell]

cur_masks <- masks[names(masks) %in% c(image)]
cur_images <- images[names(images) %in% c(image)]

plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = "area")
```

Let's show the outline of those masks to see whether the segmentation was correct here.

```{r area-outline}
cur_images <- normalize(cur_images, separateImages = TRUE)
cur_images <- normalize(cur_images, inputRange = c(0, 0.2))

plotPixels(cur_images,
           mask = cur_masks,
           img_id = "sample_id",
           missing_colour = "white",
           colour_by = "DAPI",
           colour = list(DAPI = c("black", "blue")),
           image_title = NULL,
           legend = list(colour_by.title.cex = 0.7,
                         colour_by.labels.cex = 0.7))

```
This sample has really large cells, these are not segmentation artifacts. 

### Visualizating expression

Similar to visualizing single-cell metadata on segmentation masks, we can 
use the `plotCells` function to visualize the aggregated pixel intensities
per cell. In the current dataset pixel intensities were aggregated by computing
the mean pixel intensity per cell and per channel. The `plotCells` function
accepts the `exprs_values` argument (default `counts`) that allows selecting
the assay which stores the expression values that should be visualized.

In the following example, we visualize the asinh-transformed mean pixel
intensities of the epithelial marker E-cadherin on segmentation masks.

```{r Ecad-expression}

cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]
cur_masks <- masks[names(masks) %in% c('20220128_13-2083_BM_ROI_002')]

plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = "GD2",
          exprs_values = "exprs")
```

While visualizing 6 markers on the pixel-level still allows the distinction of
different cell phenotypes it is not recommended to visualize the mean pixel
intensities of many (often overlapping) markers on segmentation masks.

Nevertheless and as an example, we will now visualize the maximum number of
allowed markers as composites on the segmentation masks. As above the markers
indicate the spatial distribution of tumor cells (GD2), T cells (CD3), B
cells (CD20), CD8+ T cells (CD8a) and proliferating cells
(Ki67).

```{r 6-channel-expression}
cur_masks <- masks[names(masks) %in% c('20220128_13-2083_BM_ROI_002')]

plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = c("GD2", "CD3", "CD20", "CD8a", "Ki-67"),
          exprs_values = "exprs")
```

Similarly to adjusting marker colors when visualizing pixel intensities, we
can change the color gradients per marker by setting the `color` argument:

```{r setting-expression-colors}
cur_masks <- masks[names(masks) %in% c('20220128_13-2083_BM_ROI_002')]

plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = c("GD2", "CD3", "CD20"),
          exprs_values = "exprs",
          colour = list(GD2 = c("black", "green"),
                          CD3 = c("black", "red"),
                          CD20 = c("black", "yellow")))
```

### Outlining cells on images {#outline-cells}

The following section highlights the combined visualization of pixel- and
cell-level information at once. For this, the `plotPixels` function accepts,
next to the multi-channel image `CytoImageList` object, a segmentation mask
`CytoImageList` object and the `SpatialExperiment` object. By specifying the
`outline_by` parameter, the outlines of cells can now be colored based on their
metadata.

The following example first generates a 3-channel composite images displaying
the expression of GD2, CD3 and CD20 before coloring the cells' outlines
by their cell phenotype.

```{r outlining-all-cells}

cur_masks <- masks[names(masks) %in% c('20220128_13-2083_BM_ROI_002')]
cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]

plotPixels(image = cur_images,
           mask = cur_masks,
           object = spe, 
           cell_id = "ObjectNumber", img_id = "sample_id",
           colour_by = c("GD2", "CD3", "CD20"),
           outline_by = "som_clusters_corrected",
                      bcg = list(GD2 = c(0, 5, 1),
                      CD3 = c(0, 15, 1),
                      CD20 = c(0, 15, 1)),
           colour = list(som_clusters_corrected = cluster_col),
           thick = TRUE)
```

Distinguishing individual cell phenotypes is nearly impossible in the images
above.

However, the `SpatialExperiment` object can be subsetted to only contain cells
of a single or few phenotypes. This allows the selective visualization of cell
outlines on composite images.

Here, we select all CD20+ B cells from the dataset and outline them on a 2-channel
composite image displaying the expression of CD3 and CD20. 

```{r outlining-CD8}

cur_masks <- masks[names(masks) %in% c('20220128_13-2083_BM_ROI_002')]
cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]

B_cells <- spe[,spe$som_clusters_corrected == "6"]

plotPixels(image = cur_images,
           mask = cur_masks,
           object = B_cells, 
           cell_id = "ObjectNumber", img_id = "sample_id",
           colour_by = c("CD3", "CD20"),
           outline_by = "som_clusters_corrected",
                      bcg = list(CD3 = c(0, 25, 1),
                      CD20 = c(0, 15, 1)),
           colour = list(celltype = c("B-cells" = "white")),
           thick = TRUE)
```
We see that some cells are clustered as B-cells even though they have very low CD20 expression. Let's look at the result of the phenograph clustering. Here the B-cells cluster is represented by cluster 17.

```{r outlining-CD8-pg}

cur_masks <- masks[names(masks) %in% c('20220128_13-2083_BM_ROI_002')]
cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]

B_cells <- spe[,spe$pg_clusters_corrected == "17"]

plotPixels(image = cur_images,
           mask = cur_masks,
           object = B_cells, 
           cell_id = "ObjectNumber", img_id = "sample_id",
           colour_by = c("CD3", "CD20"),
           outline_by = "pg_clusters_corrected",
                      bcg = list(CD3 = c(0, 25, 1),
                      CD20 = c(0, 5, 2)),
           colour = list(celltype = c("B-cells" = "white")),
           thick = TRUE)
```
Also PG clustering finds more B-cells than there really are. 

This type of visualization allows the quality control of two things: 1.
segmentation quality of individual cell types can be checked and 2. cell
phenotype quality can be visually assessed against expected marker expression.

## Adjusting plot annotations

The `cytomapper` package provides a number of function arguments to adjust the
visual appearance of figures that are shared between the `plotPixels` and
`plotCells` function.

For a full overview of the arguments please refer to `?plotting-param`.

We use the following example to highlight how to adjust the scale bar, the image
title, the legend appearance and the margin between images.

```{r adjusting-parameters}

cur_masks <- masks[names(masks) %in% c('20220128_13-2083_BM_ROI_002')]
cur_images <- images[names(images) %in% c('20220128_13-2083_BM_ROI_002')]


plotPixels(cur_images, 
           colour_by = c("GD2", "CD3", "CD20", "CD8a", "Ki-67"),
           bcg = list(GD2 = c(0, 5, 1),
                      CD3 = c(0, 15, 1),
                      CD20 = c(0, 15, 1),
                      CD8a = c(0, 15, 1),
                      Ki67 = c(0, 15, 1)),
           scale_bar = list(length = 100,
                            label = expression("100 " ~ mu * "m"),
                            cex = 0.7, 
                            lwidth = 10,
                            colour = "grey",
                            position = "bottomleft",
                            margin = c(5,5),
                            frame = 3),
           image_title = list(text = mcols(cur_images)$sample_id,
                              position = "topright",
                              colour = "grey",
                              margin = c(5,5),
                              font = 2,
                              cex = 2),
           legend = list(colour_by.title.cex = 0.7,
                         margin = 10),
           margin = 40)
```

## Displaying individual images

By default, all images are displayed on the same graphics device. This can be
useful when saving all images at once (see next section) to zoom into the
individual images instead of opening each image individually. However, when
displaying images in a markdown document these are more accessible when
visualized individually. For this, the `plotPixels` and `plotCells` function
accepts the `display` parameter that when set to `"single"` displays each
resulting image in its own graphics device:

```{r individual-images}
plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = "som_clusters_corrected",
          colour = list(som_clusters_corrected = cluster_col),
          display = "single",
          legend = NULL)
```

## Saving and returning images

The final section addresses how to save composite images and how to return them
for integration with other plots.

The `plotPixels` and `plotCells` functions accept the `save_plot` argument which
takes a named list of the following entries: `filename` indicates the location
and file type of the image saved to disk; `scale` adjusts the resolution of the
saved image (this only needs to be adjusted for small images).

```{r saving-images}
plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", img_id = "sample_id",
          colour_by = "som_clusters_corrected",
          colour = list(som_clusters_corrected = cluster_col),
          save_plot = list(filename = file.path(path,"data/celltype_image.png")))
```

The composite images (together with their annotation) can also be returned. In
the following code chunk we save two example plots to variables (`out1` and
`out2`).

```{r returning-images, results="hide", fig.show='hide'}
out1 <- plotCells(cur_masks,
                  object = spe, 
                  cell_id = "ObjectNumber", img_id = "sample_id",
                  colour_by = "som_clusters_corrected",
                  colour = list(som_clusters_corrected = cluster_col),
                  return_plot = TRUE)

out2 <- plotCells(cur_masks,
                  object = spe, 
                  cell_id = "ObjectNumber", img_id = "sample_id",
                  colour_by = c("GD2", "CD3", "CD20"),
                  exprs_values = "exprs",
                  return_plot = TRUE)
```

The composite images are stored in `out1$plot` and `out2$plot` and can be
converted into a graph object recognized by the
[cowplot](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html)
package.

The final function call of the following chunk plots both object next to each
other.

```{r side-by-side-plot, message=FALSE, fig.width = 18}
library(cowplot)
library(gridGraphics)
p1 <- ggdraw(out1$plot, clip = "on")
p2 <- ggdraw(out2$plot, clip = "on")

plot_grid(p1, p2)
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>
