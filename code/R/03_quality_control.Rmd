---
title: "Quality control"
output: html_document
date: '2022-08-12'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(cytomapper)
library(BiocParallel)
```

# Image and cell-level quality control

The following section discusses possible quality indicators for data obtained
by IMC and other highly multiplexed imaging technologies.
Due to the complexity of the data, the quality metric range across the image
and single-cell levels and the chapter is sectioned as such.

## Read in the data

We will first read in the data processed in previous sections. As compensation on all images required too much memory (>45GB), we are not using the compensated images below. For convenience, we will re-set the `channelNames` to their biological targets.

```{r read-data, message=FALSE}
path <- "/mnt/Multimodal_Imaging_Daria/_Data_Analysis/_tmp_daria/Image_analysis/20221010_Steinbock_Mesmer_IFbased/BM"
#images <- readRDS(file.path(path,"data/images.rds")) 
#masks <- readRDS(file.path(path,"data/masks.rds"))
spe <- readRDS(file.path(path,"data/BM_spe.rds"))

#channelNames(images) <- rownames(spe)
```

## Segmentation quality control

The first step after image segmentation is to observe its accuracy.
Without having ground-truth data readily available, a common approach to 
segmentation quality control is to overlay segmentation masks on composite images
displaying channels that were used for segmentation. 
The [cytomapper](https://www.bioconductor.org/packages/release/bioc/html/cytomapper.html) 
Bioconductor package supports exactly this tasks by using the `plotPixels` function.

Here, we select 3 random images and perform image- and channel-wise
normalization (channels are first min-max normalized and scaled to a range of
0-1 before clipping the maximum intensity to 0.2).

```{r overlay-masks, message=FALSE}

set.seed(20220118)
img_ids <- sample(seq_len(length(images)), 3)

# Normalize and clip images
cur_images <- images[img_ids]
cur_images <- normalize(cur_images, separateImages = TRUE)
cur_images <- normalize(cur_images, inputRange = c(0, 0.2))

plotPixels(cur_images,
           mask = masks[img_ids],
           img_id = "image_id",
           missing_colour = "white",
           colour_by = c("CD8a", "CD3", "CD4", "GD2", "DAPI"),
           colour = list(CD8a = c("black", "yellow"),
                         CD3 = c("black", "red"),
                         CD4 = c("black", "green"),
                         GD2 = c("black", "cyan"),
                         DAPI = c("black", "blue")),
           image_title = NULL,
           legend = list(colour_by.title.cex = 0.7,
                         colour_by.labels.cex = 0.7))
```

To zoom into the image you can right click and select `Open Image in New Tab`.
We can see that nuclei are centered within the segmentation masks and all cell
types are correctly segmented A common challenge here is to segment large (e.g.
GD2 - in cyan) _versus_ small (e.g. T cells - in red). However, the
segmentation approach here appears to correctly segment cells across different
sizes.

An additional approach to observe cell segmentation quality and potentially also
antibody specificity issues is to visualize single-cell expression in form of a
heatmap. Here, we sub-sample the dataset to 2000 cells for visualization
purposes and overlay the sample from which the cells were extracted.

```{r adjust sample color-vector}
library(RColorBrewer)

n <- length(unique(spe$sample))
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

metadata(spe)$color_vectors$sample <- setNames(sample(col_vector, n), 
                unique(spe$sample))
```

```{r segmentation-heatmap, message=FALSE, fig.height=7}
library(dittoSeq)
library(viridis)

cur_cells <- sample(seq_len(ncol(spe)), 2000)

dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", cluster_cols = TRUE, scale = "none",
             heatmap.colors = viridis(100), annot.by = "sample",
             annotation_legend = FALSE
             #annotation_colors = list(sample = metadata(spe)$color_vectors$sample)
             )
```

```{r segmentation-heatmap-2, message=FALSE, fig.height=7}
dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", cluster_cols = TRUE, scaled.to.max="TRUE",
             heatmap.colors = viridis(100), annot.by = "sample",
             annotation_legend = FALSE
             #annotation_colors = list(sample = metadata(spe)$color_vectors$sample)
             )
```

We can differentiate between B-cells (CD20) and T cells (CD3).
Some of the markers are specifically detected (e.g., Ki67, CD20, GD2) and
others are more broadly detected (e.g. CD45, HLA-ABC, MPO).

## Image-level quality control

Image-level quality control is often performed using tools that offer a
graphical user interface such as [QuPath](https://qupath.github.io/) and
[FIJI](https://imagej.net/software/fiji/). Viewers that were specifically
developed for IMC data can be seen
[here](https://bodenmillergroup.github.io/IMCWorkflow/viewers.html). In this
section, we will specificaly focus on quantitative metrics to assess image
quality.

It is often of interest to calculate the signal-to-noise ratio (SNR) for
individual channels and markers. Here, we define the SNR as:

$$SNR = I_s/I_n$$

where $I_s$ is the intensity of the signal (mean intensity of pixels with true
signal) and $I_n$ is the intensity of the noise (mean intensity of pixels
containing noise). Finding a threshold that separates pixels containing signal
and pixels containing noise is not trivial and different approaches can be
chosen. Here, we use the `otsu` thresholding approach to find pixels of the
"foreground" (i.e., signal) and "background" (i.e., noise). The SNR is then
defined as the mean intensity of foreground pixels divided by the mean intensity
of background pixels. We compute this measure as well as mean signal intensity
per image as well as the 95% confidence interval. The plot below shows the  
average SNR _versus_ the average signal intensity across all images.  

```{r image-snr, message=FALSE, warning=FALSE}
library(tidyverse)
library(ggrepel)
library(EBImage)

image_subset <- getImages(images, 28:30)
cur_snr <- lapply(image_subset, function(img){
    mat <- apply(img, 3, function(ch){
        # Otsu threshold
        thres <- otsu(ch, range = c(min(ch), max(ch)))
        # Signal-to-noise ratio
        snr <- mean(ch[ch > thres]) / mean(ch[ch <= thres])
        # Signal intensity
        ps <- mean(ch[ch > thres])
        
        return(c(snr = snr, ps = ps))
    })
    t(mat) %>% as.data.frame() %>% 
        mutate(marker = colnames(mat)) %>% 
        pivot_longer(cols = c(snr, ps))
})

cur_snr <- do.call(rbind, cur_snr)

cur_snr %>% 
    group_by(marker, name) %>%
    summarize(mean = mean(value),
              ci = qnorm(0.975)*sd(value)/sqrt(n())) %>%
    pivot_wider(names_from = name, values_from = c(mean, ci)) %>%
    ggplot() +
#    geom_errorbar(aes(y = log2(mean_snr), xmin = log2(mean_ps - ci_ps), 
#                      xmax = log2(mean_ps + ci_ps))) +
#    geom_errorbar(aes(x = log2(mean_ps), ymin = log2(mean_snr - ci_snr), 
#                      ymax = log2(mean_snr + ci_snr))) +
    geom_point(aes(log2(mean_ps), log2(mean_snr))) +
    geom_label_repel(aes(log2(mean_ps), log2(mean_snr), label = marker)) +
    theme_minimal(base_size = 15) + ylab("Signal-to-noise ratio") +
    xlab("Signal intensity")
```

We observe ELAVL4, LUM and S100B to have high SNR but low signal intensity
meaning that in general these markers are not abundantly expressed. The Iridium
intercalator has high signal intensity 
but low SNR. This might be due to staining differences between individual nuclei
where some nuclei are considered as background. We do however observe high
SNR and sufficient signal intensity for the majority of markers.
Results are not representative as only images [28:30] from sample 15-1320 were chosen due to memory issues.

Another quality indicator is the image area covered by cells (or biological
tissue). This metric identifies ROIs where little cells are present, possibly
hinting at incorrect selection of the ROI. We can compute the percentage of
covered image area using the metadata contained in the `SpatialExperiment`
object:

```{r cell-density}
width_px <- 700
height_px <- 700

colData(spe) %>%
    as.data.frame() %>%
    group_by(sample_id) %>%
    summarize(cell_area = sum(area),
           no_pixels = mean(width_px) * mean(height_px)) %>%
    mutate(covered_area = cell_area / no_pixels) %>%
    ggplot() +
        geom_point(aes(sample_id, covered_area)) + 
        theme_minimal(base_size = 15) +
        ylim(c(0, 1)) + 
        theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 2)) +
        ylab("% covered area") + xlab("")
```

We observe that the images with low/high cell coverage are indeed from the samples with a low/high cell number. These
two images can now be visualized using `cytomapper`.

```{r low-density-images, message=FALSE}
# Normalize and clip images
img1="20211230_13-4339_BM_ROI_004" 
img2="20220204_17-0390_BM_ROI_001" 
img3="20211222_03-0313_BM_ROI_005"
img4="20220105_16-3300_BM_ROI_001"
cur_images <- images[c(img1, img4)]
cur_images <- normalize(cur_images, separateImages = TRUE)
cur_images <- normalize(cur_images, inputRange = c(0, 0.2))

plotPixels(cur_images,
           mask = masks[c(img1, img4)],
           img_id = "image_id",
           missing_colour = "white",
           colour_by = c("CD8a", "CD3", "CD4", "GD2", "DAPI"),
           colour = list(CD8a = c("black", "yellow"),
                         CD3 = c("black", "red"),
                         CD4 = c("black", "green"),
                         GD2 = c("black", "blue"),
                         DAPI = c("black", "blue")),
           legend = list(colour_by.title.cex = 0.7,
                         colour_by.labels.cex = 0.7))
```

Some samples might be oversegmented due to a high number of neutrophils, which have irregular shapes.

Finally, it can be beneficial to visualize the mean marker expression per image
to identify images with outlying cell type compositions. This check does not
indicate image quality _per se_ but can highlight biological differences. Here,
we will use the `aggregateAcrossCells` function of the 
`r BiocStyle::Biocpkg("scuttle")` package to compute the mean expression per 
image. For visualization purposes, we again `asinh` transform the mean expression
values.

```{r mean-expression-per-image, message=FALSE, fig.height=7}
library(scuttle)

image_mean <- aggregateAcrossCells(spe, 
                                   ids = spe$sample_id, 
                                   statistics="mean",
                                   use.assay.type = "counts")
assay(image_mean, "exprs") <- asinh(counts(image_mean))

 image_mean%>%dittoHeatmap(genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", cluster_cols = TRUE, scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("sample", "staining_date"),
             annotation_legend = FALSE,
             annotation_colors = list(sample = metadata(spe)$color_vectors$sample,
                                      staining_batch = metadata(spe)$color_vectors$staining_date),
             show_colnames = FALSE)
```

We observe extensive biological variation across the images. Some images
contain a high fraction of tumor cells (GD2), T cells (CD3)
or proliferating cells (Ki67). These differences will be further studied
in the following chapters.

## Cell-level quality control {#cell-quality}

In the following paragraphs we will look at different metrics and visualization
approaches to assess data quality (as well as biological differences) on the 
single-cell level. 

Related to the signal-to-noise ratio (SNR) calculated above on the pixel-level, 
a similar measure can be derived on the single-cell level. Here, we will use 
a two component Gaussian mixture model for each marker to find cells
with positive and negative expression. The SNR is defined as:

$$SNR = I_s/I_n$$

where $I_s$ is the intensity of the signal (mean intensity of cells with positive
signal) and $I_n$ is the intensity of the noise (mean intensity of cells
lacking expression). We calculate the SNR and signal intensity by fitting the
mixture model across the transformed counts of all cells contained in the
`SpatialExperiment` object.

```{r cell-snr, message=FALSE, warning=FALSE, results="hide", fig.keep="all"}
library(mclust)


set.seed(220224)
mat <- apply(assay(spe, "exprs"), 1, function(x){
    cur_model <- Mclust(x, G = 2)
    mean1 <- mean(x[cur_model$classification == 1])
    mean2 <- mean(x[cur_model$classification == 2])
    
    signal <- ifelse(mean1 > mean2, mean1, mean2)
    noise <- ifelse(mean1 > mean2, mean2, mean1)
    
    return(c(snr = signal/noise, ps = signal))
})
    
cur_snr <- t(mat) %>% as.data.frame() %>% 
        mutate(marker = colnames(mat))

cur_snr %>% ggplot() +
    geom_point(aes(log2(ps), log2(snr))) +
    geom_label_repel(aes(log2(ps), log2(snr), label = marker)) +
    theme_minimal(base_size = 15) + ylab("Signal-to-noise ratio") +
    xlab("Signal intensity")
```

This analysis is more representative as it considers all cells, instead of cells of just one sample. We see that the nuclear channels have the highest signal intensity, but quite low SNR. CD14, CD3, GD2, CD8a, GZMB, Ki-67 and CD4 are some of the best markers and also have high SNR and intermediate signal intensity here. CD45 and HLA-ABC are expressed on a lot of cells and have a high signal. Some markers make no sense, such as ELAVL4 and PNMT, they are not nearly as good as CD20. HLA-DR should not have such as bad SNR and should also not be expressed on some many cells (as seen in heatmap above). Maybe this is caused by transformation?

Next, we observe the distributions of cell size across the individual images.
Differences in cell size distributions can indicate segmentation biases due to
differences in cell density or can indicate biological differences due to cell
type compositions (tumor cells tend to be larger than immune cells). 

```{r cell-size, message=FALSE}
colData(spe) %>%
    as.data.frame() %>%
    group_by(sample_id) %>%
    ggplot() +
        geom_boxplot(aes(sample_id, area)) +
        theme_minimal(base_size = 15) + 
        theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 2)) +
        ylab("Cell area") + xlab("")

summary(spe$area)
```

The median cell size is `r median(spe$area)` pixels with a median major axis
length of `r round(median(spe$major_axis_length), digits = 1)`. The largest cell
has an area of `r max(spe$area)` pixels which relates to a diameter of `r
round(sqrt(max(spe$area)), digits = 1)` pixels assuming a circular shape.
Overall, the distribution of cell sizes is similar across images with image
`Patient4_005` and `Patient4_007` showing reduces average cell size. These
images contain fewer tumor cells which can explain the smaller average cell size.

We detect very small cells in the dataset and will remove them.
The chosen threshold is arbitrary and needs to be adjusted per dataset.

```{r remove-small-cells}
sum(spe$area < 5)
spe <- spe[,spe$area >= 5]
```

Another quality indicator can be the number of cells per image divided by the
image size. This measure relates to the percentage of image area covered by
cells as explained above.

```{r no-cells-per-image, message=FALSE}
colData(spe) %>%
    as.data.frame() %>%
    group_by(sample_id) %>%
    summarize(cell_count = n(),
           no_pixels = mean(width_px) * mean(height_px)) %>%
    mutate(cells_per_mm2 = cell_count/(no_pixels/1000000)) %>%
    ggplot() +
        geom_point(aes(sample_id, cells_per_mm2)) + 
        theme_minimal(base_size = 15)  + 
        theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 5)) +
        ylab("Cells per mm2") + xlab("")
```

The number of cells per mm$^2$ varies across images which also depends on the
number of tumor/non-tumor cells, but also the number of neutrophils which are more prone to oversegmentation.

The data presented here were stained on individual slides. Also, samples were
pre-processed in different locations. These (and other) technical aspects can
induce staining differences between samples or batches of samples. Observing
potential staining differences can be crucial to assess data quality.
We will use ridgeline visualizations to check differences in staining patterns:

```{r ridges, message=FALSE, fig.width=7, fig.height=35}
multi_dittoPlot(spe, vars = rownames(spe)[rowData(spe)$use_channel],
               group.by = "year", plots = c("ridgeplot"), 
               assay = "exprs",
               color.panel = metadata(spe)$color_vectors$year
               )
```

We observe variations in the distributions of marker expression across years.
These variations arise mainly from sample preparation differences between samples. Some markers seem to be more problematic such as HLA-ABC, CD274, CD24, CD45 and MPO. HLA-ABC and CD274 might be caused by staining artifacts. 

##Dimensionality reduction on arcsinh-transformed counts
Finally, we will use non-linear dimensionality reduction methods to project
cells from a high-dimensional (40) down to a low-dimensional (2) space. For this
the `r BiocStyle::Biocpkg("scater")` package provides the `runUMAP` and `runTSNE`
function. To ensure reproducibility, we will need to set a seed; 
however different seeds and different parameter settings (e.g. the `perplexity`)
parameter in the `runTSNE` function need to be tested to avoid interpreting
visualization artefacts. For dimensionality reduction, we will use all channels
that show biological variation across the dataset. However, marker selection 
can be performed with different biological questions in mind. 

We will parallelize the tasks to speed up the computation. In order to reduce the 
required memory per CPU, we will delete unused variables.

```{r dimred, message=FALSE}
library(scater)

gc() #free unused space

set.seed(220225)
spe <- runUMAP(spe, subset_row = rowData(spe)$use_channel, exprs_values = "exprs", BPPARAM = MulticoreParam()) 
spe <- runTSNE(spe, subset_row = rowData(spe)$use_channel, exprs_values = "exprs", BPPARAM = MulticoreParam()) 
```

After dimensionality reduction, the low-dimensional embeddings are stored in the 
`reducedDim` slot.

```{r show-dimred-slot}
reducedDims(spe)
head(reducedDim(spe, "UMAP"))
```

Visualization of the low-dimensional embedding facilitates assessment of 
potential "batch effects". The `dittoDimPlot`
function allows flexible visualization. It returns `ggplot` objects which
can be further modified.

```{r visualizing-umap-by-year, message=FALSE}
library(patchwork)
library(viridis)

p1 <- dittoDimPlot(spe, var = "year", reduction.use = "UMAP", size = 0.2, legend.show = FALSE) + 
    scale_color_manual(values = metadata(spe)$color_vectors$year) +
    ggtitle("year on UMAP")
p2 <- dittoDimPlot(spe, var = "year", reduction.use = "TSNE", size = 0.2, legend.size=2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$year) +
    ggtitle("year on TSNE") +
    theme(legend.text=element_text(size=5))

(p1 + p2) 
p1
```

```{r visualizing-umap-by-samples, message=FALSE}

p3 <- dittoDimPlot(spe, var = "staining_date", reduction.use = "UMAP", size = 0.2, legend.show = FALSE, opacity=0.3) +
    #scale_color_manual(values = metadata(spe)$color_vectors$sample) +
    ggtitle("IF-IMC Staining batch")
p4 <- dittoDimPlot(spe, var = "sample", reduction.use = "TSNE", size = 0.2, legend.size=2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$sample) +
    ggtitle("sample on TSNE") + 
    theme(legend.text=element_text(size=2))

(p3 + p4)
p3
```


```{r visualizing-umap-by-markers, message=FALSE, fig.width=7, fig.height=25}

multi_dittoDimPlot(
  spe,
  vars = rownames(spe)[rowData(spe)$use_channel],
  reduction.use="UMAP",
  assay="exprs",
  legend.size=0.2,
  size=0.2,
  ncol=3,
  nrow=13,
  min.color="gray90",
  max.color="red"
)  + 
    theme(legend.text=element_text(size=1))
  

```
We observe a strong separation of T-cells (CD3+ cells) between the patients.
However a seperation of tumor (GD2+, CD56+) and non-tumor (CD45+) cells cannot really be seen.
Therefore we will also run the UMAP on the non-transformed (raw) counts.

##Dimensionality reduction on raw counts
Now we will try to run the UMAP on the non-transformed raw counts to see the effect of arcsinh-transformation.

```{r dimred-raw, message=FALSE}

set.seed(220225)
spe <- runUMAP(spe, subset_row = rowData(spe)$use_channel, exprs_values = "counts", name="UMAP_raw", BPPARAM = MulticoreParam()) 
```

```{r visualizing-umap-raw-by-markers, message=FALSE, fig.width=7, fig.height=25}

multi_dittoDimPlot(
  spe,
  vars = rownames(spe)[rowData(spe)$use_channel],
  reduction.use="UMAP_raw",
  assay="exprs",
  legend.size=0.2,
  size=0.2,
  ncol=3,
  nrow=13,
  min.color="gray90",
  max.color="red"
)  + 
    theme(legend.text=element_text(size=1))
  
```
We see that the result is much worse!

##Dimensionality reduction on log-transformed counts
As a final comparison, we will run the UMAP on log-transformed counts.

```{r dimred-log, message=FALSE}

set.seed(220225)
spe <- runUMAP(spe, subset_row = rowData(spe)$use_channel, exprs_values = "log", name="UMAP_log", BPPARAM = MulticoreParam()) 
```

```{r visualizing-umap-log-raw-by-markers, message=FALSE, fig.width=7, fig.height=25}

multi_dittoDimPlot(
  spe,
  vars = rownames(spe)[rowData(spe)$use_channel],
  reduction.use="UMAP_log",
  assay="exprs",
  legend.size=0.2,
  size=0.2,
  ncol=3,
  nrow=13,
  min.color="gray90",
  max.color="red"
)  + 
    theme(legend.text=element_text(size=1))
  
```

As there is no improvement, we will stick with the arcsinh transformation. 

## Save objects

The modified `SpatialExperiment` object is saved for further downstream analysis.

```{r save-objects-quality-control}
saveRDS(spe, file.path(path,"data/BM_spe_reduced.rds"))
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>