---
title: "Batch correction on full dataset"
output: html_document
date: '2022-08-13'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(parallel)
library(BiocParallel)
library(imcRtools)
library(scater)
```

# Batch effect correction {#batch-effects}

In Section \@ref(cell-quality) we observed staining/expression differences
between the individual samples. This can arise due to technical (e.g.,
differences in sample processing) as well as biological (e.g. differential
expression between patients/indications) reasons. However, the combination of these effects
hinders cell phenotyping via clustering as highlighted in Section \@ref(clustering).

To integrate cells across samples, we can use computational
strategies developed for correcting batch effects in single-cell RNA sequencing
data. In the following sections, we will use functions of the
[batchelor](https://www.bioconductor.org/packages/release/bioc/html/batchelor.html),
[harmony](https://github.com/immunogenomics/harmony) and
[Seurat](https://satijalab.org/seurat/articles/integration_introduction.html)
packages to correct for such batch effects.

We will only test harmony, as the other two took several days!!

Of note: the correction approaches presented here aim at removing any
differences between samples. This will also remove biological differences
between the patients/indications. Nevertheless, integrating cells across samples
can facilitate the detection of cell phenotypes via clustering.

First, we will read in the `SpatialExperiment` object containing the single-cell
data.

When a code chunk is time-consuming to run, you may consider caching it via the chunk option cache = TRUE. When the cache is turned on, `knitr` will skip the execution of this code chunk if it has been executed before and nothing in the code chunk has changed since then. This is explained in more detail [here](https://bookdown.org/yihui/rmarkdown-cookbook/cache.html).
However cache=TRUE did not work and was computing batch correction anyway. Thus the chunk was commented.

```{r read-data-batch-correction}
path <- "/mnt/Multimodal_Imaging_Daria/_Data_Analysis/_tmp_daria/Image_analysis/20221102_Steinbock_Mesmer_IFbased"
spe <- readRDS(file.path(path,"data/spe_bm.rds")) # change this if you want to use the full dataset (with sticky cells)
```

## fastMNN correction

The `batchelor` package provides the `mnnCorrect` and `fastMNN` functions to
correct for differences between samples/batches. Both functions build up on
finding mutual nearest neighbors (MNN) among the cells of different samples and
correct expression differences between the cells [@Haghverdi2018]. The `mnnCorrect` function 
returns corrected expression counts while the `fastMNN` functions performs the 
correction in reduced dimension space. As such, `fastMNN` returns integrated
cells in form of a low dimensional embedding.

Paper: [Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors](https://www.nature.com/articles/nbt.4091)  
Documentation: [batchelor](https://www.bioconductor.org/packages/release/bioc/vignettes/batchelor/inst/doc/correction.html)

### Perform sample correction

Here, we apply the `fastMNN` function to integrate cells between 
patients. By setting `auto.merge = TRUE` the function estimates the best 
batch merging order by maximizing the number of MNN pairs at each merging step. 
This is more time consuming than merging sequentially based on how batches appear in the 
dataset (default). We again select the markers defined in Section \@ref(cell-processing)
for sample correction.

The function returns a `SingleCellExperiment` object which contains corrected
low-dimensional coordinates for each cell in the `reducedDim(out, "corrected")`
slot. This low-dimensional embedding can be further used for clustering and
non-linear dimensionality reduction. We transfer the corrected coordinates
to the main `SpatialExperiment` object.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r batch-correction-fastMNN, message=FALSE, warning=FALSE}
library(batchelor)
set.seed(220228)
out <- fastMNN(spe, batch = spe$sample,
               auto.merge = FALSE,
               subset.row = rowData(spe)$use_channel,
               assay.type = "exprs",
               BPPARAM = MulticoreParam())
# Transfer the correction results to the main spe object
reducedDim(spe, "fastMNN") <- reducedDim(out, "corrected")

saveRDS(spe, file.path(path, "data/spe_bm.rds"))
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

The computational time of the `fastMNN` function call is 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

### Quality control of correction results

The `fastMNN` function further returns outputs that can be used to assess the
quality of the batch correction. The `metadata(out)$merge.info` entry collects
diagnostics for each individual merging step. Here, the `batch.size` and
`lost.var` entries are important. The `batch.size` entry reports the relative
magnitude of the batch effect and the `lost.var` entry represents the percentage
of lost variance per merging step. A large `batch.size` and low `lost.var`
indicate sufficient batch correction.

```{r batch-correction-fastMNN-QC, message=FALSE}
merge_info <- metadata(out)$merge.info 
DataFrame(left = merge_info$left,
          right = merge_info$right,
          batch.size = merge_info$batch.size,
          max_lost_var = rowMax(merge_info$lost.var))
```

We observe that Patient4 and Patient2 are most similar with a low batch effect. 
Merging cells of Patient3 into the combined batch of Patient1,
Patient2 and Patient4 resulted in the highest percentage of lost variance and
the detection of the largest batch effect. In the next paragraph we can
visualize the correction results.

### Visualization

The simplest option to check if the sample effects were corrected is by using
non-linear dimensionality reduction techniques and observe mixing of cells across
samples. We will recompute the UMAP embedding using the corrected
low-dimensional coordinates for each cell.

```{r dimred-batch-correction-fastMNN, message=FALSE, warning=FALSE}
library(scater)
set.seed(220228)
spe <- runUMAP(spe, dimred= "fastMNN", name = "UMAP_mnnCorrected") 
```

Next, we visualize the corrected UMAP while overlaying patient IDs.

```{r visualizing-batch-correction-fastMNN-1, message=FALSE, warning=FALSE, fig.width=12}
# visualize sample

library(cowplot)
library(dittoSeq)
library(viridis)
library(RColorBrewer)

p1 <- dittoDimPlot(spe, var = "sample", 
                   reduction.use = "UMAP", size = 0.2, legend.size=2, legend.show=FALSE) + 
    #scale_color_manual(values = col_samples) +
    ggtitle("Sample on UMAP before correction") + 
    theme(legend.text=element_text(size=4))
p2 <- dittoDimPlot(spe, var = "sample", 
                   reduction.use = "UMAP_mnnCorrected", size = 0.2, legend.size=2, legend.show=FALSE) + 
    #scale_color_manual(values = col_samples) +
    ggtitle("Sample on UMAP after correction") + 
    theme(legend.text=element_text(size=4))

plot_grid(p1)
```

```{r, fig.width=12}
plot_grid(p2)
```

We observe an imperfect merging of Patient3 into all other samples. This
was already seen when displaying the merging information above.
We now also visualize the expression of selected markers across all cells 
before and after batch correction.

```{r visualizing-batch-correction-fastMNN-2, warning=FALSE, message=FALSE, fig.width=7, fig.height=25}

# Before correction
plot_list <- multi_dittoDimPlot(spe, var = rownames(spe)[rowData(spe)$use_channel], reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list, nrow=13, ncol=3) 

# After correction
plot_list <- multi_dittoDimPlot(spe, var = rownames(spe)[rowData(spe)$use_channel], reduction.use = "UMAP_mnnCorrected", 
                   assay = "exprs", size = 0.2, ncol=3, nrow=13, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list, nrow=13, ncol=3)
```

We observe that immune cells across patients are merged after batch correction 
using `fastMNN`. However, the tumor cells of different patients still cluster
separately.

## harmony correction

The `harmony` algorithm performs batch correction by iteratively clustering
and correcting the positions of cells in PCA space [@Korsunsky2019]. It
requires a matrix of transformed expression counts and internally performs
PCA before kmeans clustering. We will first create the expression matrix and
call the `HarmonyMatrix` function to perform the correction. 

Paper: [Fast, sensitive and accurate integration of single-cell data with Harmony](https://www.nature.com/articles/s41592-019-0619-0)  
Documentation: [harmony](https://portals.broadinstitute.org/harmony/index.html)

Similar to the `fastMNN` function, `harmony` returns the corrected
low-dimensional coordinates for each cell. These can be saved in the
`reducedDim` slot of the original `SpatialExperiment` object.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r batch-correction-harmony, message=FALSE, warning=FALSE, cache=TRUE, eval=FALSE}
library(harmony)

mat <- t(assay(spe, "exprs")[rowData(spe)$use_channel,])

harmony_emb <- HarmonyMatrix(mat, spe$sample, do_pca = TRUE)

reducedDim(spe, "harmony") <- harmony_emb

```

```{r, echo=FALSE}
end_time <- Sys.time()
```

The computational time of the `HarmonyMatrix` function call is 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

### Visualization

We will now again visualize the cells in low dimensions after UMAP embedding.

```{r dimred-batch-correction-harmony, message=FALSE, eval=FALSE}
set.seed(220228)
detectCores(all.tests = FALSE, logical = TRUE) # find out how many logical cores available
spe <- runUMAP(spe, dimred = "harmony", name = "UMAP_harmony", BPPARAM = MulticoreParam()) 
```

```{r visualizing-batch-correction-harmony-1, message=FALSE, warning=FALSE, fig.width=12}
# visualize sample

library(cowplot)
library(dittoSeq)
library(viridis)
library(RColorBrewer)

#n <- length(metadata(spe)$color_vectors$sample)
#qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
#col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

# col_vector_433 = colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
# n <- length(unique(spe_all$sample))
# col_samples <- sample(col_vector_433, n)

#metadata(spe)$color_vectors$sample <- sample(col_vector_433, n)

p1 <- dittoDimPlot(spe, var = "sample", 
                   reduction.use = "UMAP", size = 0.2, legend.size=2, legend.show=FALSE) + 
    #scale_color_manual(values = col_samples) +
    ggtitle("Sample on UMAP before correction") + 
    theme(legend.text=element_text(size=4))
p2 <- dittoDimPlot(spe, var = "sample", 
                   reduction.use = "UMAP_harmony", size = 0.2, legend.size=2, legend.show=FALSE) + 
    #scale_color_manual(values = col_samples) +
    ggtitle("Sample on UMAP after correction") + 
    theme(legend.text=element_text(size=4))

plot_grid(p1)
```
```{r, fig.width=12}
plot_grid(p2)
```

And we visualize selected marker expression as defined above.

```{r visualizing-batch-correction-harmony-2, warning=FALSE, message=FALSE, fig.width=7, fig.height=25}

# Before correction
plot_list <- multi_dittoDimPlot(spe, var = rownames(spe)[rowData(spe)$use_channel], reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list, nrow=13, ncol=3) 

# After correction
plot_list <- multi_dittoDimPlot(spe, var = rownames(spe)[rowData(spe)$use_channel], reduction.use = "UMAP_harmony", 
                   assay = "exprs", size = 0.2, ncol=3, nrow=13, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list, nrow=13, ncol=3)
```

We observe a more aggressive merging of cells from different samples compared
to the results after `fastMNN` correction. What we can see in both, corrected and uncorrected, 
is that T-cells appear in the similar region with expression of CD3, CD8, CD4, CD279 and Granzyme B.
CD45 and CD15 are everywhere even in the tumor regions (GD2+, CD56+, GATA3+, ELAVL4+), which shouldn't be the case.
HLA-DR, CD14 and CD11c and CD274 come up in similar regions. CD24, CD10 regions could be immature neutrophils. 
In general, correction causes CD15, CD45 and HLA-ABC to be even more homogeneously expressed, while
it improves the segregation of other cell types like tumor cells. 

## Seurat correction

Seurat and fastMNN were tested but required too much computing time (several days), 
and were stopped in the end.

Use plan("multicore") to parallelize Seurat and adjust `future.globals.maxSize` if required, as explained [here](https://www.rdocumentation.org/packages/future/versions/1.26.1/topics/future.options).

Choosing the correct integration approach is challenging without having ground truth
cell labels available. It is recommended to compare different techniques and different
parameter settings. Please refer to the documentation of the individual tools
to become familiar with the possible parameter choices. Furthermore, in the following
section, we will discuss clustering and classification approaches in light of
expression differences between samples.

In general, it appears that MNN-based approaches are less conservative in terms
of merging compared to `harmony`. On the other hand, `harmony` could well merge
cells in a way that regresses out biological signals. 

The `Seurat` package provides a number of functionalities to analyze single-cell
data. As such it also allows the integration of cells across different samples.
Conceptually, `Seurat` performs batch correction similarly to `fastMNN` by
finding mutual nearest neighbors (MNN) in low dimensional space before
correcting the expression values of cells [@Stuart2019].

Paper: [Comprehensive Integration of Single-Cell Data](https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8)  
Documentation: [Seurat](https://satijalab.org/seurat/index.html)

To use `Seurat`, we will first create a `Seurat` object from the `SpatialExperiment`
object and add relevant metadata. The object also needs to be split by patient
prior to integration.

```{r prepare-seurat, message=FALSE, warning=FALSE}
library(Seurat)
library(SeuratObject)
seurat_obj <- as.Seurat(spe, counts = "counts", data = "exprs")
seurat_obj <- AddMetaData(seurat_obj, as.data.frame(colData(spe)))
seurat.list <- SplitObject(seurat_obj, split.by = "sample")
```

To avoid long run times, we will use an approach that relies on reciprocal PCA
instead of canonical correlation analysis for dimensionality reduction and
initial alignment. For an extended tutorial on how to use `Seurat` for data
integration, please refer to their
[vignette](https://satijalab.org/seurat/articles/integration_rpca.html).

We will first define the features used for integration and perform PCA on cells
of each patient individually. The `FindIntegrationAnchors` function detects MNNs between
cells of different patients and the `IntegrateData` function corrects the
expression values of cells. We slightly increase the number of neighbors to be
considered for MNN detection (the `k.anchor` parameter). This increases the integration
strength.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r seurat-correction, message=FALSE, warning=FALSE}
features <- rownames(spe)[rowData(spe)$use_channel]
seurat.list <- lapply(X = seurat.list, FUN = function(x) {
    x <- ScaleData(x, features = features, verbose = FALSE)
    x <- RunPCA(x, features = features, verbose = FALSE)
    return(x)
})
anchors <- FindIntegrationAnchors(object.list = seurat.list, 
                                  anchor.features = features,
                                  reduction = "rpca", 
                                  k.anchor = 20)
combined <- IntegrateData(anchorset = anchors)

saveRDS(spe, file.path(path, "data/spe_bm.rds"))
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

We now select the `integrated` assay and perform PCA dimensionality reduction.
The cell coordinates in PCA reduced space can then be transferred to the 
original `SpatialExperiment` object.

```{r message=FALSE, warning=FALSE}
DefaultAssay(combined) <- "integrated"
combined <- ScaleData(combined, verbose = FALSE)
combined <- RunPCA(combined, npcs = 30, verbose = FALSE)
reducedDim(spe, "seurat") <- combined@reductions$pca@cell.embeddings

saveRDS(spe, file.path(path, "data/spe_bm.rds"))
```

The computational time of the `Seurat` function calls is 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

### Visualization

As above, we recompute the UMAP embeddings based on `Seurat` integrated results
and visualize the embedding.

```{r umap-seurat, message=FALSE, warning=FALSE}
set.seed(220228)
spe <- runUMAP(spe, dimred = "seurat", name = "UMAP_seurat", BPPARAM = MulticoreParam()) 

saveRDS(spe, file.path(path, "data/spe_bm.rds"))
```

Visualize samples.

```{r visualizing-batch-correction-seurat-1, message=FALSE, warning=FALSE, fig.width=12}
# visualize sample

p1 <- dittoDimPlot(spe, var = "sample", 
                   reduction.use = "UMAP", size = 0.2, legend.size=2, legend.show=FALSE) + 
    #scale_color_manual(values = col_samples) +
    ggtitle("Sample on UMAP before correction") + 
    theme(legend.text=element_text(size=4))
p2 <- dittoDimPlot(spe, var = "sample", 
                   reduction.use = "UMAP_seurat", size = 0.2, legend.size=2, legend.show=FALSE) + 
    #scale_color_manual(values = col_samples) +
    ggtitle("Sample on UMAP after correction") + 
    theme(legend.text=element_text(size=4))

plot_grid(p1)
```


```{r visualizing-batch-correction-seurat-2, message=FALSE, warning=FALSE, fig.width=12}

plot_grid(p2)
```


Visualization of marker expression.

```{r visualizing-batch-correction-seurat-multi, warning=FALSE, message=FALSE, fig.width=7, fig.height=25}

# Before correction
plot_list <- multi_dittoDimPlot(spe, var = rownames(spe)[rowData(spe)$use_channel], reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list, nrow=13, ncol=3) 

# After correction
plot_list <- multi_dittoDimPlot(spe, var = rownames(spe)[rowData(spe)$use_channel], reduction.use = "UMAP_seurat", 
                   assay = "exprs", size = 0.2, ncol=3, nrow=13, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list, nrow=13, ncol=3)
```

Similar to the methods presented above, `Seurat` integrates immune cells correctly.
When visualizing the patient IDs, slight patient-to-patient differences within tumor
cells can be detected. 

Choosing the correct integration approach is challenging without having ground truth
cell labels available. It is recommended to compare different techniques and different
parameter settings. Please refer to the documentation of the individual tools
to become familiar with the possible parameter choices. Furthermore, in the following
section, we will discuss clustering and classification approaches in light of
expression differences between samples.

In general, it appears that MNN-based approaches are less conservative in terms
of merging compared to `harmony`. On the other hand, `harmony` could well merge
cells in a way that regresses out biological signals. 


## Save objects

The modified `SpatialExperiment` object is saved for further downstream analysis.

```{r save-objects-batch-correction}
saveRDS(spe, file.path(path, "data/spe_pt.rds"))
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>