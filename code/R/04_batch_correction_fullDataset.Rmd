---
title: "Batch correction on full dataset"
output: html_document
date: '2022-08-13'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(parallel)
library(BiocParallel)
library(imcRtools)
library(scater)
```

# Batch effect correction {#batch-effects}

In Section \@ref(cell-quality) we observed staining/expression differences
between the individual samples. This can arise due to technical (e.g.,
differences in sample processing) as well as biological (e.g. differential
expression between patients/indications) reasons. However, the combination of these effects
hinders cell phenotyping via clustering as highlighted in Section \@ref(clustering).

To integrate cells across samples, we can use computational
strategies developed for correcting batch effects in single-cell RNA sequencing
data. In the following sections, we will use functions of the
[batchelor](https://www.bioconductor.org/packages/release/bioc/html/batchelor.html),
[harmony](https://github.com/immunogenomics/harmony) and
[Seurat](https://satijalab.org/seurat/articles/integration_introduction.html)
packages to correct for such batch effects.

We will only test harmony, as the other two took several days!!

Of note: the correction approaches presented here aim at removing any
differences between samples. This will also remove biological differences
between the patients/indications. Nevertheless, integrating cells across samples
can facilitate the detection of cell phenotypes via clustering.

First, we will read in the `SpatialExperiment` object containing the single-cell
data.

When a code chunk is time-consuming to run, you may consider caching it via the chunk option cache = TRUE. When the cache is turned on, `knitr` will skip the execution of this code chunk if it has been executed before and nothing in the code chunk has changed since then. This is explained in more detail [here](https://bookdown.org/yihui/rmarkdown-cookbook/cache.html).
However cache=TRUE did not work and was computing batch correction anyway. Thus the chunk was commented.

```{r read-data-batch-correction}
path <- "/mnt/Multimodal_Imaging_Daria/_Data_Analysis/_tmp_daria/Image_analysis/20220723_Steinbock_Mesmer_IFbased"
spe <- readRDS(file.path(path,"data/spe.rds")) # change this if you want to use the full dataset (with sticky cells)
```


## harmony correction

The `harmony` algorithm performs batch correction by iteratively clustering
and correcting the positions of cells in PCA space [@Korsunsky2019]. It
requires a matrix of transformed expression counts and internally performs
PCA before kmeans clustering. We will first create the expression matrix and
call the `HarmonyMatrix` function to perform the correction. 

Paper: [Fast, sensitive and accurate integration of single-cell data with Harmony](https://www.nature.com/articles/s41592-019-0619-0)  
Documentation: [harmony](https://portals.broadinstitute.org/harmony/index.html)

Similar to the `fastMNN` function, `harmony` returns the corrected
low-dimensional coordinates for each cell. These can be saved in the
`reducedDim` slot of the original `SpatialExperiment` object.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r batch-correction-harmony, message=FALSE, warning=FALSE, cache=TRUE, eval=FALSE}
library(harmony)

mat <- t(assay(spe, "exprs")[rowData(spe)$use_channel,])

harmony_emb <- HarmonyMatrix(mat, spe$sample, do_pca = TRUE)

reducedDim(spe, "harmony") <- harmony_emb
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

The computational time of the `HarmonyMatrix` function call is 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

### Visualization

We will now again visualize the cells in low dimensions after UMAP embedding.

```{r dimred-batch-correction-harmony, message=FALSE, eval=FALSE}
set.seed(220228)
detectCores(all.tests = FALSE, logical = TRUE) # find out how many logical cores available
spe <- runUMAP(spe, dimred = "harmony", name = "UMAP_harmony", BPPARAM = MulticoreParam()) 
```

```{r visualizing-batch-correction-harmony-1, message=FALSE, warning=FALSE, fig.width=12}
# visualize sample

library(cowplot)
library(dittoSeq)
library(viridis)
library(RColorBrewer)

n <- length(metadata(spe)$color_vectors$sample)
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

metadata(spe)$color_vectors$sample <- sample(col_vector, n)

p1 <- dittoDimPlot(spe, var = "sample", 
                   reduction.use = "UMAP", size = 0.2, legend.size=2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$sample) +
    ggtitle("Sample ID on UMAP before correction") + 
    theme(legend.text=element_text(size=4))
p2 <- dittoDimPlot(spe, var = "sample", 
                   reduction.use = "UMAP_harmony", size = 0.2, legend.size=2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$sample) +
    ggtitle("Sample ID on UMAP after correction") + 
    theme(legend.text=element_text(size=4))

plot_grid(p1)
```
```{r, fig.width=12}
plot_grid(p2)
```

And we visualize selected marker expression as defined above.

```{r visualizing-batch-correction-harmony-2, warning=FALSE, message=FALSE, fig.width=7, fig.height=25}

# Before correction

# Before correction
plot_list <- multi_dittoDimPlot(spe, var = rownames(spe)[rowData(spe)$use_channel], reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list, nrow=13, ncol=3) 

# After correction
plot_list <- multi_dittoDimPlot(spe, var = rownames(spe)[rowData(spe)$use_channel], reduction.use = "UMAP_harmony", 
                   assay = "exprs", size = 0.2, ncol=3, nrow=13, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list, nrow=13, ncol=3)
```

We observe a more aggressive merging of cells from different samples compared
to the results after `fastMNN` correction. What we can see in both, corrected and uncorrected, 
is that T-cells appear in the similar region with expression of CD3, CD8, CD4, CD279 and Granzyme B.
CD45 and CD15 are everywhere even in the tumor regions (GD2+, CD56+, GATA3+, ELAVL4+), which shouldn't be the case.
HLA-DR, CD14 and CD11c and CD274 come up in similar regions. CD24, CD10 regions could be immature neutrophils. 
In general, correction causes CD15, CD45 and HLA-ABC to be even more homogeneously expressed, while
it improves the segregation of other cell types like tumor cells. 

## Seurat correction

Seurat and fastMNN were tested but required too much computing time (several days), 
and were stopped in the end.

Use plan("multicore") to parallelize Seurat and adjust `future.globals.maxSize` if required, as explained [here](https://www.rdocumentation.org/packages/future/versions/1.26.1/topics/future.options).

Choosing the correct integration approach is challenging without having ground truth
cell labels available. It is recommended to compare different techniques and different
parameter settings. Please refer to the documentation of the individual tools
to become familiar with the possible parameter choices. Furthermore, in the following
section, we will discuss clustering and classification approaches in light of
expression differences between samples.

In general, it appears that MNN-based approaches are less conservative in terms
of merging compared to `harmony`. On the other hand, `harmony` could well merge
cells in a way that regresses out biological signals. 

## Save objects

The modified `SpatialExperiment` object is saved for further downstream analysis.

```{r save-objects-batch-correction}
saveRDS(spe, file.path(path, "data/spe.rds"))
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>