---
title: "Read in scRNAseq data"
output: html_document
date: '2023-07-06'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Read in the single-cell data {#read-data}

Here we will read in single-cell RNAseq data from a single-cell adrenal gland atlas by 
[Jansky et al.](https://adrenal.kitz-heidelberg.de/developmental_programs_NB_viz/), and
our imaging-based single-cell data

```{r read-data, message=FALSE}
library(Seurat)
library(SingleCellExperiment)
library(dplyr)
library(tidyr)
library(monocle3)

path <- "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS"

rna <- readRDS(file.path(path,"results/Manuscript/1_Figure/public_datasets/Jansky/adrenal_medulla_Seurat.RDS"))

DefaultAssay(rna) <- "RNA"
rna <- UpdateSeuratObject(object = rna)

protein <- readRDS(file.path(path,"results/Manuscript/spe_clustered.rds"))
protein <- protein[rowData(protein)$use_channel,]
col_celltype <- metadata(protein)$color_vectors$col_celltype
```

# Set common features 
Next, we will set common features between the reference and query dataset. Therefore,
we have to rename the features in the imaging dataset to the names of the corresponding
genes. 

```{r set common features, message=FALSE}

protein2gene <- read.csv(file.path(path,"results/public_datasets/protein2gene.csv"), sep=";")

code <- setNames(protein2gene$genes, protein2gene$protein)
rownames(protein) <- recode(rownames(protein), !!!code)
rowData(protein)$name <- rownames(protein)
rowData(protein)$channel <- rownames(protein)

protein <- as.Seurat(protein, counts = "counts", data = "exprs")
Idents(protein) <- "celltype"

#protein <- readRDS(file.path(path, "results/Manuscript/1_Figure/public_datasets/imc_seurat.rds"))
protein <- UpdateSeuratObject(object = protein)

common_features <- intersect(row.names(rna), row.names(protein))

tumor_markers <- c("ELAVL4", "CXCR4", "HLA-A", "CD24", "CD44", "NCAM1", "GATA3", "VIM", "MKI67", "ST8SIA1", "PRPH", "LUM", "CHGA", "SOX10", "S100B")
common_features <- common_features[common_features%in%tumor_markers]
```

# Quality control on public dataset

We will first look at cluster similarity to evaulate which clusters are similar. 
```{r mean-per-cluster-protein, fig.height=15, message=FALSE}
library(scuttle)
library(bruceR)
library(ComplexHeatmap)
library(viridis)

protein_clusters <- protein@active.ident
protein_data <- GetAssayData(protein, assay = "originalexp", slot = "data")[common_features, ]
protein_mean <- aggregate(t(protein_data), list(protein_clusters), mean)

protein_mean_t <- t(protein_mean[,2:ncol(protein_mean)])
colnames(protein_mean_t) <- protein_mean[,"Group.1"]
protein_mean_scaled <- t(apply(protein_mean_t, 1, RESCALE, to=0:1))

column_ha = HeatmapAnnotation(ncells=anno_barplot(as.data.frame(table(protein_clusters))[,"Freq"], height = unit(3, "cm")),
                              show_legend=F)

Heatmap(protein_mean_scaled, 
        column_title = "Mean per cluster (protein data)",
        top_annotation = column_ha, 
        cluster_columns=T,
        show_column_dend = T,
        show_column_names=T,
        show_row_names=T,
        col=viridis(100)
        )

```

```{r mean-per-cluster-rna, fig.height=15, message=FALSE}

#rna_clusters <- rna@meta.data$fate
rna_clusters <- rna@active.ident
rna_data <- GetAssayData(rna, assay = "RNA", slot = "data")[common_features, ]
rna_mean <- aggregate(t(rna_data), list(rna_clusters), mean)

rna_mean_t <- t(rna_mean[,2:ncol(rna_mean)])
colnames(rna_mean_t) <- rna_mean[,"Group.1"]
rna_mean_scaled <- t(apply(rna_mean_t, 1, RESCALE, to=0:1))

column_ha = HeatmapAnnotation(ncells=anno_barplot(as.data.frame(table(rna_clusters))[,"Freq"], height = unit(3, "cm")),
                              show_legend=F)

Heatmap(rna_mean_scaled, 
        column_title = "Mean per cluster (RNA data)",
        top_annotation = column_ha, 
        cluster_columns=T,
        show_column_dend = T,
        show_column_names=T,
        show_row_names=T,
        col=viridis(100)
        )

```
We will then visualize the two datasets by UMAP.

```{r umap-rna, fig.width=10, fig.height=7, message=FALSE}
library(RColorBrewer)
library(paletteer)
set.seed(230712)

col_vector_433 = colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
col_rna_clusters = setNames(sample(col_vector_433, length(unique(rna@active.ident))), unique(rna@active.ident))

DimPlot(rna, reduction="umap", cols=col_rna_clusters)

```

```{r umap-protein, message=FALSE, fig.width=10, fig.height=7}
set.seed(230713)
rand_cells <- sample(seq_len(ncol(protein)), 10000)
DimPlot(protein[,rand_cells], reduction="UMAP")
```

For further analysis we will on consider tumor cells.
```{r data-curation, message=FALSE}
protein <- protein[,protein@meta.data$metacluster=="tumor"]

```

We will next plot the two together to look at similarity.
```{r mean-per-cluster-combined, fig.height=7, fig.width=7, message=FALSE}
set.seed(230717)
protein_clusters <- protein@active.ident
protein_data <- GetAssayData(protein, assay = "originalexp", slot = "data")[common_features, ]
protein_mean <- aggregate(t(protein_data), list(protein_clusters), mean)
protein_mean_t <- t(protein_mean[,2:ncol(protein_mean)])
colnames(protein_mean_t) <- protein_mean[,"Group.1"]
protein_mean_scaled <- t(apply(protein_mean_t, 1, RESCALE, to=0:1))

rna_clusters <- droplevels(rna@active.ident)
rna_data <- GetAssayData(rna, assay = "RNA", slot = "data")[common_features, ]
rna_mean <- aggregate(t(rna_data), list(rna_clusters), mean)
rna_mean_t <- t(rna_mean[,2:ncol(rna_mean)])
colnames(rna_mean_t) <- rna_mean[,"Group.1"]
rna_mean_scaled <- t(apply(rna_mean_t, 1, RESCALE, to=0:1))

clusters <- c(rna_clusters, protein_clusters)
cell_count <- c(as.data.frame(table(rna_clusters))[,"Freq"], as.data.frame(table(protein_clusters))[,"Freq"])
modality <- c(rep(c("RNA"), ncol(rna_mean_scaled)), rep(c("protein"), ncol(protein_mean_scaled)))
mean_scaled <- cbind(rna_mean_scaled, protein_mean_scaled)

column_ha = HeatmapAnnotation(modality=modality,
                              ncells=anno_barplot(cell_count, height = unit(3, "cm")),
                              show_legend=F)

Heatmap(mean_scaled, 
        column_title = "Mean per cluster (RNA & protein)",
        top_annotation = column_ha, 
        clustering_distance_columns="pearson", #use euclidean, kendall or pearson
        clustering_method_columns="average", #use centroid, average or single
        cluster_columns=T,
        show_column_dend = T,
        show_column_names=T,
        show_row_names=T,
        col=viridis(100)
        )


```
We will show this in a bubble plot.
```{r dot-plot-complex-heatmap, message=FALSE, fig.height=14, fig.width=16}
library(tidyr)
library(tidyHeatmap)
library(bruceR)

#Mean expression per cluster
protein_clusters <- protein@active.ident
protein_data <- GetAssayData(protein, assay = "originalexp", slot = "data")[common_features, ]
protein_mean <- aggregate(t(protein_data), list(protein_clusters), mean)
protein_mean_t <- t(protein_mean[,2:ncol(protein_mean)])
colnames(protein_mean_t) <- protein_mean[,"Group.1"]
protein_exp_mat <- t(apply(protein_mean_t, 1, RESCALE, to=0:1))

rna_clusters <- droplevels(rna@active.ident)
rna_data <- GetAssayData(rna, assay = "RNA", slot = "data")[common_features, ]
rna_mean <- aggregate(t(rna_data), list(rna_clusters), mean)
rna_mean_t <- t(rna_mean[,2:ncol(rna_mean)])
colnames(rna_mean_t) <- rna_mean[,"Group.1"]
rna_exp_mat <- t(apply(rna_mean_t, 1, RESCALE, to=0:1))

#Percentage of cells per cluster expressing a marker (>0)
tmp <- protein_data
tmp[tmp > unname(quantile(protein_exp_mat[protein_exp_mat>0], c(0.2)))] <- 1
tmp[tmp <= unname(quantile(protein_exp_mat[protein_exp_mat>0], c(0.2)))] <- 0
tmp <- aggregate(t(tmp), list(protein_clusters), sum)
tmp2 <- tmp[,2:ncol(tmp)]
rownames(tmp2) <- tmp[,"Group.1"]
protein_percent_mat <- tmp2 / unname(table(protein_clusters))
protein_percent_mat <- t(protein_percent_mat)
protein_percent_mat[protein_percent_mat < 0.1] <- 0.1 #setting min values higher to make points in heatmap visible
head(protein_percent_mat)

tmp <- rna_data
tmp[tmp > unname(quantile(rna_exp_mat[rna_exp_mat>0], c(0.2)))] <- 1
tmp[tmp <= unname(quantile(rna_exp_mat[rna_exp_mat>0], c(0.2)))] <- 0
tmp <- aggregate(t(tmp), list(rna_clusters), sum)
tmp2 <- tmp[,2:ncol(tmp)]
rownames(tmp2) <- tmp[,"Group.1"]
rna_percent_mat <- tmp2 / unname(table(rna_clusters))
rna_percent_mat <- t(rna_percent_mat)
rna_percent_mat[rna_percent_mat < 0.1] <- 0.1 #setting min values higher to make points in heatmap visible
head(rna_percent_mat)

#Annotation bars
clusters <- c(rna_clusters, protein_clusters)
cell_count <- c(as.data.frame(table(rna_clusters))[,"Freq"], as.data.frame(table(protein_clusters))[,"Freq"])
modality <- c(rep(c("RNA"), ncol(rna_mean_scaled)), rep(c("protein"), ncol(protein_mean_scaled)))
exp_mat <- cbind(rna_exp_mat, protein_exp_mat)
percent_mat <- cbind(rna_percent_mat, protein_percent_mat)

modality_col <- setNames(c("ivory4", "lightcoral"), c("RNA", "protein"))

column_ha = HeatmapAnnotation(modality=modality,
                              ncells=anno_barplot(cell_count, height = unit(0.5, "cm")),
                              col=list(modality=modality_col),
                              show_legend=T)

#Function to set dot size based on percentage expressed
cell_fun = function(j, i, x, y, w, h, fill){
          grid.rect(x = x, y = y, width = w, height = h, 
                    gp = gpar(col = NA, fill = NA))
          grid.circle(x=x,y=y,r= percent_mat[i, j]/2 * min(unit.c(w, h)),
                      gp = gpar(fill = col_fun(exp_mat[i, j]), col = NA))}

#Function to set dot color based on mean expression
col_fun = circlize::colorRamp2(c(min(exp_mat),(max(exp_mat)-min(exp_mat))/2, max(exp_mat)), viridis(100)[c(1,50,100)])

#Function to set legend size according to percentage expressed
layer_fun = function(j, i, x, y, w, h, fill){
          grid.rect(x = x, y = y, width = w, height = h, 
                    gp = gpar(col = NA, fill = NA))
          grid.circle(x=x,y=y,r= pindex(percent_mat, i, j)/1 * unit(1.5, "mm"),
                      gp = gpar(fill = col_fun(pindex(exp_mat, i, j)), col = NA))}

#Generate legend for percentage expressed
lgd_list = list(
    Legend( labels = c(0,0.25,0.5,0.75,1), title = "percentage expressed",
            graphics = list(
              function(x, y, w, h) grid.circle(x = x, y = y, r = 0 * unit(2, "mm"),
                                               gp = gpar(fill = "black")),
              function(x, y, w, h) grid.circle(x = x, y = y, r = 0.25 * unit(2, "mm"),
                                               gp = gpar(fill = "black")),
              function(x, y, w, h) grid.circle(x = x, y = y, r = 0.5 * unit(2, "mm"),
                                               gp = gpar(fill = "black")),
              function(x, y, w, h) grid.circle(x = x, y = y, r = 0.75 * unit(2, "mm"),
                                               gp = gpar(fill = "black")),
              function(x, y, w, h) grid.circle(x = x, y = y, r = 1 * unit(2, "mm"),
                                               gp = gpar(fill = "black")))
            ))

#Heatmap
set.seed(20231215)
hp <- Heatmap(exp_mat,
        heatmap_legend_param=list(title="expression"),
        column_title = "Dotplot - normalized mean expression and %expressed", 
        top_annotation = column_ha, 
        col=col_fun,
        rect_gp = gpar(type = "none"),
        clustering_distance_columns="pearson", #use euclidean, kendall or pearson
        clustering_method_columns="average", #use centroid, average or single
        layer_fun = layer_fun,
        row_labels=sapply(strsplit(rownames(exp_mat), "_"), "[[", 1),
        cell_fun = cell_fun,
        show_row_dend = F,
        column_dend_height = unit(2, "cm"),
        row_names_gp = gpar(fontsize = 10),
        column_names_gp = gpar(fontsize = 10),
        column_names_rot = 45,
        border = "black")

d1 <- draw( hp, annotation_legend_list = lgd_list)

setEPS()
postscript(file.path(path, "results/Manuscript/1_Figure/public_datasets/Jansky/Jansky_bubbleplot_scaled.eps"), height=6, width=8)
d1
dev.off()
```

We will then look at cluster similarity in the PCA plot.
```{r pca-plot, fig.width=10, message=FALSE}
library("FactoMineR")
library("factoextra")
library("tidyr")

data <- as.data.frame(mean_scaled)

data <- t(data)
data.pca <- FactoMineR::PCA(data, graph=F)
data$modality <- as.factor(modality)

set.seed(20231215)
pca <- fviz_pca_ind(data.pca, repel=T, habillage=data$modality) + scale_color_manual(values=c("lightcoral", "ivory4"))
setEPS()
postscript(file.path(path, "results/Manuscript/1_Figure/public_datasets/Jansky/Jansky_PCA_biplot.eps"), height=6, width=8)
pca
dev.off()

```


