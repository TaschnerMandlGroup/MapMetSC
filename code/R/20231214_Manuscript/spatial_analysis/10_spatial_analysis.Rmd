---
title: "Spatial analysis in primary tumor samples"
author: "LazDaria"
date: "`r Sys.Date()`"
output: 
  workflowr::wflow_html
editor_options:
  chunk_output_type: inline
params: 
  input: "/mnt/Multimodal_Imaging_Daria/Publication/processed_data"
  output: "/mnt/Multimodal_Imaging_Daria/Publication/processed_data/data"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      error=FALSE,
                      messages=FALSE,
                      warning=FALSE)
```

# Spatial analysis in PT {#sp-pt}
Herein, we explore spatial interactions in the primary tumor.

## Load libraries
<details>
   <summary>Load libraries</summary>
   
```{r load-libraries}
library(imcRtools)
library(scales)
library(BiocParallel)
library(RColorBrewer)
library(circlize)
library(patchwork)
library(ggplot2)
library(lisaClust)
library(tidyr)
library(diffcyt)
library(dplyr)
library(CATALYST)
library(ComplexHeatmap)
library(gtools)
library(ggpubr)
library(gridExtra)
library(ggridges)
library(forcats)
```
</details>

## Read data
First, we load the processed and phenotyped single-cell data from [chapter 4](#phenotyping). We perform spatial analysis only in the primary tumor sapmles, since the bone marrow samples are aspirates, where the spatial context is lost. Therefore, we first subset the SPE object to the PT samples first and then load cell neighbors that were computed in [MapMetIP](https://github.com/TaschnerMandlGroup/MapMetIP). Therein, we have constructed a spatial graph by expanding individual high-resolution cell masks by 15 pixels. For the spatial interaction analysis, we will use the metaclusters for non-tumor cells, since these represent the minority in the PT samples, and the celltype level annotations for the tumor cells (majority). 

```{r read-data}
spe <- readRDS(file.path(params$output,"spe_final.rds"))
spe <- spe[,spe$tissue=="PT"] 

spe_neighbors <- read_steinbock(path=params$input, image_file=NULL, panel_file = NULL, intensities_folder = "intensities-0px-PT",regionprops_folder = NULL, graphs_folder="neighbors") 
colnames(spe_neighbors) <- paste0(spe_neighbors$sample_id, "_", spe_neighbors$ObjectNumber)
colPair(spe, "neighborhood") <- colPair(spe_neighbors[,colnames(spe)], "neighborhood")

#celltype 2
spe$celltype_2 <- spe$metacluster
spe[,spe$metacluster=="tumor"]$celltype_2 <- spe[,spe$metacluster=="tumor"]$celltype

# generate new color vector
tumor_names <- unique(spe[,spe$metacluster=="tumor"]$celltype)
metadata(spe)$color_vectors$col_celltype_2 <- metadata(spe)$color_vectors$col_metacluster
metadata(spe)$color_vectors$col_celltype_2 <- c(metadata(spe)$color_vectors$col_celltype_2, metadata(spe)$color_vectors$col_celltype[tumor_names])

#celltype 3
spe$celltype_3 <- spe$metacluster
spe[,spe$metacluster=="T cell" | spe$metacluster=="B cell" | spe$metacluster=="granulocyte" | spe$metacluster=="MO/DC/NK"]$celltype_3 <- "immune"

# generate new color vector
metadata(spe)$color_vectors$col_celltype_3 <- metadata(spe)$color_vectors$col_metacluster
metadata(spe)$color_vectors$col_celltype_3 <- c(metadata(spe)$color_vectors$col_celltype_3, "immune" = "red")
```

## Interaction analysis
Next, we determine the interactions between cells on the celltype_2 level. For each image, the `testInteractions` function computes the averaged cell type interactions and compares this number against an empirical null distribution generated by permuting all cell labels, while maintaining tissue structure.

```{r interaction-analysis}
#spe_red <- spe[,spe$metacluster!="other" & spe$metacluster!="progenitor"]

out <- testInteractions(spe_red, 
                        group_by = "sample_id",
                        label = "metacluster", 
                        colPairName = "neighborhood",
                        BPPARAM = SerialParam(RNGseed = 221029))

saveRDS(out, "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/testInteractions.rds")
```

## Cellular neighborhoods
In a next step, we detect cellular neighborhoods (CNs). Cells are groups into neighborhoods based on celltypes in their proximity. For each cell, the fraction of cells of a celltype among its neighbors, is detected. Based on these metrics, the cells can then be aggregated into neighborhoods. The number of neighborhoods has to be predefined. 

```{r cn-analysis, fig.width=20, fig.height=50}
spe <- aggregateNeighbors(spe, 
                          colPairName = "neighborhood", 
                          aggregate_by = "metadata", 
                          count_by = "celltype_2")

set.seed(220705)

cn_1 <- kmeans(spe$aggregatedNeighbors, centers = 6)
spe$cn_celltypes_2 <- as.factor(cn_1$cluster)

tiff(filename = "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/CNs_graph.tiff", width = 5000, height = 11000, units = "px", res = 300)

plotSpatial(spe, 
            node_color_by = "cn_celltypes_2", 
            img_id = "sample_id", 
            ncols=6,
            node_size_fix = 0.5) +
    scale_color_brewer(palette = "Set3")

dev.off()
```
Lastly, we can visualize the enrichment of cell types within cellular neighborhoods
using the `regionMap` function of the `lisaClust` package.

```{r, fig.height=6, fig.width=5}
setEPS()
postscript(file.path("/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/CNs_enrichment.eps"), height=6, width=5)

regionMap(spe, 
          cellType = "celltype_2",
          region = "cn_celltypes_2")

dev.off()
```
### Differential abundance of CNs

Finally, we will generate a barplot showing the proportions of CNs per sample. To be able to use the diffcyt package, we will first transform the SPE object into a catalyst-compatible object.
```{r transform-data, fig.height=6, fig.width=10}
sce <- SingleCellExperiment(assays=list(counts=assay(spe, "counts"), exprs=assay(spe, "counts")))

#recode metadata on progression
sce$progress <- factor(spe$progression)
progress <- recode(sce$progress, `0` = 'NoProg', `1` = 'Prog')
sce$progress <- as.factor(progress)

#recode metadata on MYCN amplification
sce$mna <- factor(spe$MYCN_amp)
mna <- recode(sce$mna, `1` = 'MNA', `2` = 'het', `0` = 'nMNA', `9` = 'unknown')
sce$mna <- as.factor(mna)

sce$patient <- factor(spe$study_id)
sce$fm_id <- spe$fm_id

sce$sample_id <- factor(paste0(sce$progress, "_", sce$mna, "_", sce$patient, "_", sce$fm_id))

sce$cluster_id <- factor(spe$cn_celltypes_2)
sce$metacluster <- factor(spe$metacluster)

sce$condition <- 'na' 

# Add celltype information to metadata
metadata(sce)$cluster_codes <- data.frame(celltype = factor(spe$cn_celltypes_2))
```

Next, we will generate a barplot showing the proportion of cells assigned to each of the 6 CNs per sample.

```{r cohort-overview}
set.seed(20231103)

p <- plotAbundances(sce, k = "celltype", by = "sample", col_clust=T, k_pal=brewer.pal(6, "Set3"), 
                    linkage="ward.D", distance="manhattan") 

setEPS()
postscript("/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/CNs_barplot.eps", height=12, width=20)
p
dev.off()
```

We will generate a dendogram for the hierarchical clustering of barplots.

```{r dendogram, fig.height=8, fig.width=7}
#Dendogram
set.seed(20231103)
wide_df <- p$data %>%
  select(-condition) %>%
  pivot_wider(names_from = cluster_id, values_from = Freq)

wide_df <- data.frame(wide_df)
rownames(wide_df) <- wide_df$sample_id
wide_df <- wide_df %>% select(-sample_id)

dist_matrix <- dist(wide_df, method = "manhattan")
hc <- hclust(dist_matrix, method = "ward.D")

setEPS()
postscript("/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/CNs_dendogram.eps", height=12, width=20)
plot(hc)
dev.off()
```

In addition, we will plot the metadata to these samples in the respective order.

```{r plot-metadata}
clustered_samples <- levels(p$data$sample_id)
sce$sample_id <- factor(sce$sample_id, levels=clustered_samples)

#access sample-level data
sample_summary <- as.data.frame(colData(sce)) %>%
  group_by(sample_id) %>%
  summarize(mna = first(mna), 
            progress=first(progress),
  )

sample_summary <- as.data.frame(sample_summary)
rownames(sample_summary) <- sample_summary$sample_id
sample_summary <- sample_summary %>% select(-sample_id)


#assign color codes
col_code <- c("MNA"=rgb(202,0,32, maxColorValue = 255),
              "het"=rgb(146,197,222, maxColorValue = 255),
              "nMNA"=rgb(5,113,176, maxColorValue = 255),
              "unknown"="white",
              "Prog"=rgb(202,0,32, maxColorValue = 255),
              "NoProg"=rgb(5,113,176, maxColorValue = 255)
              )


# Plot metadata
setEPS()
postscript("/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/CNs_metadata.eps", height=12, width=20)
columnAnnotation(MYCN_amp=sample_summary$mna, col=list(MYCN_amp=col_code)) %v%
  columnAnnotation(progression=sample_summary$progress, col=list(progression=col_code)) 
dev.off()
```

We then compare the abundance of cellular communities between nMNA and MNA samples.
We first prepare data for DA analysis using the `diffcyt` package. 

```{r transform-data2, fig.height=6, fig.width=10}
keep_rows <- rowData(spe)$use_channel 
keep_cols <- spe$MYCN_amp==0 | spe$MYCN_amp==1
sce <- SingleCellExperiment(assays=list(counts=assay(spe[keep_rows,keep_cols], "counts"), exprs=assay(spe[keep_rows,keep_cols], "counts")))

#recode metadata on progression
sce$progress <- factor(spe[keep_rows,keep_cols]$progression)
progress <- recode(sce$progress, `0` = 'NoProg', `1` = 'Prog')
sce$progress <- as.factor(progress)

#recode metadata on MYCN amplification
sce$mna <- factor(spe[keep_rows,keep_cols]$MYCN_amp)
mna <- recode(sce$mna, `1` = 'MNA', `2` = 'het', `0` = 'nMNA', `9` = 'unknown')
sce$mna <- as.factor(mna)

sce$patient <- factor(spe[keep_rows,keep_cols]$study_id)
sce$fm_id <- spe[keep_rows,keep_cols]$fm_id

sce$sample_id <- factor(paste0(sce$progress, "_", sce$mna, "_", sce$patient, "_", sce$fm_id))

sce$cluster_id <- factor(spe[keep_rows,keep_cols]$cn_celltypes_2)
sce$metacluster <- factor(spe[keep_rows,keep_cols]$metacluster)

sce$condition <- sce$mna 

# Add experiment_info
metadata(sce)$experiment_info <- as.data.frame(colData(sce)) %>% group_by(sample_id,patient, mna, condition, progress) %>% 
    summarise(n_cells=n(),.groups = 'drop') %>%
    as.data.frame()

# Add celltype information to metadata
metadata(sce)$cluster_codes <- data.frame(celltype = factor(spe[keep_rows,keep_cols]$cn_celltypes_2))

# Define cell type and state markers
type_markers <- c("MPO_Y89_mean", "CD44_In115_mean", "CD11b_Nd142_mean", "HLA-DR_Nd143_mean", "PRPH_Nd144_mean", "HLA-ABC_Sm147_mean", "CD20_Nd148_mean", "LUM_Sm149_mean", "CD11c_Nd150_mean",
                  "CD24_Eu151_mean", "CD3_Sm152_mean", "CD45_Eu153_mean", "CD8a_Sm154_mean", "GD2_Gd155_mean", "CD34_Gd156_mean", "CD10_Gd158_mean", "CXCR4_Tb159_mean","SOX10_Dy162_mean",
                  "FOXP3_Dy163_mean", "CHGA_Dy164_mean", "GATA3_Er168_mean", "CD56_Er170_mean", "CD4_Yb171_mean", "ELAVL4_Yb174_mean", "CD14_Lu175_mean", "Vimentin_Pt196_mean", "CD15_Bi209_mean")

state_markers <- c("CD274_Gd160_mean", "S100B_Dy161_mean", "CD279_Ho165_mean", "Ki-67_Tm169_mean", "GZMB_Yb173_mean")
```

```{r prepare-data}
#list of samples as input to diffcyt methods
df_list <- lapply(unique(sce$sample_id), function(x){as.data.frame(t(counts(sce[,sce$sample_id==x])))})
names(df_list) <- unique(sce$sample_id)

#experiment info
experiment_info <- metadata(sce)$experiment_info
experiment_info <- experiment_info[match(names(df_list),experiment_info$sample_id),]

#marker info
channel_name <- sapply(strsplit(rownames(rowData(spe[keep_rows,])), "_"), "[[", 2)
marker_name <- sapply(strsplit(rownames(rowData(spe[keep_rows,])), "_"), "[[", 1)
marker_class <-ifelse(rownames(spe[keep_rows,]) %in% type_markers, "type",
                                    ifelse(rownames(spe[keep_rows,]) %in% state_markers, "state", 
                                    "other"))
row_data <- data.frame(cbind(channel_name, marker_name), row.names=marker_name)
row_data$marker_class <- as.factor(marker_class)

marker_info <-  row_data

#prepare data into format for diffcyt pipeline 
d_se <- prepareData(df_list, experiment_info, marker_info)
rowData(d_se)$cluster_id <- sce[,rownames(d_se)]$cluster_id 
metadata(d_se)$cluster_codes <- metadata(sce)$cluster_codes

# Transform data
d_se <- transformData(d_se)

# Calculate counts
d_counts <- calcCounts(d_se)
```

Subsequently, we perform the DA analysis comparing celltype proportions between to genetic subgroups. 

```{r da-analysis}
# Create design matrix
design <- createDesignMatrix(experiment_info, cols_design = "condition")

# Create contrast matrix
contrast <- createContrast(c(0, 1)) 
nrow(contrast) == ncol(design)

# Test for differential abundance (DA) of clusters
res_DA <- testDA_voom(d_counts,design, contrast
                       )

FDR_cutoff = 0.1
rowData(res_DA)[rowData(res_DA)$p_adj<FDR_cutoff,]
res<- data.frame(rowData(res_DA))
```

Finally, we visualize DA results in boxplots and barplots showing the logFC.

```{r visualize-da, fig.width=12, fig.height=10}
p <- plotAbundances(sce, k = "celltype", by = "sample") 
comparisons <- c("nMNAvsMNA")

plot_list_fc <- list()

for(i in 1:length(unique(p$data$cluster_id))){
  cluster_name <- unique(p$data$cluster_id)[i]
  proportions <- data.frame(p$data[p$data$cluster_id == cluster_name, c("sample_id", "condition", "Freq")])
  
  p_adj <- c()
  group1 <- c()
  group2 <- c()
  logFC <- c()
  
  for(j in 1:1){
  stats <- res
  p_adj <- c(p_adj, round(stats[rownames(stats)==droplevels(cluster_name), "p_adj"],3))
  logFC <- c(logFC, -1*round(stats[rownames(stats)==droplevels(cluster_name), "logFC"],2))
  group1 <- c(group1, unlist(strsplit(comparisons[j], "vs"))[1])
  group2 <- c(group2, unlist(strsplit(comparisons[j], "vs"))[2])
  }

  stats_df <- data.frame(p_adj=p_adj, group1=group1, group2=group2, logFC=logFC)
  stats_df$p_adj_signif <- stars.pval(stats_df$p_adj)
  stats_df$p_adj_signif[stats_df$p_adj_signif==" "] <- "ns"
  stats_df$p_fc <- paste0(stats_df$logFC, " (", stats_df$p_adj, ")", " (", stats_df$p_adj_signif, ")")
  
  color <- brewer.pal(6, "Set3")[cluster_name]
  
  plot_list_fc[[i]] <- ggboxplot(proportions, x = "condition", y = "Freq", order=c("nMNA", "MNA"),
              color = "condition", palette =c(color, color), 
              add.params = list(size = 1.5),
              add = "jitter", 
              title=cluster_name, show.legend = F) +
      stat_pvalue_manual(
        stats_df,
        y.position = max(proportions$Freq),
        step.increase = 0.4,
        label = "p_fc"
        )  +
      theme(aspect.ratio = 1.5, legend.position="none") +
      scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
}

setEPS()
postscript("/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/CNs_DA_boxplot.eps", height=26, width=20)
grid.arrange(grobs = plot_list_fc, ncol = 6)
   dev.off()
```
## Patch detection
Subsequently, we will detect tumor patches. We will first detect connected sets of tumor cells with a predefined min. number of cells making up a patch and then we expand the concave hull around the patch by 1 pixel.

```{r patchDetection-1, fig.height=20, fig.width=20}
spe <- patchDetection(spe, 
                      patch_cells = spe$metacluster == "tumor",
                      img_id = "sample_id",
                      min_patch_size=20,
                      expand_by=1,
                      colPairName = "neighborhood")
```
We can now plot the tumor patch in the neighborhood graph of individual samples.

```{r plot-patch}
tiff(filename = "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/16-006_GD2.tiff", width = 2000, height = 2000, units = "px", res = 300)

plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-006_TU_003"], 
            node_color_by = "GD2_Gd155_mean", 
            assay_type = "counts",
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "neighborhood", 
            nodes_first = FALSE, 
            node_size_by = "area", 
            directed = FALSE,
            edge_color_fix = "grey") + 
    scale_size_continuous(range = c(0.1, 2)) +
    ggtitle("GD2")

dev.off()

tiff(filename = "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/16-006_patch.tiff", width = 2000, height = 2000, units = "px", res = 300)

plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-006_TU_003"], 
            node_color_by = "patch_id", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none")

dev.off()
```
Then we determine the frequency of cells within the patch belonging to a metacluster per sample with respect to progression status of the respective patient.

```{r patch-freq, fig.width=14, fig.height=12}
variable <- "progression"
plot_list <- list()
celltypes <- unique(spe$metacluster)

for(i in 1:length(unique(celltypes))){
  
  c <- celltypes[i]
  
  cell_freq_per_patch <- colData(spe) %>% as_tibble() %>%
      group_by(patch_id, sample) %>%
      summarize(cell_count = sum(metacluster == c),
                patch_size = n(),
                cell_freq = cell_count / patch_size) %>%
      filter(!is.na(patch_id)) 
    
  mean_cell_freq_per_sample <- cell_freq_per_patch %>%
    group_by(sample) %>%
    summarise(mean_cell_freq = mean(cell_freq, na.rm = TRUE))%>%
    arrange(desc(mean_cell_freq))
  
  df <- data.frame(
    sample = spe$sample,
    condition = colData(spe)[,variable]
  )
  
  progression_per_sample <- df %>%
    group_by(sample) %>%
    summarise(condition = first(condition))
  
  combined_data <- mean_cell_freq_per_sample %>%
    left_join(progression_per_sample, by = "sample")
  
  # Calculate log2FC
  log2fc_df <- combined_data %>%
    group_by(condition) %>%
    summarise(mean_freq = mean(mean_cell_freq, na.rm = TRUE)) %>%
    spread(condition, mean_freq) %>%
    mutate(log2FC = log2(`1` / `0`))
  
  stats_df <- compare_means(mean_cell_freq ~ condition,  
                            method = "wilcox.test",  
                            data = combined_data) 
    
  stats_df$p_adj_signif <- stars.pval(stats_df$p.adj)
  stats_df$p_adj_signif[stats_df$p_adj_signif==" "] <- "ns"
  stats_df$p_long <- paste0("log2FC: ", round(log2fc_df$log2FC, 2), 
                            " (", stats_df$p.adj, " ", stats_df$p_adj_signif, ")")
  
  color <- unname(metadata(spe)$color_vectors$col_metacluster[as.character(c)])
  
  plot_list[[c]] <- ggboxplot(combined_data, x = "condition", y = "mean_cell_freq",
                  color = "condition", palette =c(color, color),
                  add.params = list(size = 3),
                  add = "jitter",
                  title=c) + 
                  stat_pvalue_manual(stats_df, label = "p_long", y.position = max(combined_data$mean_cell_freq), step.increase = 0.4,) +
                  theme(aspect.ratio = 1.6, legend.position="none") +
      scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
                  
  
}

setEPS()
postscript("/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/metacluster_freq_patch.eps", height=26, width=20)
grid.arrange(grobs = plot_list, ncol = 6)
   dev.off()
```

We repeat the same for immune cells overall. 

```{r patch-freq-immune}
variable <- "progression"
  
c <- "immune"

cell_freq_per_patch <- colData(spe) %>% as_tibble() %>%
    group_by(patch_id, sample) %>%
    summarize(cell_count = sum(celltype_3 == c),
              patch_size = n(),
              cell_freq = cell_count / patch_size) %>%
    filter(!is.na(patch_id)) 
  
mean_cell_freq_per_sample <- cell_freq_per_patch %>%
  group_by(sample) %>%
  summarise(mean_cell_freq = mean(cell_freq, na.rm = TRUE))%>%
  arrange(desc(mean_cell_freq))

df <- data.frame(
  sample = spe$sample,
  condition = colData(spe)[,variable]
)

progression_per_sample <- df %>%
  group_by(sample) %>%
  summarise(condition = first(condition))

combined_data <- mean_cell_freq_per_sample %>%
  left_join(progression_per_sample, by = "sample")

# Calculate log2FC
log2fc_df <- combined_data %>%
  group_by(condition) %>%
  summarise(mean_freq = mean(mean_cell_freq, na.rm = TRUE)) %>%
  spread(condition, mean_freq) %>%
  mutate(log2FC = log2(`1` / `0`))

stats_df <- compare_means(mean_cell_freq ~ condition,  
                          method = "wilcox.test",  
                          data = combined_data) 
  
stats_df$p_adj_signif <- stars.pval(stats_df$p.adj)
stats_df$p_adj_signif[stats_df$p_adj_signif==" "] <- "ns"
stats_df$p_long <- paste0("log2FC: ", round(log2fc_df$log2FC, 2), 
                          " (", stats_df$p.adj, " ", stats_df$p_adj_signif, ")")

color <- unname(metadata(spe)$color_vectors$col_celltype_3[as.character(c)])

p <- ggboxplot(combined_data, x = "condition", y = "mean_cell_freq",
                color = "condition", palette =c(color, color),
                add.params = list(size = 3),
                add = "jitter",
                title=c) + 
                stat_pvalue_manual(stats_df, label = "p_long", y.position = max(combined_data$mean_cell_freq), step.increase = 0.4,) +
                theme(aspect.ratio = 1.6, legend.position="none") +
    scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
                  

setEPS()
postscript("/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/metacluster_freq_patch-immune.eps", height=5, width=5)
p
dev.off()
```
### Distance to tumor-stroma border
Based on detected patches, the distance to the tumor stroma border can be computed. Therefore the [minDistToCells](https://bodenmillergroup.github.io/imcRtools/reference/minDistToCells.html) can be used. Negative values indicate represent cells within patches and positive values cells outside of patches.
```{r minDistCells}
spe <- minDistToCells(spe, 
                      x_cells = !is.na(spe$patch_id), 
                      img_id = "sample_id")

tiff(filename = "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/16-006_distance_to_border.tiff", width = 2000, height = 2000, units = "px", res = 300)
plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-006_TU_003"], 
            node_color_by = "distToCells", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_gradient2(low = "dark blue", mid = "white", high = "dark red")
dev.off()
```

The distance distribution per celltype can be shown in ridge plots.

```{r ridges-distance, fig.height=15,fig.width=15}
setEPS()
postscript("/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/ridge_distance.eps", height=26, width=20)
ggplot(as.data.frame(colData(spe)) %>%
         mutate(celltype_2 = fct_reorder(celltype_2, distToCells, .fun = median))) + 
  stat_density_ridges(aes(distToCells, celltype_2, fill = celltype_2), 
                      quantiles = c(0.5), quantile_lines = TRUE, scale = 3) +
  #geom_density_ridges(aes(distToCells, celltype_2, fill = celltype_2)) +
  geom_vline(xintercept = 0, color = "dark red", linewidth = 2) +
  scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype_2) +
  theme_ridges()
dev.off()
```
Based on the calculated distance for each cell, three compartments - tumor core, tumor/stroma border and stroma - can be defined using a distance threshold. Image `20221018_20220906_03-018_TU_001` lacks patches, therefore all cells are defined as `stroma` for this image.

```{r spatial-compartments}
threshold <- 100

spe$compartment <- "stroma"
spe[, abs(spe$distToCells) <= threshold & spe$sample_id != "20221018_20220906_03-018_TU_001"]$compartment <- "border"
spe[,spe$border != "border" & spe$distToCells<0 & spe$sample_id != "20221018_20220906_03-018_TU_001"]$compartment <- "core"
```

### DA analysis in spatial compartments

Next, we will plot the differential abundance of metaclusters with respect to spatial compartment on a sample level. Let's again convert the SPE object into a catalyst-compatible object. Decide whether you want to compare `tumor` celltypes or `immune` metaclusters by setting the variable `cells`. Furthermore, select which compartments to compare, by setting `compare` to `core-border`, `core-stroma` or `border-stroma`. 

```{r catalyst-comp-object3, fig.width=12}
cells <- "immune"
compare <- "core-border"

if (cells =="immune"){
  order <- c("T cell", "B cell", "MO/DC/NK", "granulocyte")
  keep_cols <- spe$metacluster=="T cell" | spe$metacluster=="B cell" | spe$metacluster=="MO/DC/NK" | spe$metacluster=="granulocyte"
  color <- metadata(spe)$color_vectors$col_celltype_2
}else{
  order <- c("early SYM-like TC","CD24+ marker-lo TC", "CD24- marker-lo TC", "GD2lo TC", "Ki67hi TC", "CHGAhi TC", "CXCR4hi TC", "GATA3hi TC", "bridge-like TC", "CD44+ mes-like TC")
  keep_cols <- spe$metacluster=="tumor"
  color <- metadata(spe)$color_vectors$col_celltype_2
}

keep_cols <- keep_cols & (spe$compartment == strsplit(compare, "-")[[1]][1] | spe$compartment == strsplit(compare, "-")[[1]][2])
keep_rows <- rowData(spe)$use_channel 
sce <- SingleCellExperiment(assays=list(counts=assay(spe, "counts")[keep_rows,keep_cols], exprs=assay(spe, "counts")[keep_rows,keep_cols]))

sce$fm_id <- spe[keep_rows,keep_cols]$fm_id
sce$compartment <- factor(spe[keep_rows,keep_cols]$compartment)

#split samples into individual compartments
sce$sample_id <- factor(paste0(sce$fm_id, "_", sce$compartment))
sce$sample <- factor(spe[keep_rows,keep_cols]$sample)

sce$condition <- sce$compartment

sce$cluster_id <- factor(spe[keep_rows,keep_cols]$celltype_2, levels=order)                                                                     

sce$metacluster <- factor(spe[keep_rows,keep_cols]$metacluster)
metadata(sce)$cluster_codes <- data.frame(celltype = factor(spe[keep_rows,keep_cols]$celltype_2, levels=order))

# Add metadata
metadata(sce)$experiment_info <- as.data.frame(colData(sce)) %>% group_by(sample_id, condition, sample) %>% 
    summarise(n_cells=n(),.groups = 'drop') %>%
    as.data.frame()

# Define cell_type_markers 
type_markers <- c("MPO_Y89_mean", "CD44_In115_mean", "CD11b_Nd142_mean", "HLA-DR_Nd143_mean", "PRPH_Nd144_mean", "HLA-ABC_Sm147_mean", "CD20_Nd148_mean", "LUM_Sm149_mean", "CD11c_Nd150_mean",
                  "CD24_Eu151_mean", "CD3_Sm152_mean", "CD45_Eu153_mean", "CD8a_Sm154_mean", "GD2_Gd155_mean", "CD34_Gd156_mean", "CD10_Gd158_mean", "CXCR4_Tb159_mean","SOX10_Dy162_mean",
                  "FOXP3_Dy163_mean", "CHGA_Dy164_mean", "GATA3_Er168_mean", "CD56_Er170_mean", "CD4_Yb171_mean", "ELAVL4_Yb174_mean", "CD14_Lu175_mean", "Vimentin_Pt196_mean", "CD15_Bi209_mean")

# Define cell_state_markers 
state_markers <- c("CD274_Gd160_mean", "S100B_Dy161_mean", "CD279_Ho165_mean", "Ki-67_Tm169_mean", "GZMB_Yb173_mean")

# Add to sce
rowData(sce)$marker_class <- ifelse(rownames(sce) %in% type_markers, "type",
                                    ifelse(rownames(sce) %in% state_markers, "state", 
                                    "other"))

plotAbundances(sce, k = "celltype", by = "sample", k_pal=color) 
```

We first prepare data for DA analysis using the `diffcyt` package. 

```{r prepare-data}
#list of samples as input to diffcyt methods
df_list <- lapply(unique(sce$sample_id), function(x){as.data.frame(t(counts(sce[,sce$sample_id==x])))})
names(df_list) <- unique(sce$sample_id)

#experiment info
experiment_info <- metadata(sce)$experiment_info
experiment_info <- experiment_info[match(names(df_list),experiment_info$sample_id),]

#marker info
channel_name <- sapply(strsplit(rownames(rowData(spe)[keep_rows,]), "_"), "[[", 2)
marker_name <- sapply(strsplit(rownames(rowData(spe)[keep_rows,]), "_"), "[[", 1)
marker_class <-ifelse(rownames(spe)[keep_rows] %in% type_markers, "type",
                                    ifelse(rownames(spe)[keep_rows] %in% state_markers, "state", 
                                    "other"))
row_data <- data.frame(cbind(channel_name, marker_name), row.names=marker_name)
row_data$marker_class <- as.factor(marker_class)

marker_info <-  row_data

#prepare data into format for diffcyt pipeline 
d_se <- prepareData(df_list, experiment_info, marker_info)
rowData(d_se)$cluster_id <- sce[,rownames(d_se)]$cluster_id 
metadata(d_se)$cluster_codes <- metadata(sce)$cluster_codes

# Transform data
d_se <- transformData(d_se)

# Calculate counts
d_counts <- calcCounts(d_se)
```

Subsequently, we perform the DA analysis comparing `r cells` celltype/metacluster proportions between paired compartments, i.e. from the same sample.

```{r da-analysis}
design <- createDesignMatrix(experiment_info, cols_design = c("condition", "sample")) 
contrast <- createContrast(c(0, 1, rep(0, length(unique(experiment_info$sample))-1))) #paired
nrow(contrast) == ncol(design)

# Test for differential abundance (DA) of clusters
res_DA <- testDA_edgeR(d_counts,design, contrast, 
                       min_cells=3, 
                       min_samples=round(dim(d_counts)[2]*0.2)
                       )


FDR_cutoff = 0.1
rowData(res_DA)[rowData(res_DA)$p_adj<FDR_cutoff,]
res<- data.frame(rowData(res_DA))
```

## Visualization of DA results
Finally, we visualize DA results in boxplots.

```{r visualize-da, fig.width=12, fig.height=12}
p <- plotAbundances(sce, k = "celltype", by = "sample")

comparisons <- c(paste0(strsplit(compare, "-")[[1]][1], "vs", strsplit(compare, "-")[[1]][2]))
ord <- c(strsplit(compare, "-")[[1]][1], strsplit(compare, "-")[[1]][2])

plot_list_fc <- list()

for(i in 1:length(unique(p$data$cluster_id))){
  cluster_name <- unique(p$data$cluster_id)[i]
  proportions <- data.frame(p$data[p$data$cluster_id == cluster_name, c("sample_id", "condition", "Freq")])
  
  p_adj <- c()
  group1 <- c()
  group2 <- c()
  logFC <- c()
  
  for(j in 1:1){
  stats <- res
  p_adj <- c(p_adj, round(stats[rownames(stats)==droplevels(cluster_name), "p_adj"],3))
  logFC <- c(logFC, round(stats[rownames(stats)==droplevels(cluster_name), "logFC"],2))
  group1 <- c(group1, unlist(strsplit(comparisons[j], "vs"))[1])
  group2 <- c(group2, unlist(strsplit(comparisons[j], "vs"))[2])
  }

  stats_df <- data.frame(p_adj=p_adj, group1=group1, group2=group2, logFC=logFC)
  stats_df$p_adj_signif <- stars.pval(stats_df$p_adj)
  stats_df$p_adj_signif[stats_df$p_adj_signif==" "] <- "ns"
  stats_df$p_fc <- paste0(stats_df$logFC, " (", stats_df$p_adj, ")", " (", stats_df$p_adj_signif, ")")

  color <- unname(metadata(spe)$color_vectors$col_celltype_2[as.character(cluster_name)]) 
  
  plot_list_fc[[i]] <- ggboxplot(proportions, x = "condition", y = "Freq", order=ord,
              color = "condition", palette =c(color, color), 
              add.params = list(size = 1.5),
              add = "jitter", 
              title=cluster_name, show.legend = F) +
      stat_pvalue_manual(
        stats_df,
        y.position = max(proportions$Freq),
        step.increase = 0.4,
        label = "p_fc"
        )  +
      theme(aspect.ratio = 1.5, legend.position="none") +
      scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
}

setEPS()
postscript(paste0("/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/compartment_DA_boxplots_", compare, cells, ".eps"), height=26, width=20)
grid.arrange(grobs = plot_list_fc, ncol = 6)
   dev.off()
```

We will plot the logFC for the comparisons between conditions in a barplot.
```{r barplot-logFC, fig.width=7, fig.height=8}
df <- res[, c("logFC", "p_adj")]
df$p_adj_signif <- stars.pval(df$p_adj)
df$p_adj_signif[df$p_adj_signif==" "] <- "ns"
df$cluster <- rownames(df)

p <- ggplot(df, aes(fill=cluster, y=logFC, x=cluster)) + 
  ggtitle(colnames(contrasts)[i]) +
  geom_bar(
    stat="identity",
    position="dodge",
    show.legend = F) + 
  scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype_2) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  geom_text(aes(label = p_adj_signif), vjust = 0)

setEPS()
postscript(paste0("/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/compartment_DA_dodge_", compare, cells, ".eps"), height=6, width=6)
p
dev.off()
```



Finally, we save the R object.
```{r save-rds}
saveRDS(spe, "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/Manuscript/ADD_4_Figure/R/spe_spatial.RDS")
```


## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>