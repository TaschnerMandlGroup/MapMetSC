---
title: "CCC analysis: MYCNA vs. non-MYCNA"
author: "Sara Wernig-Zorc"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: yes
    toc_depth: 5
    toc_float: yes
    collapsed: false
    code_folding: hide
    highlight: pygments
    theme: spacelab
    df_print: paged
params:
  input: "/home/data/MapMet/"
  out: "/home/out/MapMet/"
  GO_db: "/home/sara_wz/annotation/GSEA_GeneSetEnrichments"
  markers: "/home/sara_wz/annotation/MES_ADRN/"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      tidy = TRUE, 
                      error = FALSE, 
                      messages = FALSE,
                      warning = FALSE)

library(parallel)
future::plan(strategy = 'future::multicore', workers = 12)
options(future.globals.maxSize = 8 * 10^9)

source("/home/sara_wz/MapMet_project/MapMetSC/code/R/CCC_analysis/00_MapMet_color_code.R")

print(params)
```

```{r libs}
library(SingleCellExperiment)
library(dplyr)
library(ggplot2)
library(nichenetr)
library(multinichenetr)
```


# ___Load data___

```{r load Fetahu2023 dataset, eval=FALSE, include=FALSE}
metadata <- readRDS(paste0(params$input,"/fetahu.scRNA.2023/data/metadata.rds"))
scrna_data <- readRDS(paste0(params$input,"/fetahu.scRNA.2023/data/rna_decontaminated.rds"))

rna <- as.Seurat(scrna_data, data=NULL)
rna <- RenameAssays(object = rna, originalexp = 'RNA')

rna@active.ident <- setNames(pull(metadata[match(metadata$cell,colnames(rna)),"cellont_cluster"], "cellont_cluster"),pull(metadata[match(metadata$cell,colnames(rna)), "cell"], "cell"))
DefaultAssay(rna) <- "RNA"

true_label <- rna@active.ident

rna$original_celltype <- rna@active.ident

rna@meta.data
```

# ___Define comparison groups___

Comparison: MYCN amplified vs. non-MYCN amplified
Cell types of inetrest: T-cells, Monocytes and tumor cells

```{r define comparison groups - PART I, eval=FALSE, include=FALSE}
# STEP 1
Idents(rna) <- rna@meta.data$original_celltype

# define which clusters to compare
clusters_of_interest <- c("T (5)", "T (6)", "T (9)", 
                          "M (1)", "M (2)", "M (10)",
                          "NB (8)") 
# Clusters T (18) and M (15) were excluded due to low cell numbers (<100)

rna <- subset(rna, idents = clusters_of_interest, invert = FALSE)
metadata <- rna@meta.data

saveRDS(rna, file = paste0(params$out,"Rds/fetahu2023_T_MO_NB.Rds"))

# STEP 2

Idents(rna) <- rna@meta.data$group

MYCNA_patients <- "II"
nonMYCNA_patients <- c("III","IV")
control_patients <- "I"

MYCNA <- subset(rna, idents = MYCNA_patients, invert = FALSE)
nonMYCNA <- subset(rna, idents = nonMYCNA_patients, invert = FALSE)
control <- subset(rna, idents = control_patients, invert = FALSE)

rna@meta.data$new_groups <- NA
rna@meta.data <- rna@meta.data %>% mutate(new_groups = ifelse((rna@meta.data$group == MYCNA_patients ),  "MYCNA","non_MYCNA"))


# STEP 3
Idents(MYCNA) <- MYCNA@meta.data$original_celltype
Idents(nonMYCNA) <- nonMYCNA@meta.data$original_celltype
Idents(control) <- control@meta.data$original_celltype

# STEP 4
MYCNA$original_celltype = droplevels(MYCNA$original_celltype, 
                                     exclude = setdiff(levels(MYCNA$original_celltype),
                                                       unique(MYCNA$original_celltype)))

nonMYCNA$original_celltype = droplevels(nonMYCNA$original_celltype, 
                                        exclude = setdiff(levels(nonMYCNA$original_celltype),
                                                          unique(nonMYCNA$original_celltype)))

control$original_celltype = droplevels(control$original_celltype, 
                                     exclude = setdiff(levels(control$original_celltype),
                                                       unique(control$original_celltype)))


saveRDS(MYCNA, file = paste0(params$out,"Rds/fetahu2023_T_MO_NB_MYCNA.Rds"))
saveRDS(nonMYCNA, file = paste0(params$out,"Rds/fetahu2023_T_MO_NB_nonMYCNA.Rds"))
saveRDS(control, file = paste0(params$out,"Rds/fetahu2023_T_MO_NB_control.Rds"))

```


```{r load Rds}
rna <- readRDS(file = paste0(params$out,"Rds/fetahu2023_T_MO_NB.Rds"))
```

# ___UMAP vizualization per group___

```{r sanity check, eval=FALSE, fig.height=5, fig.width=7, include=FALSE, paged.print=FALSE}
DimPlot(MYCNA, cols = COLOR_CODE_RNA_v3)
DimPlot(nonMYCNA, cols = COLOR_CODE_RNA_v3)
DimPlot(control, cols = COLOR_CODE_RNA_v3)
```


# ___Differential CCC analysis with MultiNicheNet___

MultiNicheNet analysis 
1. MYCNA vs. non-MYCNA (ATRXm and sporadic)
2. non-MYCNA (ATRXm and sporadic) vs. MYCNA
3. MYCNA vs. Sporadic
4. Sporadic vs. MYCNA


```{r MultiNicheNet analysis}
Idents(rna) <- rna@meta.data$group

# 1. prepare db

organism = "human"
options(timeout = 120)

if(organism == "human"){
  lr_network_all = 
    readRDS(url(
      "https://zenodo.org/record/10229222/files/lr_network_human_allInfo_30112033.rds"
      )) %>% 
    mutate(
      ligand = convert_alias_to_symbols(ligand, organism = organism), 
      receptor = convert_alias_to_symbols(receptor, organism = organism))
  lr_network_all = lr_network_all  %>% 
    mutate(ligand = make.names(ligand), receptor = make.names(receptor)) 
  lr_network = lr_network_all %>% 
    distinct(ligand, receptor)
  ligand_target_matrix = readRDS(url(
    "https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final.rds"
    ))
  colnames(ligand_target_matrix) = colnames(ligand_target_matrix) %>% 
    convert_alias_to_symbols(organism = organism) %>% make.names()
  rownames(ligand_target_matrix) = rownames(ligand_target_matrix) %>% 
    convert_alias_to_symbols(organism = organism) %>% make.names()
  lr_network = lr_network %>% filter(ligand %in% colnames(ligand_target_matrix))
  ligand_target_matrix = ligand_target_matrix[, lr_network$ligand %>% unique()]
  
} else if(organism == "mouse"){
  
  lr_network_all = readRDS(url(
    "https://zenodo.org/record/10229222/files/lr_network_mouse_allInfo_30112033.rds"
    )) %>% 
    mutate(
      ligand = convert_alias_to_symbols(ligand, organism = organism), 
      receptor = convert_alias_to_symbols(receptor, organism = organism))
  
  lr_network_all = lr_network_all  %>% 
    mutate(ligand = make.names(ligand), receptor = make.names(receptor)) 
  lr_network = lr_network_all %>% 
    distinct(ligand, receptor)
  
  ligand_target_matrix = readRDS(url(
    "https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final_mouse.rds"
    ))
  
  colnames(ligand_target_matrix) = colnames(ligand_target_matrix) %>% 
    convert_alias_to_symbols(organism = organism) %>% make.names()
  rownames(ligand_target_matrix) = rownames(ligand_target_matrix) %>% 
    convert_alias_to_symbols(organism = organism) %>% make.names()
  
  lr_network = lr_network %>% filter(ligand %in% colnames(ligand_target_matrix))
  ligand_target_matrix = ligand_target_matrix[, lr_network$ligand %>% unique()]
}

# 2.
sce = Seurat::as.SingleCellExperiment(rna, assay = "RNA")
head(colData(sce))
#colnames(sce)


# 3.
SummarizedExperiment::colData(sce)$sample = SummarizedExperiment::colData(sce)$sample %>% make.names()
SummarizedExperiment::colData(sce)$group = SummarizedExperiment::colData(sce)$group %>% make.names()
SummarizedExperiment::colData(sce)$original_celltype = SummarizedExperiment::colData(sce)$original_celltype %>% make.names()

sample_id = "sample"
group_id = "group"
celltype_id = "original_celltype"

# 4. 
covariates = "sample"
batches = NA

# 5.
contrasts_oi = c("'(IV+III)/2'II/2','II-(IV+III)/2'")

# Note the format to indicate the contrasts! This formatting should be adhered to very strictly, and white spaces are not allowed! Check ?get_DE_info for explanation about how to define this well. The most important points are that: *each contrast is surrounded by single quotation marks *contrasts are separated by a comma without any white space *all contrasts together are surrounded by double quotation marks.

# 6.
contrast_tbl = tibble(contrast =  c("'(IV+III)/2'II/2','II-(IV+III)/2'"), 
                      group = c("IV","III","II"))

# 7. Define the sender and receiver cell types of interest
# all clusters
senders_oi = SummarizedExperiment::colData(sce)[,celltype_id] %>% unique()
receivers_oi = SummarizedExperiment::colData(sce)[,celltype_id] %>% unique()
sce = sce[, SummarizedExperiment::colData(sce)[,celltype_id] %in% 
            c(senders_oi, receivers_oi)
          ]

# only select conditions
conditions_keep = c("IV","III","II")
sce = sce[, SummarizedExperiment::colData(sce)[,group_id] %in% 
            conditions_keep
          ]
# 8. MultiNicheNet core analysis
# Cell-type filtering: determine which cell types are sufficiently present
min_cells = 5 # reducing the cut-off to not lose tumor cells (sporadic NB, low tumor numbers)
abundance_info = get_abundance_info(
  sce = sce, 
  sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, 
  min_cells = min_cells, 
  senders_oi = senders_oi, receivers_oi = receivers_oi, 
  batches = batches
  )

# The first plot visualizes the number of cells per celltype-sample combination, 
# and indicates which combinations are removed during the DE analysis because 
# there are less than min_cells in the celltype-sample combination.
abundance_info$abund_plot_sample

# Actual filtering
sample_group_celltype_df = abundance_info$abundance_data %>% 
  filter(n > min_cells) %>% 
  ungroup() %>% 
  distinct(sample_id, group_id) %>% 
  cross_join(
    abundance_info$abundance_data %>% 
      ungroup() %>% 
      distinct(celltype_id)
    ) %>% 
  arrange(sample_id)

abundance_df = sample_group_celltype_df %>% left_join(
  abundance_info$abundance_data %>% ungroup()
  )

abundance_df$n[is.na(abundance_df$n)] = 0
abundance_df$keep[is.na(abundance_df$keep)] = FALSE
abundance_df_summarized = abundance_df %>% 
  mutate(keep = as.logical(keep)) %>% 
  group_by(group_id, celltype_id) %>% 
  summarise(samples_present = sum((keep)))

celltypes_absent_one_condition = abundance_df_summarized %>% 
  filter(samples_present == 0) %>% pull(celltype_id) %>% unique() 
# find truly condition-specific cell types by searching for cell types 
# truely absent in at least one condition

celltypes_present_one_condition = abundance_df_summarized %>% 
  filter(samples_present >= 2) %>% pull(celltype_id) %>% unique() 
# require presence in at least 2 samples of one group so 
# it is really present in at least one condition

condition_specific_celltypes = intersect(
  celltypes_absent_one_condition, 
  celltypes_present_one_condition)

total_nr_conditions = SummarizedExperiment::colData(sce)[,group_id] %>% 
  unique() %>% length() 

absent_celltypes = abundance_df_summarized %>% 
  filter(samples_present < 2) %>% 
  group_by(celltype_id) %>% 
  count() %>% 
  filter(n == total_nr_conditions) %>% 
  pull(celltype_id)
  
print(paste0("condition-specific celltypes: ", condition_specific_celltypes))
print(paste0("absent celltypes: ",absent_celltypes))

analyse_condition_specific_celltypes = TRUE
if(analyse_condition_specific_celltypes == TRUE){
  senders_oi = senders_oi %>% setdiff(absent_celltypes)
  receivers_oi = receivers_oi %>% setdiff(absent_celltypes)
} else {
  senders_oi = senders_oi %>% 
    setdiff(union(absent_celltypes, condition_specific_celltypes))
  receivers_oi = receivers_oi %>% 
    setdiff(union(absent_celltypes, condition_specific_celltypes))
}

sce = sce[, SummarizedExperiment::colData(sce)[,celltype_id] %in% 
            c(senders_oi, receivers_oi)
          ]

# Gene filtering: determine which genes are sufficiently expressed in each present cell type
min_sample_prop = 0.25 # genes should be expressed in at least 50% of the samples in the group
fraction_cutoff = 0.05 # genes should show non-zero expression values in at least 5% of cells in a sample

frq_list = get_frac_exprs(
  sce = sce, 
  sample_id = sample_id, celltype_id =  celltype_id, group_id = group_id, 
  min_cells = min_cells, batches = batches,
  fraction_cutoff = fraction_cutoff, min_sample_prop = min_sample_prop)

# Now only keep genes that are expressed by at least one cell type:
genes_oi = frq_list$expressed_df %>% 
  filter(expressed == TRUE) %>% pull(gene) %>% unique() 
sce = sce[genes_oi, ]


# Pseudobulk expression calculation: determine and normalize per-sample pseudobulk expression levels for each expressed gene in each present cell type
abundance_expression_info = process_abundance_expression_info(
  sce = sce, 
  sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, 
  min_cells = min_cells, 
  senders_oi = senders_oi, receivers_oi = receivers_oi, 
  lr_network = lr_network, 
  batches = batches, 
  frq_list = frq_list, 
  abundance_info = abundance_info)
# Normalized pseudobulk expression values per gene/celltype/sample
abundance_expression_info$celltype_info$pb_df %>% head()
# average of these sample-level expression values per condition/group
abundance_expression_info$celltype_info$pb_df_group %>% head()
# values for  ligand-receptor interactions
abundance_expression_info$sender_receiver_info$pb_df %>% head()
abundance_expression_info$sender_receiver_info$pb_df_group %>% head()

# Differential expression (DE) analysis: determine which genes are DE
# pseudobulk analysis by EdgeR multi-condition multi-sample DE analysis 
# also called 'differential state' analysis by the developers of Muscat
DE_info = get_DE_info(
  sce = sce, 
  sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, 
  batches = batches, covariates = covariates, 
  contrasts_oi = contrasts_oi, 
  min_cells = min_cells, 
  expressed_df = frq_list$expressed_df)

# DE results
DE_info$celltype_de$de_output_tidy %>% head()

# qc of p-value cut-off selection
# ditribution of p-values
DE_info$hist_pvals

empirical_pval = FALSE

if(empirical_pval == TRUE){
  DE_info_emp = get_empirical_pvals(DE_info$celltype_de$de_output_tidy)
  celltype_de = DE_info_emp$de_output_tidy_emp %>% select(-p_val, -p_adj) %>% 
    rename(p_val = p_emp, p_adj = p_adj_emp)
} else {
  celltype_de = DE_info$celltype_de$de_output_tidy
} 


# Combine DE information for ligand-senders and receptors-receivers
sender_receiver_de = combine_sender_receiver_de(
  sender_de = celltype_de,
  receiver_de = celltype_de,
  senders_oi = senders_oi,
  receivers_oi = receivers_oi,
  lr_network = lr_network
)

sender_receiver_de %>% head(20)

# Ligand activity prediction: use the DE analysis output to predict the activity 
# of ligands in receiver cell types and infer their potential target genes

hist(celltype_de$logFC)
hist(celltype_de$p_val)

logFC_threshold = 1      # set based on the histogram distribution
p_val_threshold = 0.01
p_val_adj = FALSE 

######### HERE IS THE ISSUE

geneset_assessment = contrast_tbl$contrast %>% 
  lapply(
    process_geneset_data, 
    celltype_de, logFC_threshold, p_val_adj, p_val_threshold
  ) %>% 
  bind_rows() 
geneset_assessment

top_n_target = 250
verbose = TRUE
cores_system = 1
n.cores = min(cores_system, celltype_de$cluster_id %>% unique() %>% length()) 

ligand_activities_targets_DEgenes = suppressMessages(suppressWarnings(
  get_ligand_activities_targets_DEgenes(
    receiver_de = celltype_de,
    receivers_oi = intersect(receivers_oi, celltype_de$cluster_id %>% unique()),
    ligand_target_matrix = ligand_target_matrix,
    logFC_threshold = logFC_threshold,
    p_val_threshold = p_val_threshold,
    p_val_adj = p_val_adj,
    top_n_target = top_n_target,
    verbose = verbose, 
    n.cores = n.cores
  )
))

# output
ligand_activities_targets_DEgenes$ligand_activities

# Prioritization: rank cell-cell communication patterns through multi-criteria prioritization
# we calculated expression, differential expression and NicheNet ligand activity. In the final step, we will now combine all calculated information to rank all sender-ligand---receiver-receptor pairs according to group/condition specificity. We will use the following criteria to prioritize ligand-receptor interactions (equal weight to all 4 points):

# 1. Upregulation of the ligand in a sender cell type and/or upregulation of the 
# receptor in a receiver cell type - in the condition of interest.
# 2. Cell-type specific expression of the ligand in the sender cell type and 
# receptor in the receiver cell type in the condition of interest (to mitigate 
# the influence of upregulated but still relatively weakly expressed ligands/receptors)
# 3. Sufficiently high expression levels of ligand and receptor in many samples of the same group
# 4. High NicheNet ligand activity, to further prioritize ligand-receptor pairs based 
# on their predicted effect of the ligand-receptor interaction on the gene expression in the receiver cell type.

ligand_activity_down = TRUE # if TRUE, than prioritize ligands that 
# lead potentially to both up- and downregulation of target genes
# if FALSE, only consider ligands that up-regulate target genes
sender_receiver_tbl = sender_receiver_de %>% distinct(sender, receiver)

metadata_combined = SummarizedExperiment::colData(sce) %>% tibble::as_tibble()

if(!is.na(batches)){
  grouping_tbl = metadata_combined[,c(sample_id, group_id, batches)] %>% 
    tibble::as_tibble() %>% distinct()
  colnames(grouping_tbl) = c("sample","group",batches)
} else {
  grouping_tbl = metadata_combined[,c(sample_id, group_id)] %>% 
    tibble::as_tibble() %>% distinct()
  colnames(grouping_tbl) = c("sample","group")
}

prioritization_tables = suppressMessages(generate_prioritization_tables(
    sender_receiver_info = abundance_expression_info$sender_receiver_info,
    sender_receiver_de = sender_receiver_de,
    ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
    contrast_tbl = contrast_tbl,
    sender_receiver_tbl = sender_receiver_tbl,
    grouping_tbl = grouping_tbl,
    scenario = "regular", # all prioritization criteria will be weighted equally
    fraction_cutoff = fraction_cutoff, 
    abundance_data_receiver = abundance_expression_info$abundance_data_receiver,
    abundance_data_sender = abundance_expression_info$abundance_data_sender,
    ligand_activity_down = ligand_activity_down
  ))

prioritization_tables$group_prioritization_tbl %>% head(100)

# (optional) In multi-sample datasets, we can look whether expression of L-R
# across all samples is correlated with the expression of their by NicheNet predicted target genes
lr_target_prior_cor = lr_target_prior_cor_inference(
  receivers_oi = prioritization_tables$group_prioritization_tbl$receiver %>% unique(), 
  abundance_expression_info = abundance_expression_info, 
  celltype_de = celltype_de, 
  grouping_tbl = grouping_tbl, 
  prioritization_tables = prioritization_tables, 
  ligand_target_matrix = ligand_target_matrix, 
  logFC_threshold = logFC_threshold, 
  p_val_threshold = p_val_threshold, 
  p_val_adj = p_val_adj
  )

# Save all the output of MultiNicheNet
path = paste0(params$out,"/Rds/")

multinichenet_output = list(
    celltype_info = abundance_expression_info$celltype_info,
    celltype_de = celltype_de,
    sender_receiver_info = abundance_expression_info$sender_receiver_info,
    sender_receiver_de =  sender_receiver_de,
    ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
    prioritization_tables = prioritization_tables,
    grouping_tbl = grouping_tbl,
    lr_target_prior_cor = lr_target_prior_cor
  ) 

multinichenet_output = make_lite_output(multinichenet_output)

save = TRUE
if(save == TRUE){
  saveRDS(multinichenet_output, paste0(path, "multiNicheNet_II-vs-III+IV.Rds"))
}
```

# ___Vizualization___

```{r}
# Visualization of differential cell-cell interactions
prioritized_tbl_oi_all = get_top_n_lr_pairs(
  multinichenet_output$prioritization_tables, 
  top_n = 50, 
  rank_per_group = FALSE
  )

prioritized_tbl_oi = 
  multinichenet_output$prioritization_tables$group_prioritization_tbl %>%
  filter(id %in% prioritized_tbl_oi_all$id) %>%
  distinct(id, sender, receiver, ligand, receptor, group) %>% 
  left_join(prioritized_tbl_oi_all)
prioritized_tbl_oi$prioritization_score[is.na(prioritized_tbl_oi$prioritization_score)] = 0

senders_receivers = union(prioritized_tbl_oi$sender %>% unique(), prioritized_tbl_oi$receiver %>% unique()) %>% sort()

colors_sender = RColorBrewer::brewer.pal(n = length(senders_receivers), name = 'Spectral') %>% magrittr::set_names(senders_receivers)
colors_receiver = RColorBrewer::brewer.pal(n = length(senders_receivers), name = 'Spectral') %>% magrittr::set_names(senders_receivers)

circos_list = make_circos_group_comparison(prioritized_tbl_oi, colors_sender, colors_receiver)


# R-L expression
# MYCNA patient group 
group_oi = "MYCNA" 

prioritized_tbl_oi_M_50 = prioritized_tbl_oi_all %>% 
  filter(group == group_oi)

plot_oi = make_sample_lr_prod_activity_plots_Omnipath(
  multinichenet_output$prioritization_tables, 
  prioritized_tbl_oi_M_50 %>% inner_join(lr_network_all)
  )

plot_oi

# non-MYCNA patient group 
group_oi = "non_MYCNA"

prioritized_tbl_oi_M_50 = prioritized_tbl_oi_all %>% 
  filter(group == group_oi)

plot_oi = make_sample_lr_prod_activity_plots_Omnipath(
  multinichenet_output$prioritization_tables, 
  prioritized_tbl_oi_M_50 %>% inner_join(lr_network_all)
  )

plot_oi

# Filtering of target genes based on LR-target expression correlation
lr_target_prior_cor_filtered = 
  multinichenet_output$prioritization_tables$group_prioritization_tbl$group %>% unique() %>% 
  lapply(function(group_oi){
    lr_target_prior_cor_filtered = multinichenet_output$lr_target_prior_cor %>%
      inner_join(
        multinichenet_output$ligand_activities_targets_DEgenes$ligand_activities %>%
          distinct(ligand, target, direction_regulation, contrast)
        ) %>% 
      inner_join(contrast_tbl) %>% filter(group == group_oi)
    
    lr_target_prior_cor_filtered_up = lr_target_prior_cor_filtered %>% 
      filter(direction_regulation == "up") %>% 
      filter( (rank_of_target < top_n_target) & (pearson > 0.5))
    
    lr_target_prior_cor_filtered_down = lr_target_prior_cor_filtered %>% 
      filter(direction_regulation == "down") %>% 
      filter( (rank_of_target < top_n_target) & (pearson < -0.5))
    lr_target_prior_cor_filtered = bind_rows(
      lr_target_prior_cor_filtered_up, 
      lr_target_prior_cor_filtered_down
      )
}) %>% bind_rows()

network = infer_intercellular_regulatory_network(lr_target_df, prioritized_tbl_oi_all)
network$links %>% head()

colors_sender["NB..8."] = "#e31a1c"
colors_sender["T..5."] = "#1f78b4"
colors_sender["T..6."] = "#1f78b4"
colors_sender["T..9."] = "#39BEB1"
colors_sender["M..1."] = "darkorange4"
colors_sender["M..2."] = "#ff7f00"
colors_sender["M..10."] = "#ff7f00"
colors_sender["M..15."] = "#ff7f00"
network_graph = visualize_network(network, colors_sender)
network_graph$plot

network$prioritized_lr_interactions
prioritized_tbl_oi_network = prioritized_tbl_oi_all %>% inner_join(
  network$prioritized_lr_interactions)
prioritized_tbl_oi_network

group_oi = "non_MYCNA"
prioritized_tbl_oi_M = prioritized_tbl_oi_network %>% filter(group == group_oi)

plot_oi = make_sample_lr_prod_activity_plots_Omnipath(
  multinichenet_output$prioritization_tables, 
  prioritized_tbl_oi_M %>% inner_join(lr_network_all)
  )
plot_oi

# Visualize sender-agnostic ligand activities for each receiver-group combination
group_oi = "non_MYCNA"
receiver_oi = "T..9."
prioritized_tbl_oi_M_10 = get_top_n_lr_pairs(
  multinichenet_output$prioritization_tables, 
  10, 
  groups_oi = group_oi, 
  receivers_oi = receiver_oi)

combined_plot = make_ligand_activity_target_plot(
  group_oi, 
  receiver_oi, 
  prioritized_tbl_oi_M_10,
  multinichenet_output$prioritization_tables, 
  multinichenet_output$ligand_activities_targets_DEgenes, contrast_tbl, 
  multinichenet_output$grouping_tbl, 
  multinichenet_output$celltype_info, 
  ligand_target_matrix, 
  plot_legend = FALSE)
combined_plot$combined_plot

# L-R pairs of interest violin plots
ligand_oi = "HMGB1"     
receptor_oi = "CXCR4"
group_oi = "IV"
sender_oi = "NB..8."
receiver_oi = "M..10."

ligand_oi = "TIMP1"     
receptor_oi = "CD36"
group_oi = "IV"
sender_oi = "M..10."
receiver_oi = "NB..8."

p_violin = make_ligand_receptor_violin_plot(
  sce = sce, 
  ligand_oi = ligand_oi,
  receptor_oi = receptor_oi, 
  group_oi = group_oi, 
  group_id = group_id, 
  sender_oi = sender_oi, 
  receiver_oi = receiver_oi, 
  sample_id = sample_id, 
  celltype_id = celltype_id)
p_violin

# Visualize top DE genes for a cell type of interest
group_oi = "IV"
receiver_oi = "T..9."
DE_genes = multinichenet_output$ligand_activities_targets_DEgenes$de_genes_df %>% 
  inner_join(contrast_tbl) %>% 
  filter(group == group_oi) %>% 
  arrange(p_val) %>% 
  filter(
    receiver == receiver_oi & 
      logFC > 2 & 
      p_val <= 0.05 &
      contrast == contrast_tbl %>% filter(group == group_oi) %>% pull(contrast)) %>% 
  pull(gene) %>% unique()

p_target = make_DEgene_dotplot_pseudobulk(
  genes_oi = DE_genes, 
  celltype_info = multinichenet_output$celltype_info, 
  prioritization_tables = multinichenet_output$prioritization_tables, 
  celltype_oi = receiver_oi, 
  multinichenet_output$grouping_tbl)
p_target$pseudobulk_plot + ggtitle("DE genes (pseudobulk expression)")
p_target$singlecell_plot + ggtitle("DE genes (single-cell expression)")

# the same but only for Ligands 
DE_genes = multinichenet_output$ligand_activities_targets_DEgenes$de_genes_df %>% 
  inner_join(contrast_tbl) %>% 
  filter(group == group_oi) %>% 
  arrange(p_val) %>% 
  filter(
    receiver == receiver_oi & 
      logFC > 1 & 
      p_val <= 0.05 &
      contrast == contrast_tbl %>% filter(group == group_oi) %>% pull(contrast)) %>% 
  pull(gene) %>% unique()
DE_genes = DE_genes %>% intersect(lr_network$ligand)
p_target = make_DEgene_dotplot_pseudobulk(
  genes_oi = DE_genes, 
  celltype_info = multinichenet_output$celltype_info, 
  prioritization_tables = multinichenet_output$prioritization_tables, 
  celltype_oi = receiver_oi, 
  multinichenet_output$grouping_tbl)
p_target$pseudobulk_plot + ggtitle("DE ligands (pseudobulk expression)")
p_target$singlecell_plot + ggtitle("DE ligands (single-cell expression)")

# the same but for Receptors
DE_genes = multinichenet_output$ligand_activities_targets_DEgenes$de_genes_df %>% 
  inner_join(contrast_tbl) %>% 
  filter(group == group_oi) %>% 
  arrange(p_val) %>% 
  filter(
    receiver == receiver_oi & 
      logFC > 1 & 
      p_val <= 0.05 &
      contrast == contrast_tbl %>% filter(group == group_oi) %>% pull(contrast)) %>% 
  pull(gene) %>% unique()
DE_genes = DE_genes %>% intersect(lr_network$receptor)
p_target = make_DEgene_dotplot_pseudobulk(
  genes_oi = DE_genes, 
  celltype_info = multinichenet_output$celltype_info, 
  prioritization_tables = multinichenet_output$prioritization_tables, 
  celltype_oi = receiver_oi, 
  multinichenet_output$grouping_tbl)
p_target$pseudobulk_plot + ggtitle("DE receptors (pseudobulk expression)")
p_target$singlecell_plot + ggtitle("DE ligands (single-cell expression)")
```

## ___NicheNetR analysis___

```{r}
library(nichenetr)

Idents(rna) <- rna$original_celltype

organism <- "human"

if(organism == "human"){
  lr_network <- readRDS(url("https://zenodo.org/record/7074291/files/lr_network_human_21122021.rds"))
  ligand_target_matrix <- readRDS(url("https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final.rds"))
  weighted_networks <- readRDS(url("https://zenodo.org/record/7074291/files/weighted_networks_nsga2r_final.rds"))
} else if(organism == "mouse"){
  lr_network <- readRDS(url("https://zenodo.org/record/7074291/files/lr_network_mouse_21122021.rds"))
  ligand_target_matrix <- readRDS(url("https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final_mouse.rds"))
  weighted_networks <- readRDS(url("https://zenodo.org/record/7074291/files/weighted_networks_nsga2r_final_mouse.rds"))
}


# 1. Define a set of potential ligands for both the sender-agnostic and sender-focused approach
lr_network <- lr_network %>% distinct(from, to)
expressed_genes_receiver <- get_expressed_genes(c("T (5)","T (6)","T (9)",
                                                  "M (1)","M (2)","M (10)",
                                                  "NB (8)"), rna, pct = 0.05) 
# Min. 5% of the cells should express the L/R

all_receptors <- unique(lr_network$to)  
expressed_receptors <- intersect(all_receptors, expressed_genes_receiver)

potential_ligands <- lr_network %>% filter(to %in% expressed_receptors) %>% pull(from) %>% unique()

sender_celltypes <- clusters_of_interest

# Use lapply to get the expressed genes of every sender cell type separately here
list_expressed_genes_sender <- sender_celltypes %>% unique() %>% lapply(get_expressed_genes, rna, 0.05)
expressed_genes_sender <- list_expressed_genes_sender %>% unlist() %>% unique()

potential_ligands_focused <- intersect(potential_ligands, expressed_genes_sender) 

# Sanity check
length(expressed_genes_sender)
length(potential_ligands)
length(potential_ligands_focused)

# 2. Define the gene set of interest
condition_oi <-  "IV"
condition_reference <- "I"

rna_receiver <- subset(rna, idents = receiver)

DE_table_receiver <-  FindMarkers(object = rna_receiver,
                                  ident.1 = condition_oi, 
                                  ident.2 = condition_reference,
                                  group.by = "group",
                                  min.pct = 0.05) %>% rownames_to_column("gene")

geneset_oi <- DE_table_receiver %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC) >= 0.25) %>% pull(gene)
geneset_oi <- geneset_oi %>% .[. %in% rownames(ligand_target_matrix)]

# 3. Define the background genes
background_expressed_genes <- expressed_genes_receiver %>% .[. %in% rownames(ligand_target_matrix)]

length(background_expressed_genes)
length(geneset_oi)

# 4. Perform NicheNet ligand activity analysis
ligand_activities <- predict_ligand_activities(geneset = geneset_oi,
                                               background_expressed_genes = background_expressed_genes,
                                               ligand_target_matrix = ligand_target_matrix,
                                               potential_ligands = potential_ligands)

ligand_activities <- ligand_activities %>% arrange(-aupr_corrected) %>% mutate(rank = rank(desc(aupr_corrected)))
ligand_activities

p_hist_lig_activity <- ggplot(ligand_activities, aes(x=aupr_corrected)) + 
  geom_histogram(color="black", fill="darkorange")  + 
  geom_vline(aes(xintercept=min(ligand_activities %>% top_n(30, aupr_corrected) %>% pull(aupr_corrected))),
             color="red", linetype="dashed", size=1) + 
  labs(x="ligand activity (PCC)", y = "# ligands") +
  theme_classic()

p_hist_lig_activity

best_upstream_ligands <- ligand_activities %>% top_n(30, aupr_corrected) %>% arrange(-aupr_corrected) %>% pull(test_ligand)

vis_ligand_aupr <- ligand_activities %>% filter(test_ligand %in% best_upstream_ligands) %>%
  column_to_rownames("test_ligand") %>% select(aupr_corrected) %>% arrange(aupr_corrected) %>% as.matrix(ncol = 1)

(make_heatmap_ggplot(vis_ligand_aupr,
                     "Prioritized ligands", "Ligand activity", 
                     legend_title = "AUPR", color = "darkorange") + 
    theme(axis.text.x.top = element_blank()))  

# 5. Infer target genes and receptors of top-ranked ligands
active_ligand_target_links_df <- best_upstream_ligands %>%
  lapply(get_weighted_ligand_target_links,
         geneset = geneset_oi,
         ligand_target_matrix = ligand_target_matrix,
         n = 100) %>%
  bind_rows() %>% drop_na()

nrow(active_ligand_target_links_df)
head(active_ligand_target_links_df)

active_ligand_target_links <- prepare_ligand_target_visualization(
  ligand_target_df = active_ligand_target_links_df,
  ligand_target_matrix = ligand_target_matrix,
  cutoff = 0.33) 

nrow(active_ligand_target_links)
head(active_ligand_target_links)

order_ligands <- intersect(best_upstream_ligands, colnames(active_ligand_target_links)) %>% rev()
order_targets <- active_ligand_target_links_df$target %>% unique() %>% intersect(rownames(active_ligand_target_links))

vis_ligand_target <- t(active_ligand_target_links[order_targets,order_ligands])

make_heatmap_ggplot(vis_ligand_target, "Prioritized ligands", "Predicted target genes",
                    color = "purple", legend_title = "Regulatory potential") +
  scale_fill_gradient2(low = "whitesmoke",  high = "purple")

 
ligand_receptor_links_df <- get_weighted_ligand_receptor_links(
  best_upstream_ligands, expressed_receptors,
  lr_network, weighted_networks$lr_sig) 

vis_ligand_receptor_network <- prepare_ligand_receptor_visualization(
  ligand_receptor_links_df,
  best_upstream_ligands,
  order_hclust = "both") 

(make_heatmap_ggplot(t(vis_ligand_receptor_network), 
                     y_name = "Ligands", x_name = "Receptors",  
                     color = "mediumvioletred", legend_title = "Prior interaction potential"))

# 6. Sender-focused approach
ligand_activities_all <- ligand_activities 
best_upstream_ligands_all <- best_upstream_ligands

ligand_activities <- ligand_activities %>% filter(test_ligand %in% potential_ligands_focused)
best_upstream_ligands <- ligand_activities %>% top_n(30, aupr_corrected) %>% arrange(-aupr_corrected) %>%
  pull(test_ligand) %>% unique()

ligand_aupr_matrix <- ligand_activities %>% filter(test_ligand %in% best_upstream_ligands) %>%
  column_to_rownames("test_ligand") %>% select(aupr_corrected) %>% arrange(aupr_corrected)
vis_ligand_aupr <- as.matrix(ligand_aupr_matrix, ncol = 1) 

p_ligand_aupr <- make_heatmap_ggplot(vis_ligand_aupr,
                     "Prioritized ligands", "Ligand activity", 
                     legend_title = "AUPR", color = "darkorange") + 
    theme(axis.text.x.top = element_blank())

p_ligand_aupr

# Target gene plot
active_ligand_target_links_df <- best_upstream_ligands %>%
  lapply(get_weighted_ligand_target_links,
         geneset = geneset_oi,
         ligand_target_matrix = ligand_target_matrix,
         n = 100) %>%
  bind_rows() %>% drop_na()

active_ligand_target_links <- prepare_ligand_target_visualization(
  ligand_target_df = active_ligand_target_links_df,
  ligand_target_matrix = ligand_target_matrix,
  cutoff = 0.33) 

order_ligands <- intersect(best_upstream_ligands, colnames(active_ligand_target_links)) %>% rev()
order_targets <- active_ligand_target_links_df$target %>% unique() %>% intersect(rownames(active_ligand_target_links))

vis_ligand_target <- t(active_ligand_target_links[order_targets,order_ligands])

p_ligand_target <- make_heatmap_ggplot(vis_ligand_target, "Prioritized ligands", "Predicted target genes",
                    color = "purple", legend_title = "Regulatory potential") +
  scale_fill_gradient2(low = "whitesmoke",  high = "purple")

p_ligand_target

# Receptor plot
ligand_receptor_links_df <- get_weighted_ligand_receptor_links(
  best_upstream_ligands, expressed_receptors,
  lr_network, weighted_networks$lr_sig) 

vis_ligand_receptor_network <- prepare_ligand_receptor_visualization(
  ligand_receptor_links_df,
  best_upstream_ligands,
  order_hclust = "both") 

p_ligand_receptor <- make_heatmap_ggplot(t(vis_ligand_receptor_network), 
                     y_name = "Ligands", x_name = "Receptors",  
                     color = "mediumvioletred", legend_title = "Prior interaction potential")

p_ligand_receptor

best_upstream_ligands_all %in% rownames(rna) %>% table()

# Dotplot of sender-focused approach
p_dotplot <- DotPlot(subset(rna, celltype %in% sender_celltypes),
        features = rev(best_upstream_ligands), cols = "RdYlBu") + 
  coord_flip() +
  scale_y_discrete(position = "right")

p_dotplot


celltype_order <- levels(Idents(rna)) 

# Use this if cell type labels are the identities of your Seurat object
# if not: indicate the celltype_col properly
DE_table_top_ligands <- lapply(
  celltype_order[celltype_order %in% sender_celltypes],
  get_lfc_celltype, 
  seurat_obj = rna,
  condition_colname = "group",
  condition_oi = condition_oi,
  condition_reference = condition_reference,
  celltype_col = "original_celltype",
  min.pct = 0, logfc.threshold = 0,
  features = best_upstream_ligands 
) 

DE_table_top_ligands <- DE_table_top_ligands %>%  reduce(., full_join) %>% 
  column_to_rownames("gene") 

vis_ligand_lfc <- as.matrix(DE_table_top_ligands[rev(best_upstream_ligands), ]) 

p_lfc <- make_threecolor_heatmap_ggplot(vis_ligand_lfc,
                                "Prioritized ligands", "LFC in Sender",
                                low_color = "midnightblue", mid_color = "white",
                                mid = median(vis_ligand_lfc), high_color = "red",
                                legend_title = "LFC")

p_lfc

(make_line_plot(ligand_activities = ligand_activities_all,
                potential_ligands = potential_ligands_focused) +
   theme(plot.title = element_text(size=11, hjust=0.1, margin=margin(0, 0, -5, 0))))

# 7. Summary visualizations of the NicheNet analysis
figures_without_legend <- cowplot::plot_grid(
  p_ligand_aupr + theme(legend.position = "none"),
  p_dotplot + theme(legend.position = "none",
                    axis.ticks = element_blank(),
                    axis.title.y = element_blank(),
                    axis.title.x = element_text(size = 12),
                    axis.text.y = element_text(size = 9),
                    axis.text.x = element_text(size = 9,  angle = 90, hjust = 0)) +
    ylab("Expression in Sender"),
  p_lfc + theme(legend.position = "none",
                axis.title.y = element_blank()),
  p_ligand_target + theme(legend.position = "none",
                          axis.title.y = element_blank()),
  align = "hv",
  nrow = 1,
  rel_widths = c(ncol(vis_ligand_aupr)+6, ncol(vis_ligand_lfc)+7, ncol(vis_ligand_lfc)+8, ncol(vis_ligand_target)))

legends <- cowplot::plot_grid(
    ggpubr::as_ggplot(ggpubr::get_legend(p_ligand_aupr)),
    ggpubr::as_ggplot(ggpubr::get_legend(p_dotplot)),
    ggpubr::as_ggplot(ggpubr::get_legend(p_lfc)),
    ggpubr::as_ggplot(ggpubr::get_legend(p_ligand_target)),
    nrow = 1,
    align = "h", rel_widths = c(1.5, 1, 1, 1))

combined_plot <-  cowplot::plot_grid(figures_without_legend, legends, rel_heights = c(10,5), nrow = 2, align = "hv")
combined_plot

# save analysis
#saveRDS()
```



# ___CCC analysis with CellChat___

To infer the cell state-specific communications, CellChat v2 identifies 
over-expressed ligands or receptors in one cell group and then identifies 
over-expressed ligand-receptor interactions if either ligand or receptor are 
over-expressed.

```{r ccc function - basic}
ccc.analysis <- function(seurat) {
  print(seurat)
  Idents(seurat) <- seurat@meta.data$original_celltype
  # extract read count matrix
  mat <- GetAssayData(seurat, assay = "RNA", slot = "data")
  # create cell chat object
  cellchat <- createCellChat(
    mat, meta = seurat@meta.data,
    group.by = "original_celltype",
)
  # define which database to use
  cellchat@DB <- CellChatDB.human
  # only keep genes in CellChatDB
  cellchat <- subsetData(cellchat)
  # find over expressed ligands/receptors
  cellchat <- identifyOverExpressedGenes(cellchat)
  # find over expressed interactions
  cellchat <- identifyOverExpressedInteractions(cellchat)
  # calculate communication probability between cell groups
  cellchat <- computeCommunProb(cellchat, seed.use = 28)
  # filter communications occurring with less than 100 cells in a cell group
  cellchat <- filterCommunication(cellchat,min.cells = 100)
  # calculate communication probability on the signaling pathway level
  cellchat <- computeCommunProbPathway(cellchat)
  # calculate aggregated communication network
  cellchat <- aggregateNet(cellchat)
  # determine network centrality pathways
  cellchat <- netAnalysis_computeCentrality(cellchat)
  # save analysis results
  df_net_all <-
  cellchat %>% 
  subsetCommunication() %>% 
  as_tibble() %>% 
  group_by(interaction_name_2) %>% 
  mutate(prob.norm = prob / max(prob)) %>% # Normalize the probabilities 0-1
  ungroup() %>% 
  mutate(
    source = factor(source, clusters_of_interest),
    target = factor(target, clusters_of_interest),
    )
  df_net_all
  # print results
  print(df_net_all)
  # save results in Rds object
  #cellchat %>% 
  #saveRDS(paste0(params$out,"Rds/fetahu2023.cellchat",seurat,".Rds"))
  #df_net_all %>% 
  #saveRDS(paste0(params$out,"Rds/fetahu2023.signaling",seurat,".Rds"))
  }
```

```{r ccc function - advanced}
ccc.analysis.comprehensive <- function(seurat) {
  print(seurat)
  Idents(seurat) <- seurat@meta.data$original_celltype
  # extract read count matrix
  mat <- GetAssayData(seurat, assay = "RNA", slot = "data")
  # create cell chat object
  cellchat <- createCellChat(mat, 
                             meta = seurat@meta.data,
                             group.by = "original_celltype",
                             )
  # Prepare DB
  cellchat@DB <- CellChatDB.human
  # subset the expression data of signaling genes for saving computation cost
  cellchat <- subsetData(cellchat) # This step is necessary even if using the whole database (it removes genes which are not expressed in the data)
  cellchat <- identifyOverExpressedGenes(cellchat)
  cellchat <- identifyOverExpressedInteractions(cellchat)
  cellchat <- projectData(cellchat, PPI.human)
  # Compute the communication probability and infer cellular communication network
  # project gene expression data onto PPI (Use `raw.use = FALSE` in the function 
  # computeCommunProb() in order to use the projected data)
  cellchat <- computeCommunProb(cellchat, raw.use = FALSE, population.size = TRUE)
  # population.size = TRUE <- cell numbers per cell type/cluster 
  # used for the probability calculation
  # only consider R-L pairs which are expressed by minumum 50 cells
  cellchat <- filterCommunication(cellchat, min.cells = 50)
  df.net <- subsetCommunication(cellchat)
  df.net.pathways <- subsetCommunication(cellchat, slot.name = "netP")
  # slot.name = "netP" for inferred communications at the level of signaling pathways
  print(df.net.pathways)
  # Infer the cell-cell communication at a signaling pathway level
  cellchat <- computeCommunProbPathway(cellchat)
  # Calculate the aggregated cell-cell communication network
  cellchat <- aggregateNet(cellchat)
  groupSize <- as.numeric(table(cellchat@idents))
  netVisual_circle(cellchat@net$weight, vertex.weight = groupSize, 
                   weight.scale = T, label.edge= F, 
                   title.name = "CC interaction strength")
  # Bubble plot: all the significant interactions (Ligand-Receptor pairs) from 
  # one cell groups (defined by 'sources.use') to other cell groups (defined by 'targets.use')
  netVisual_bubble(cellchat, sources.use = "NB (8)",  
                   remove.isolate = FALSE)
  netVisual_chord_gene(cellchat, sources.use = "NB (8)", 
                       slot.name = "netP", 
                       legend.pos.x = 10)
  # Compute the network centrality scores
  cellchat <- netAnalysis_computeCentrality(cellchat, slot.name = "netP") 
  # the slot 'netP' means the inferred intercellular communication network of signaling pathways
  # Visualize the computed centrality scores using heatmap, allowing ready identification of major signaling roles of cell groups
  #netAnalysis_signalingRole_network(cellchat, signaling = pathway, 
  #                                  width = 8, height = 2.5, font.size = 12)
  # Visualize dominant senders (sources) and receivers (targets) in a 2D space
  gg1 <- netAnalysis_signalingRole_scatter(cellchat)
  # Signaling role analysis on the cell-cell communication networks of interest
  #gg2 <- netAnalysis_signalingRole_scatter(cellchat, signaling = pathway)
  # Signaling role analysis on the cell-cell communication network from user's input
  gg1 
  #gg2
  # Signaling role analysis on the aggregated cell-cell communication network from all signaling pathways
  ht1 <- netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing")
  ht2 <- netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming")
  ht1 + ht2
  # run selectK to infer the number of patterns.
  # selectK(cellchat, pattern = "outgoing") # define the number of patterns/cut-off
  nPatterns = 7 # based on the output of the previous command
  cellchat <- identifyCommunicationPatterns(cellchat, 
                                            pattern = "outgoing", 
                                            k = nPatterns)
  # river plot
  netAnalysis_river(cellchat, pattern = "outgoing")
  # dot plot
  netAnalysis_dot(cellchat, pattern = "outgoing")
  # the same for incoming communication patterns
  #selectK(cellchat, pattern = "incoming") # define the number of patterns/cut-off
  nPatterns = 7
  cellchat <- identifyCommunicationPatterns(cellchat, 
                                            pattern = "incoming", 
                                            k = nPatterns)
  # river plot
  netAnalysis_river(cellchat, pattern = "incoming")
  # dot plot
  netAnalysis_dot(cellchat, pattern = "incoming")
  #saveRDS(cellchat, file = paste0(params$out,"/Rds/CCC_analysis_Fetahu2023.Rds"))
  results_network <- subsetCommunication(cellchat, slot.name = "net")
  results_pathways <- subsetCommunication(cellchat, slot.name = "netP")
  
  df_net_all <-
  cellchat %>% 
  subsetCommunication() %>% 
  as_tibble() %>% 
  group_by(interaction_name_2) %>% 
  mutate(prob.norm = prob / max(prob)) %>% # Normalize the probabilities 0-1
  ungroup() %>% 
  mutate(
    source = factor(source, clusters_of_interest),
    target = factor(target, clusters_of_interest),
    )
  
  print(df_net_all)
}
```

```{r Run CCC analysis, eval=FALSE, include=FALSE}
sample.list <- list(MYCNA, nonMYCNA)
setNames(sample.list, c("MYCNA", "nonMYCNA"))

CCC_analysis <- lapply(sample.list, ccc.analysis)
```

```{r}
sample.list <- list(MYCNA, nonMYCNA)
setNames(sample.list, c("MYCNA", "nonMYCNA"))

CCC_analysis_full <- lapply(sample.list, ccc.analysis.comprehensive)
```

```{r}
CCC_analysis_full[[1]]  #MYCNA
write.csv(CCC_analysis_full[[1]], file = paste0(params$out,"/tables/CellChat_MYCNA_CCC_advanced.csv"),
          quote = FALSE,sep = "\t",row.names = FALSE)
CCC_analysis_full[[2]]  #non-MYCNA
write.csv(CCC_analysis_full[[1]], file = paste0(params$out,"/tables/CellChat_nonMYCNA_CCC_advanced.csv"),
          quote = FALSE,sep = "\t",row.names = FALSE)

```


```{r}
CCC_analysis[[1]]
write.csv(CCC_analysis[[1]], file = paste0(params$out,"/tables/CellChat_MYCNA_CCC_basic.csv"),
          quote = FALSE,sep = "\t",row.names = FALSE)
CCC_analysis[[2]]
write.csv(CCC_analysis[[2]], file = paste0(params$out,"/tables/CellChat_nonMYCNA_CCC_basic.csv"),
          quote = FALSE,sep = "\t",row.names = FALSE)
#CCC_analysis[[3]]
#write.csv(CCC_analysis[[1]], file = paste0(params$out,"/tables/CellChat_controls_CCC_basic.csv"),
          quote = FALSE,sep = "\t",row.names = FALSE)
```


```{r}
# set a cutoff
hist(CCC_analysis_full[[1]]$prob.norm)
hist(CCC_analysis_full[[2]]$prob.norm)

hist(CCC_analysis[[1]]$prob.norm)
hist(CCC_analysis[[2]]$prob.norm)
```


-------------------------------------------------------------------------------



```{r}
sessionInfo()
```
