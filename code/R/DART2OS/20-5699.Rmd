---
title: "Read in steinbock data"
output: html_document
date: '2022-08-12'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Read in the data {#read-data}

This section describes how to read in single-cell data and images into `R`
**after** image processing and segmentation (see Section \@ref(processing)).

We use the [imcRtools](https://github.com/BodenmillerGroup/imcRtools) package to
read in single-cell data extracted using the `steinbock` framework or the IMC
Segmentation Pipeline. Both image processing approaches also generate
multi-channel images and segmentation masks that can be read into `R` using the
[cytomapper](https://github.com/BodenmillerGroup/cytomapper) package.

```{r, message=FALSE}
library(imcRtools)
#testing
library(cytomapper)
library(BiocParallel)
```

## Read in single-cell information

For single-cell data analysis in `R` the
[SingleCellExperiment](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html)
[@Amezquita2019] data container is commonly used within the Bioconductor
framework. It allows standardized access to (i) expression data, (ii) cellular
metadata (e.g. cell type), (iii) feature metadata (e.g. marker name) and (iv)
experiment-wide metadata. For an in-depth introduction to the `SingleCellExperiment`
container, please refer to the [SingleCellExperiment class](https://bioconductor.org/books/3.14/OSCA.intro/the-singlecellexperiment-class.html).

The [SpatialExperiment](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html)
class [@Righelli2021] is an extension of the `SingleCellExperiment` class. It
was developed to store spatial data in addition to single-cell data and an
extended introduction is accessible
[here](https://bioconductor.org/packages/release/bioc/vignettes/SpatialExperiment/inst/doc/SpatialExperiment.html).

To read in single-cell data generated by the `steinbock` framework or the IMC
Segmentation Pipeline, the `imcRtools` package provides the `read_steinbock` and
`read_cpout` function, respectively. By default, the data is read into a
`SpatialExperiment` object; however, data can be read in as a
`SingleCellExperiment` object by setting `return_as = "sce"`. All functions
presented in this book are applicable to both data containers.

### steinbock generated data

The [steinbock](https://github.com/BodenmillerGroup/steinbock) framework was
used to process and segment IMC raw data available.

The `read_steinbock` function provided by `imcRtools` can now be used to read in
`steinbock` generated data. For more information, please refer to
`?read_steinbock`.

```{r read-steinbock}
path <- "/mnt/Multimodal_Imaging_Daria/DART2OS/20-5699_corrected"

spe <- read_steinbock(path=path, image_file=NULL, panel_file = file.path(path, 'NB_Panel.csv')) 

#Rename third IF channel (CD45 for PT, CD56 for BM)
rownames(spe)[44] <- "IF3_CD45/56_mean"
rownames(spe)[88] <- "IF3_CD45/56_mean-80"

#Transform counts
assay(spe, "exprs") <- asinh(counts(spe)/1)

spe
```
## Single-cell processing {#cell-processing}

After reading in the single-cell data, few further processing steps need to be
taken.

**Add additional metadata**

We can set the `colnames` of the object to generate unique identifiers per cell:

```{r set-colnames}
colnames(spe) <- paste0(spe$sample_id, "_", spe$ObjectNumber)
```

It is also often the case that sample-specific metadata are available externally.
For the current data, we need to link metadata from an external excel file.
More information on how to extract matching patterns from a string can be found [here](https://stringr.tidyverse.org/reference/str_extract.html).

```{r add-indication}
library(stringr)

spe$sample <- gsub(spe$sample_id, pattern="([UM]).*", replacement="\\1")
spe$fm_id <- str_match(spe$sample, "_.*_(.*)_")[,2]  
spe$tissue <- str_match(spe$sample, "^.*_.*_(.*)")[,2] 
spe$tissue[spe$tissue=="TU"] = "PT"
spe$ROI <- str_match(spe$sample_id, "^.*_.*_.*_.*_(.*)")[,2]
spe$year <- gsub(spe$sample_id, pattern="^.*_.*_(.*)-.*", replacement="\\1")

```

**Check for technical confounders (batch effects)**

```{r plot by sample}

selected_samples <- unique(spe$sample)
marker <- 'IF3_CD45/56_mean-80'

library(dittoSeq)

dittoRidgePlot(spe[,spe$sample%in%selected_samples], var = marker, group.by = "sample", assay = "counts") +
    ggtitle(paste(marker,  "- per sample"))
```

```{r plot by staining date, fig.height=10}

#marker <- 'CD45_Eu153_mean'
marker <- 'GD2_Gd155_mean'
tissue <- unique(spe$tissue)
#tissue <- "PT"
dittoRidgePlot(spe[,spe$tissue%in%tissue], var = marker, group.by = "tissue", assay = "exprs") +
    ggtitle(paste(marker,  "- per tissue"))

```
##Generate matrix 

```{r generate-dataframes, message=FALSE, fig.height=7}
library(bruceR)
library(SpatialExperiment)

intensity_mat <- assay(spe, "counts")
colnames(intensity_mat) <- colnames(spe)
intensity_mat <- intensity_mat[!grepl("mean-80", rownames(intensity_mat)),]

intensity_mat_hq <- intensity_mat[!grepl("Xe|Ba136|CXCR2|CD20|CD11c|CD24|SOX10|CHGA|GATA3|IDO|ELAVL4|DAPI|IF2_GD2|IF3_CD45/56|DNA1|H4K12Ac|H3K9Ac", rownames(intensity_mat)),]
intensity_mat_lq <- intensity_mat[grepl("Xe|Ba136|CXCR2|CD20|CD11c|CD24|SOX10|CHGA|GATA3|IDO|ELAVL4|DAPI|IF2_GD2|IF3_CD45/56|DNA1|H4K12Ac|H3K9Ac", rownames(intensity_mat)),]

#Make sure to exclude cells that are zero for all markers as PG won't work otherwise 
non_zeros <- as.logical(colSums(intensity_mat_hq)!=0)

intensity_mat_hq_wo_zeros <- intensity_mat_hq[,non_zeros]
intensity_mat_lq_wo_zeros <- intensity_mat_lq[,non_zeros]

#Apply changes to SPE object
spe <- spe[,non_zeros]
rowData(spe)$use_channel <- !grepl("mean-80|Xe|Ba136|CXCR2|CD20|CD11c|CD24|SOX10|CHGA|GATA3|IDO|ELAVL4|DAPI|IF2_GD2|IF3_CD45/56|DNA1|H4K12Ac|H3K9Ac", rownames(spe))

tissue <- spe$tissue
cell_id <- colnames(spe)
```

##Single-cell heatmap

In a next step, we will plot a single-cell heatmap using complex heatmap. 

```{r single-cell-heatmap, message=FALSE, fig.height=10}
library(ComplexHeatmap)
library(viridis)
library(circlize)
library(RColorBrewer)
library(paletteer)

mat <- intensity_mat_hq

set.seed(221228)

qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector_74 = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
col_vector_433 = colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]

col_sample = setNames(sample(col_vector_433, length(unique(spe$sample))), unique(spe$sample))

rand_cells <- sample(seq_len(ncol(mat)), 2000)

Heatmap(mat[,rand_cells], 
        column_title = "Single-cell heatmap",
        show_column_dend = F,
        show_column_names=F,
        col=viridis(100)
        )
```
##Clustering

```{r phenograph-clustering}
library(Rphenoannoy)

set.seed(221228)

Rphenograph_out <- Rphenoannoy(t(mat), k = 30)

clusters <- factor(membership(Rphenograph_out[[2]]))

spe$pg_clusters <- clusters
```

##Single-cell heatmap after clustering
Next we will look at the single cell heatmap ordered by the identified phenograph clusters for 2000 randomly selected cells. 

```{r single-cell-heatmap-clusters, message=FALSE, fig.width=9, fig.height=9}
library(ComplexHeatmap)
library(viridis)
library(circlize)
library(RColorBrewer)
library(paletteer)


set.seed(20230521)

col_vector_433 = colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
col_clusters = setNames(sample(col_vector_433, length(unique(spe$pg_clusters))), unique(spe$pg_clusters))

rand_cells <- sample(seq_len(ncol(mat)), 2000)

column_ha = HeatmapAnnotation(cluster = clusters[rand_cells],
                              col=list(cluster=col_clusters), 
                              show_legend=T)


Heatmap(mat[,rand_cells], 
        column_title = "Single-cell heatmap with phenograph clusters (1-px mean)",
        top_annotation = column_ha, 
        cluster_columns=F,
        column_order= order(clusters[rand_cells], decreasing=F),
        show_column_dend = T,
        show_column_names=F,
        col=viridis(100)
        )
```

##Bubble plot

```{r dot-plot-complex-heatmap, message=FALSE, fig.height=7}
library(tidyr)
library(tidyHeatmap)
library(bruceR)

col_vector_433 = colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
col_clusters = setNames(sample(col_vector_433, length(unique(spe$pg_clusters))), unique(spe$pg_clusters))

#Mean expression per cluster
exp_mat_ <- aggregate(t(mat), list(spe$pg_clusters), mean)
exp_mat <- exp_mat_[,2:ncol(exp_mat_)]
exp_mat <- apply(exp_mat, 2, RESCALE, to=0:1)
rownames(exp_mat) <- exp_mat_[,"Group.1"]
exp_mat <- t(exp_mat)
head(exp_mat)

#Percentage of cells per cluster expressing a marker (>0)
tmp <- mat
tmp[tmp > unname(quantile(exp_mat[exp_mat>0], c(0.2)))] <- 1
tmp[tmp <= unname(quantile(exp_mat[exp_mat>0], c(0.2)))] <- 0
tmp <- aggregate(t(tmp), list(spe$pg_clusters), sum)
tmp2 <- tmp[,2:ncol(tmp)]
rownames(tmp2) <- tmp[,"Group.1"]
percent_mat <- tmp2 / unname(table(droplevels(spe$pg_clusters)))
percent_mat <- t(percent_mat)
percent_mat[percent_mat < 0.1] <- 0.1 #setting min values higher to make points in heatmap visible
head(percent_mat)

column_ha = HeatmapAnnotation(ncellsl=anno_barplot(as.data.frame(table(spe$pg_clusters))[,"Freq"], add_numbers=T, height = unit(2.2, "cm")),
                              col=list(pg_clusters=metadata(spe)$color_vectors$col_clusters), 
                              show_legend=T)

#Function to set dot size based on percentage expressed
cell_fun = function(j, i, x, y, w, h, fill){
          grid.rect(x = x, y = y, width = w, height = h, 
                    gp = gpar(col = NA, fill = NA))
          grid.circle(x=x,y=y,r= percent_mat[i, j]/2 * min(unit.c(w, h)),
                      gp = gpar(fill = col_fun(exp_mat[i, j]), col = NA))}

#Function to set dot color based on mean expression
col_fun = circlize::colorRamp2(c(min(exp_mat),(max(exp_mat)-min(exp_mat))/2, max(exp_mat)), viridis(100)[c(1,50,100)])

#Function to set legend size according to percentage expressed
layer_fun = function(j, i, x, y, w, h, fill){
          grid.rect(x = x, y = y, width = w, height = h, 
                    gp = gpar(col = NA, fill = NA))
          grid.circle(x=x,y=y,r= pindex(percent_mat, i, j)/1 * unit(1.5, "mm"),
                      gp = gpar(fill = col_fun(pindex(exp_mat, i, j)), col = NA))}

#Generate legend for percentage expressed
lgd_list = list(
    Legend( labels = c(0,0.25,0.5,0.75,1), title = "percentage expressed",
            graphics = list(
              function(x, y, w, h) grid.circle(x = x, y = y, r = 0 * unit(2, "mm"),
                                               gp = gpar(fill = "black")),
              function(x, y, w, h) grid.circle(x = x, y = y, r = 0.25 * unit(2, "mm"),
                                               gp = gpar(fill = "black")),
              function(x, y, w, h) grid.circle(x = x, y = y, r = 0.5 * unit(2, "mm"),
                                               gp = gpar(fill = "black")),
              function(x, y, w, h) grid.circle(x = x, y = y, r = 0.75 * unit(2, "mm"),
                                               gp = gpar(fill = "black")),
              function(x, y, w, h) grid.circle(x = x, y = y, r = 1 * unit(2, "mm"),
                                               gp = gpar(fill = "black")))
            ))

#Heatmap
hp <- Heatmap(exp_mat,
        heatmap_legend_param=list(title="expression"),
        column_title = "Dotplot - normalized mean expression and %expressed", 
        top_annotation = column_ha, 
        col=col_fun,
        rect_gp = gpar(type = "none"),
        clustering_distance_columns="pearson", #use euclidean, kendall or pearson
        clustering_method_columns="average", #use centroid, average or single
        layer_fun = layer_fun,
        row_labels=sapply(strsplit(rownames(exp_mat), "_"), "[[", 1),
        cell_fun = cell_fun,
        show_row_dend = F,
        column_dend_height = unit(1.5, "cm"),
        row_names_gp = gpar(fontsize = 10),
        column_names_gp = gpar(fontsize = 10),
        column_names_rot = 45,
        border = "black")

d1 <- draw( hp, annotation_legend_list = lgd_list)

# setEPS()
# postscript(file.path(path, "results/Manuscript/2_Ext_Figure/R/bubbleplot_scaled_PT.eps"), height=7.2, width=18)
# d1
# dev.off()
```

## Save objects

Finally, the generated data objects can be saved for further downstream 
processing and analysis.We will exclude low-quality samples.

```{r save-objects-read-data}

saveRDS(spe, file.path(path, "results/Manuscript/1_Figure/spe_0px_refined.rds"))
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>