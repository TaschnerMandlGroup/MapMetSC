---
title: "Read in steinbock data"
output: html_document
date: '2022-08-12'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Read in the data {#read-data}

This section describes how to read in single-cell data and images into `R`
**after** image processing and segmentation (see Section \@ref(processing)).

We use the [imcRtools](https://github.com/BodenmillerGroup/imcRtools) package to
read in single-cell data extracted using the `steinbock` framework or the IMC
Segmentation Pipeline. Both image processing approaches also generate
multi-channel images and segmentation masks that can be read into `R` using the
[cytomapper](https://github.com/BodenmillerGroup/cytomapper) package.

```{r, message=FALSE}
library(imcRtools)
library(cytomapper)
library(BiocParallel)
```

## Read in single-cell information

For single-cell data analysis in `R` the
[SingleCellExperiment](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html)
[@Amezquita2019] data container is commonly used within the Bioconductor
framework. It allows standardized access to (i) expression data, (ii) cellular
metadata (e.g. cell type), (iii) feature metadata (e.g. marker name) and (iv)
experiment-wide metadata. For an in-depth introduction to the `SingleCellExperiment`
container, please refer to the [SingleCellExperiment class](https://bioconductor.org/books/3.14/OSCA.intro/the-singlecellexperiment-class.html).

The [SpatialExperiment](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html)
class [@Righelli2021] is an extension of the `SingleCellExperiment` class. It
was developed to store spatial data in addition to single-cell data and an
extended introduction is accessible
[here](https://bioconductor.org/packages/release/bioc/vignettes/SpatialExperiment/inst/doc/SpatialExperiment.html).

To read in single-cell data generated by the `steinbock` framework or the IMC
Segmentation Pipeline, the `imcRtools` package provides the `read_steinbock` and
`read_cpout` function, respectively. By default, the data is read into a
`SpatialExperiment` object; however, data can be read in as a
`SingleCellExperiment` object by setting `return_as = "sce"`. All functions
presented in this book are applicable to both data containers.

### steinbock generated data

The [steinbock](https://github.com/BodenmillerGroup/steinbock) framework was
used to process and segment IMC raw data available.

The `read_steinbock` function provided by `imcRtools` can now be used to read in
`steinbock` generated data. For more information, please refer to
`?read_steinbock`.

```{r read-steinbock}

path <- "/mnt/Multimodal_Imaging_Daria/PIPELINE/TEMP"
spe <- read_steinbock(path, image_file=NULL, panel_file = file.path(path, 'NB_Panel.csv')) 

#Rename third IF channel (CD45 for PT, CD56 for BM)
rownames(spe)[44] <- "IF3_CD45/56_mean"
rownames(spe)[88] <- "IF3_CD45/56_mean-80"

spe
```

By default, single-cell data is read in as `SpatialExperiment` object. 
The summarized pixel intensities per channel and cell (here mean intensity) are
stored in the `counts` slot. Columns represent cells and rows represent channels.

```{r counts}
rowData(spe)
counts(spe)[45:88,1:9]
```

Metadata associated to individual cells are stored in the `colData` slot. After
initial image processing, these metadata include the numeric identifier (`ObjectNumber`),
the area, and morphological features of each cell. In addition, `sample_id` stores
the image name from which each cell was extracted and the width and height of the
corresponding images are stored.

```{r colData}
head(colData(spe))
typeof(colData(spe))
class(spe)
class(colData(spe))
nrow(colData(spe))
colData(spe)[1:5, 2:ncol(colData(spe))]
```

The main difference between the `SpatialExperiment` and the
`SingleCellExperiment` data container in the current setting is the way spatial
locations of all cells are stored. For the `SingleCellExperiment` container, the
locations are stored in the `colData` slot while the `SpatialExperiment`
container stores them in the `spatialCoords` slot:

```{r spatialCoords}
head(spatialCoords(spe))
```

Finally, metadata regarding the channels are stored in the `rowData` slot. This
information is extracted from the `panel.csv` file. Channels are ordered by
isotope mass and therefore match the channel order of the multi-channel images
(see Section \@ref(read-images)).

```{r rowData}
head(rowData(spe))
rowData(spe)
```

## Single-cell processing {#cell-processing}

After reading in the single-cell data, few further processing steps need to be
taken.

**Add additional metadata**

We can set the `colnames` of the object to generate unique identifiers per cell:

```{r set-colnames}
colnames(spe) <- paste0(spe$sample_id, "_", spe$ObjectNumber)
```

It is also often the case that sample-specific metadata are available externally.
For the current data, we need to link metadata from an external excel file.
More information on how to extract matching patterns from a string can be found [here](https://stringr.tidyverse.org/reference/str_extract.html).

```{r add-indication}
library(stringr)

spe$sample <- gsub(spe$sample_id, pattern="([UM]).*", replacement="\\1")
spe$fm_id <- str_match(spe$sample, "_.*_(.*)_")[,2]  
spe$tissue <- str_match(spe$sample, "^.*_.*_(.*)")[,2] 
spe$tissue[spe$tissue=="TU"] = "PT"

meta_path <- "/mnt/Multimodal_Imaging_Daria/PIPELINE/metadata"
meta <- read.csv(file.path(meta_path, '20230531_metadata_complete.csv'))
#meta <- meta[meta$Tissue == 'BM',]

spe$puncture_side <- meta$Puncture_side[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$infiltration_right <- meta$Infiltration_right[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$infiltration_left <- meta$Infiltration_left[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$exclude <- meta$exclude[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$imc_score <- meta$IMC_score[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$staining_date <- meta$Staining_date[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$stainer <- meta$Stainer[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$imc_date <- meta$IMC_date[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$DE_date <- meta$DE_date[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$DE_year <- sub("-.*", "", spe$DE_date)
spe$control <- meta$control[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$study_id <- meta$Study_ID[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$timepoint <- meta$Timepoint[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$stage <- meta$stage4[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$progression <- meta$efs[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$tod <- meta$tod[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$efs_dur <- meta$efs_dur[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$tod_date <- meta$tod_dat1[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$tod_dur <- meta$tod_dur[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$rez_date <- meta$rez_dat[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$prog_date <- meta$prog_dat[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$event_date <- meta$event_dat[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$MYCN_amp <- meta$MYCN_amp[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$ALK_amp <- meta$ALK_amp[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$ALK_mut <- meta$ALK_mut[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$ATRX_del <- meta$ATRX_del[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$TERT_rear <- meta$TERT_rear[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$X1p_loss <- meta$X1p_loss[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$X1q_gain <- meta$X1q_gain[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$X11q_loss <- meta$X11q_loss[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]
spe$X17q_gain <- meta$X17q_gain[match(paste(spe$fm_id, spe$tissue), paste(meta$Sample, meta$Tissue))]

spe$ROI <- str_match(spe$sample_id, "^.*_.*_.*_.*_(.*)")[,2]
spe$year <- gsub(spe$sample_id, pattern="^.*_.*_(.*)-.*", replacement="\\1")
```


**Check for technical confounders (batch effects)**

```{r plot by sample}

selected_samples <- unique(spe$sample)
marker <- 'IF3_CD56_mean-80'

library(dittoSeq)
dittoRidgePlot(spe[,spe$sample%in%selected_samples], var = marker, group.by = "sample", assay = "counts") +
    ggtitle(paste(marker,  "- per sample"))
```

```{r plot by staining date}

marker <- 'CD3_Sm152_mean-80'
selecting_staining_dates <- unique(spe$staining_date)[1:5]
dittoRidgePlot(spe[,spe$staining_date%in%selecting_staining_dates], var = marker, group.by = "staining_date", assay = "counts") +
    ggtitle(paste(marker,  "- per staining batch"))

```


## Save objects

Finally, the generated data objects can be saved for further downstream 
processing and analysis.We will exclude low-quality samples.

```{r save-objects-read-data}

spe <- spe[,spe$exclude%in%c("no", "maybe")]
assay(spe, "exprs") <- assay(spe, "counts")

saveRDS(spe, file.path(path, "data/spe_no-dil-refined.rds"))
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>