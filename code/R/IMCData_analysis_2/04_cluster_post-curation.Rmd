---
title: "UMAP and histogram on matrices"
output: html_document
date: '2022-12-28'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
```

In this RMD file, we will perform clustering on the curated data (after excluding cells that swam off between IF and IMC and segmentation artifacts). First, we will read our SPE.

```{r read-data}

path <- "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS"

spe <- readRDS(file.path(path,"results/spe_1px_non-refined_curated.rds"))

```


Then we will generate a matrix from intensity features and exclude low-quality markers such as IDO, PNMT, FN1, CXCR2 and all IF and nuclear markers. We will then use mean intensity for clustering, because the effect of lateral spillover or artifacts is diminished in this metric as compared to mean-80.

```{r generate-dataframes, message=FALSE, fig.height=7}
library(bruceR)
library(SpatialExperiment)

intensity_mat <- assay(spe, "exprs")
colnames(intensity_mat) <- spe$sample
intensity_mat <- intensity_mat[!grepl("mean-80", rownames(intensity_mat)),]


intensity_mat_hq <- intensity_mat[!grepl("IDO|DAPI|IF2_GD2|IF3_CD45/56|DNA1|H4K12Ac|H3K9Ac|CXCR2|PNMT|Fibro", rownames(intensity_mat)),]
intensity_mat_lq <- intensity_mat[grepl("IDO|DAPI|IF2_GD2|IF3_CD45/56|DNA1|H4K12Ac|H3K9Ac|CXCR2|PNMT|Fibro", rownames(intensity_mat)),]

#Make sure to exclude cells that are zero for all markers as PG won't work otherwise 
non_zeros <- as.logical(colSums(intensity_mat_hq)!=0)

intensity_mat_hq_wo_zeros <- intensity_mat_hq[,non_zeros]
intensity_mat_lq_wo_zeros <- intensity_mat_lq[,non_zeros]
spe <- spe[,non_zeros]


cell_id <- colnames(spe)
tissue <- spe$tissue

```

We will add morphological features according to the determined thresholds. 
```{r generate-dataframes, message=FALSE, fig.height=10, fig.width=7}

#Normalization and scaling functions 
norm_minmax <- function(x){(x- min(x)) /(max(x)-min(x))}

robust_scalar<- function(x){(x- median(x)) /(quantile(x,probs = .75)-quantile(x,probs = .25))}

clipper <- function(data, lower, upper) {
  data[data > quantile(data, probs = c(upper))] <- quantile(data, probs = c(upper))
  data[data < quantile(data, probs = c(lower))] <- quantile(data, probs = c(lower))
  clipped_data <- norm_minmax(data)
  return(clipped_data)}


#Generation of matrix with morphological features
morph_names <- c("area",
                 "solidity",
                 "aspect_ratio-0"
                 )

morph_mat <- as.matrix(t(colData(spe)[,morph_names]))
rownames(morph_mat) <- gsub('-0','',rownames(morph_mat))

area_upper <- 0.99999
solidity_lower <- 0.001
aspect_ratio_upper <- 0.9995 

clipped_area <- c(clipper(morph_mat[1,tissue=="BM"], 0, area_upper), clipper(morph_mat[1,tissue=="PT"], 0, area_upper))
clipped_area <- clipped_area[colnames(spe)]

morph_mat_clipped <- rbind(clipped_area, clipper(morph_mat[2,], solidity_lower, 1), clipper(morph_mat[3,], 0, aspect_ratio_upper))

colnames(morph_mat_clipped) <- spe$sample

rownames(morph_mat_clipped) <- c("area", "solidity", "aspect_ratio")

#Concatenate intensity and morphological features
mat <- rbind(intensity_mat_hq_wo_zeros, morph_mat_clipped)
#mat <- intensity_mat_hq_wo_zeros
```

In a next step, we will plot a single-cell heatmap using complex heatmap. 

```{r single-cell-heatmap, message=FALSE, fig.height=20}
library(ComplexHeatmap)
library(viridis)
library(circlize)
library(RColorBrewer)
library(paletteer)

set.seed(221228)

qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector_74 = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
col_vector_433 = colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]

col_sample = setNames(sample(col_vector_433, length(unique(spe$sample))), unique(spe$sample))

rand_cells <- sample(seq_len(ncol(mat)), 2000)

column_ha = HeatmapAnnotation(sample = colnames(mat[,rand_cells]), col=list(sample=col_sample), show_legend=F)
Heatmap(mat[,rand_cells], 
        column_title = "Single-cell heatmap",
        top_annotation = column_ha, 
        show_column_dend = F,
        show_column_names=F,
        col=viridis(100)
        )
```

We will now cluster the data.

```{r phenograph-clustering}
library(FastPG)
library(parallel)

set.seed(221229)
n_threads <- detectCores()

mat <- t(mat)

# out <- FastPG::fastCluster(data=mat, k=45, num_threads=n_threads)
# clusters <- factor(out$communities)

# saveRDS(clusters, file.path(path, "results/int_morph/clusters-1px-postcuration_intensity-morphology.rds"))
clusters <- readRDS(file.path(path, "results/int_morph/clusters-1px-postcuration_intensity-morphology.rds"))

```

Now we will plot 41 distinct, manually selected colors.
```{r colors, message=FALSE, fig.height=17}

n <- length(unique(clusters))


col_clusters <- c(rgb(255,255,162, maxColorValue = 255),
                rgb(255,221,57, maxColorValue = 255),
                rgb(246,246,0, maxColorValue = 255),
                rgb(255,255,209, maxColorValue = 255),
                rgb(254,217,166, maxColorValue = 255),
                rgb(253,180,98, maxColorValue = 255),
                rgb(255,137,0, maxColorValue = 255),
                rgb(241,75,2, maxColorValue = 255),
                rgb(152,78,163, maxColorValue = 255),
                rgb(188,128,189, maxColorValue = 255),
                rgb(190,174,212, maxColorValue = 255),
                rgb(253,218,236, maxColorValue = 255),
                rgb(251,154,153, maxColorValue = 255),
                rgb(242,3,137, maxColorValue = 255),
                rgb(251,128,114, maxColorValue = 255),
                rgb(254,142,175, maxColorValue = 255),
                rgb(240,0,240, maxColorValue = 255),
                rgb(227,26,28, maxColorValue = 255),
                rgb(147,3,0, maxColorValue = 255),
                rgb(230,245,201, maxColorValue = 255),
                rgb(204,235,197, maxColorValue = 255),
                rgb(179,222,105, maxColorValue = 255),
                rgb(198,255,72, maxColorValue = 255),
                rgb(65,208,57, maxColorValue = 255),
                rgb(104,180,238, maxColorValue = 255),
                rgb(128,177,211, maxColorValue = 255),
                rgb(51,180,180, maxColorValue = 255),
                rgb(102,166,30, maxColorValue = 255),
                rgb(149,144,89, maxColorValue = 255),
                rgb(210,205,126, maxColorValue = 255),
                rgb(27,158,119, maxColorValue = 255),
                rgb(102,194,165, maxColorValue = 255),
                rgb(39,130,187, maxColorValue = 255),
                rgb(166,206,227, maxColorValue = 255),
                rgb(212,241,240, maxColorValue = 255),
                rgb(169,189,210, maxColorValue = 255),
                rgb(2,0,138, maxColorValue = 255),
                rgb(217,217,217, maxColorValue = 255),
                rgb(113,113,113, maxColorValue = 255),
                rgb(156,76,24, maxColorValue = 255),
                rgb(174,129,37, maxColorValue = 255))

pie(rep(1,n), col=col_clusters, labels=col_clusters)

col_clusters <- setNames(col_clusters, c(0:40))
```

Next we will look at the single cell heatmap ordered by the identified phenograph clusters for 2000 randomly selected cells. 

```{r single-cell-heatmap-clusters, message=FALSE, fig.height=17}
library(ComplexHeatmap)
library(viridis)
library(circlize)
library(RColorBrewer)
library(paletteer)


set.seed(20230521)

col_marker = colorRamp2(c(0, 2.5, 0.5), c("blue", "white", "red"))
col_tissue = c("PT" = "deepskyblue", "BM" = "orange")

rand_cells <- sample(seq_len(ncol(mat)), 2000)


# area = morph_mat_scaled["area",]
# solidity = morph_mat_scaled["solidity",]
# concavity = morph_mat_scaled["concavity",]
# 
# #col_morph = colorRamp2(c(0,0.5, 1), c("blue", "white", "red"))
# col_area = colorRamp2(c(min(area[rand_cells]),min(area[rand_cells])+(max(area[rand_cells])-min(area[rand_cells]))/2, max(area[rand_cells])), c("blue", "white", "red"))
# col_solidity = colorRamp2(c(min(solidity[rand_cells]),min(solidity[rand_cells])+(max(solidity[rand_cells])-min(solidity[rand_cells]))/2, max(solidity[rand_cells])), c("blue", "white", "red"))
# col_concavity = colorRamp2(c(min(concavity[rand_cells]),min(concavity[rand_cells])+(max(concavity[rand_cells])-min(concavity[rand_cells]))/2, max(concavity[rand_cells])), c("blue", "white", "red"))

column_ha = HeatmapAnnotation(cluster = clusters[rand_cells],
                              tissue = tissue[rand_cells],
                              # area = area[rand_cells],
                              # solidity = solidity[rand_cells],
                              # concavity = concavity[rand_cells],
                              col=list(cluster=col_clusters, 
                                       tissue=col_tissue
                                       # area = col_area,
                                       # solidity = col_solidity,
                                       # concavity = col_concavity
                                       ), 
                              show_legend=T)


Heatmap(mat[,rand_cells], 
        column_title = "Single-cell heatmap with phenograph clusters (1-px mean)",
        top_annotation = column_ha, 
        cluster_columns=F,
        column_order= order(clusters[rand_cells], decreasing=F),
        show_column_dend = F,
        show_column_names=F,
        col=viridis(100)
        )
```

Next we will look at the single cell heatmap ordered by the identified phenograph clusters and sample the same number of cells from BM and PT samples. 

```{r single-cell-heatmap-clusters, message=FALSE, fig.height=17}
library(ComplexHeatmap)
library(viridis)
library(circlize)
library(RColorBrewer)
library(paletteer)


set.seed(20230618)

col_marker = colorRamp2(c(0, 2.5, 0.5), c("blue", "white", "red"))
col_tissue = c("PT" = "deepskyblue", "BM" = "orange")

#mat <- t(mat)

#Get same number of PT and BM cells
pt_index <- which(tissue=="PT")
bm_index <- which(tissue=="BM")
rand_cells_pt <- sample(seq_len(length(pt_index)), 4000)
rand_cells_bm <- sample(seq_len(length(bm_index)), 4000)
pt_index_rand <- pt_index[rand_cells_pt]
bm_index_rand <- bm_index[rand_cells_bm]
rand_cells <- c(pt_index_rand, bm_index_rand)

# col_area = colorRamp2(c(min(area[rand_cells]),min(area[rand_cells])+(max(area[rand_cells])-min(area[rand_cells]))/2, max(area[rand_cells])), c("blue", "white", "red"))
# col_solidity = colorRamp2(c(min(solidity[rand_cells]),min(solidity[rand_cells])+(max(solidity[rand_cells])-min(solidity[rand_cells]))/2, max(solidity[rand_cells])), c("blue", "white", "red"))
# col_concavity = colorRamp2(c(min(concavity[rand_cells]),min(concavity[rand_cells])+(max(concavity[rand_cells])-min(concavity[rand_cells]))/2, max(concavity[rand_cells])), c("blue", "white", "red"))

column_ha = HeatmapAnnotation(cluster = clusters[rand_cells],
                              tissue = tissue[rand_cells],
                              #area = area[rand_cells],
                              #solidity = solidity[rand_cells],
                              #concavity = concavity[rand_cells],
                              col=list(cluster=col_clusters, 
                                       tissue=col_tissue
                                       #area = col_area,
                                       #solidity = col_solidity,
                                       #concavity = col_concavity
                                       ), 
                              show_legend=T)


Heatmap(mat[,rand_cells], 
        column_title = "Single-cell heatmap with phenograph clusters (1-px mean)",
        top_annotation = column_ha, 
        cluster_columns=F,
        column_order= order(clusters[rand_cells], decreasing=F),
        show_column_dend = F,
        show_column_names=F,
        col=viridis(100)
        )
```
Next we will look at the single cell heatmap ordered by the identified phenograph clusters and sample the same number of cells from BM and PT samples per cluster. 

```{r single-cell-heatmap-clusters, message=FALSE, fig.height=17}

set.seed(20230517)

n <- length(unique(clusters))

count <- 45
rand_cells <- c()

#Get same number of PT and BM cells per cluster
for (i in 1: length(unique(clusters))){
  pt_index <- which(tissue=="PT" & clusters == unique(clusters)[i])
  bm_index <- which(tissue=="BM" & clusters == unique(clusters)[i])
  if (length(pt_index) < count){
    pt_diff <- count-length(pt_index)
    print(paste("PT_diff: ", pt_diff, " for cluster ", unique(clusters)[i]))
    rand_index_pt <- sample(pt_index, length(pt_index))
    rand_index_bm <- sample(bm_index, (count + pt_diff))
  } else if (length(bm_index) < count){
    bm_diff <- count-length(bm_index)
    rand_index_pt <- sample(pt_index, (count + bm_diff))
    rand_index_bm <- sample(bm_index, length(bm_index))
  } else {
      rand_index_pt <- sample(pt_index, count)
      rand_index_bm <- sample(bm_index, count)
  }

  rand_cells <- c(rand_cells, rand_index_pt, rand_index_bm)
}

# col_area = colorRamp2(c(min(area[rand_cells]),min(area[rand_cells])+(max(area[rand_cells])-min(area[rand_cells]))/2, max(area[rand_cells])), c("blue", "white", "red"))
# col_solidity = colorRamp2(c(min(solidity[rand_cells]),min(solidity[rand_cells])+(max(solidity[rand_cells])-min(solidity[rand_cells]))/2, max(solidity[rand_cells])), c("blue", "white", "red"))
# col_concavity = colorRamp2(c(min(concavity[rand_cells]),min(concavity[rand_cells])+(max(concavity[rand_cells])-min(concavity[rand_cells]))/2, max(concavity[rand_cells])), c("blue", "white", "red"))
# 
# col_marker = colorRamp2(c(0, 2.5, 0.5), c("blue", "white", "red"))
col_tissue = c("PT" = "deepskyblue", "BM" = "orange")

#mat <- t(mat)
                                       
                                       
column_ha = HeatmapAnnotation(cluster = clusters[rand_cells],
                              tissue = tissue[rand_cells],
                              # area = area[rand_cells],
                              # solidity = solidity[rand_cells],
                              # concavity = concavity[rand_cells],
                              col=list(cluster=col_clusters, 
                                       tissue=col_tissue
                                       # area = col_area,
                                       # solidity = col_solidity,
                                       # concavity = col_concavity
                                       ), 
                              show_legend=T)


Heatmap(mat[,rand_cells], 
        column_title = "Single-cell heatmap with phenograph clusters (1-px mean)",
        top_annotation = column_ha, 
        cluster_columns=F,
        column_order= order(clusters[rand_cells], decreasing=F),
        show_column_dend = F,
        show_column_names=F,
        col=viridis(100)
        )
```

Next we will look at the single cell heatmap ordered by the identified phenograph clusters and sample the same number of cells from each cluster

```{r single-cell-heatmap-clusters, message=FALSE, fig.height=17}

set.seed(20230517)

n <- length(unique(clusters))

count <- 90
rand_cells <- c()

#Get same number of PT and BM cells per cluster
for (i in 1: length(unique(clusters))){
  idx <- which(clusters == unique(clusters)[i])
  rand_idx <- sample(idx, count)
  rand_cells <- c(rand_cells, rand_idx)
}

# col_area = colorRamp2(c(min(area[rand_cells]),min(area[rand_cells])+(max(area[rand_cells])-min(area[rand_cells]))/2, max(area[rand_cells])), c("blue", "white", "red"))
# col_solidity = colorRamp2(c(min(solidity[rand_cells]),min(solidity[rand_cells])+(max(solidity[rand_cells])-min(solidity[rand_cells]))/2, max(solidity[rand_cells])), c("blue", "white", "red"))
# col_concavity = colorRamp2(c(min(concavity[rand_cells]),min(concavity[rand_cells])+(max(concavity[rand_cells])-min(concavity[rand_cells]))/2, max(concavity[rand_cells])), c("blue", "white", "red"))

col_marker = colorRamp2(c(0, 2.5, 0.5), c("blue", "white", "red"))
col_tissue = c("PT" = "deepskyblue", "BM" = "orange")

#mat <- t(mat)

column_ha = HeatmapAnnotation(cluster = clusters[rand_cells],
                              tissue = tissue[rand_cells],
                              # area = area[rand_cells],
                              # solidity = solidity[rand_cells],
                              # concavity = concavity[rand_cells],
                              col=list(cluster=col_clusters, 
                                       tissue=col_tissue
                                       # area = col_area,
                                       # solidity = col_solidity,
                                       # concavity = col_concavity
                                       ), 
                              show_legend=T)


Heatmap(mat[,rand_cells], 
        column_title = "Single-cell heatmap with phenograph clusters (1-px mean)",
        top_annotation = column_ha, 
        cluster_columns=F,
        column_order= order(clusters[rand_cells], decreasing=F),
        show_column_dend = F,
        show_column_names=F,
        col=viridis(100)
        )
```

Next, we will look at the mean marker expression per cluster. 

```{r ingle-cell-heatmap-clusters-mean, message=FALSE, fig.height=17}
library(scuttle)

set.seed(20230135)

mean <- aggregate(t(mat), list(clusters), mean)

mean_t <- t(mean[,2:ncol(mean)])
colnames(mean_t) <- mean[,"Group.1"]


# mat_morph <- morph_mat_scaled
# mean_morph <- aggregate(t(mat_morph), list(clusters), mean)

mean_t <- t(mean[,2:ncol(mean)])
colnames(mean_t) <- mean[,"Group.1"]

# area_mean = mean_morph[,"area"]
# solidity_mean = mean_morph[,"solidity"]
# concavity_mean = mean_morph[,"concavity"]
# 
# col_mean_area = colorRamp2(c(min(area_mean),min(area_mean)+(max(area_mean)-min(area_mean))/2, max(area_mean)), c("blue", "white", "red"))
# col_mean_solidity = colorRamp2(c(min(solidity_mean),min(solidity_mean)+(max(solidity_mean)-min(solidity_mean))/2, max(solidity_mean)), c("blue", "white", "red"))
# col_mean_concavity = colorRamp2(c(min(concavity_mean),min(concavity_mean)+(max(concavity_mean)-min(concavity_mean))/2, max(concavity_mean)), c("blue", "white", "red"))

column_ha = HeatmapAnnotation(cluster = mean[,"Group.1"], 
                              #area=area_mean,
                              #solidity = solidity_mean, 
                              #concavity = concavity_mean, 
                              ncells=anno_barplot(as.data.frame(table(clusters))[,"Freq"], height = unit(3, "cm")),
                              col=list(cluster=col_clusters 
                                       #area=col_mean_area,
                                       #solidity=col_mean_solidity,
                                       #concavity=col_mean_concavity
                                       ), 
                              show_legend=T)



# Feature-wise scaling
#mean_t <- t(apply(mean_t, 1, RESCALE, to=0:1))

Heatmap(mean_t, 
        column_title = "Cluster-means heatmap with phenograph clusters (1px -mean)-scaled",
        top_annotation = column_ha, 
        cluster_columns=T,
        show_column_dend = F,
        show_column_names=T,
        show_row_names=T,
        col=viridis(100)
        )


```
We can see that cluster 35 are the sticky cells, which are positive for everything. We will exclude this cluster and re-generate the heatmap.

```{r ingle-cell-heatmap-clusters-mean, message=FALSE, fig.height=17}
library(scuttle)

set.seed(20230135)

sticky_cluster <- "35"

# Feature-wise scaling
mean_t_wo_sticky <- mean_t[,levels(clusters)!=sticky_cluster]
mean_t_wo_sticky <- t(apply(mean_t_wo_sticky, 1, RESCALE, to=0:1))
clusters_wo_sticky <- droplevels(clusters[clusters!=sticky_cluster])

# area_mean_wo_sticky <- area_mean[levels(clusters)!=sticky_cluster]
# solidity_mean_wo_sticky <- solidity_mean[levels(clusters)!=sticky_cluster]
# concavity_mean_wo_sticky <- concavity_mean[levels(clusters)!=sticky_cluster]
# 
# 
# col_mean_area_wo_sticky = colorRamp2(c(min(area_mean_wo_sticky),min(area_mean_wo_sticky)+(max(area_mean_wo_sticky)-min(area_mean_wo_sticky))/2, max(area_mean_wo_sticky)), c("blue", "white", "red"))
# col_mean_solidity_wo_sticky = colorRamp2(c(min(solidity_mean_wo_sticky),min(solidity_mean_wo_sticky)+(max(solidity_mean_wo_sticky)-min(solidity_mean_wo_sticky))/2, max(solidity_mean_wo_sticky)), c("blue", "white", "red"))
# col_mean_concavity_wo_sticky = colorRamp2(c(min(concavity_mean_wo_sticky),min(concavity_mean_wo_sticky)+(max(concavity_mean_wo_sticky)-min(concavity_mean_wo_sticky))/2, max(concavity_mean_wo_sticky)), c("blue", "white", "red"))

col_clusters_wo_sticky <- col_clusters[names(col_clusters)!=sticky_cluster]

column_ha = HeatmapAnnotation(cluster = droplevels(mean[levels(clusters)!=sticky_cluster,"Group.1"]),
                              #area=area_mean_wo_sticky,
                              #solidity=solidity_mean_wo_sticky,
                              #concavity=concavity_mean_wo_sticky,
                              ncells=anno_barplot(as.data.frame(table(clusters_wo_sticky))[,"Freq"], height = unit(3, "cm")),
                              col=list(cluster=col_clusters_wo_sticky
                                       #area=col_mean_area_wo_sticky,
                                       #solidity=col_mean_solidity_wo_sticky,
                                       #concavity=col_mean_concavity_wo_sticky
                                       ), 
                              show_legend=T)

Heatmap(mean_t_wo_sticky, 
        column_title = "Cluster-means heatmap with phenograph clusters (1px -mean)-scaled",
        top_annotation = column_ha, 
        cluster_columns=T,
        show_column_dend = F,
        show_column_names=T,
        show_row_names=T,
        col=viridis(100)
        )


```

Then, we will perform dimensionality reduction by a UMAP. 

```{r UMAP, message=FALSE}
library(scater)
library(BiocParallel)

set.seed(221228)

# mat_red <- calculateUMAP(mat, BPPARAM = MulticoreParam()) 
# rownames(mat_red) <- colnames(mat)
# 
# saveRDS(mat_red, file.path(path, "results/int_morph/mat_red_1px_int-morphology.rds"))

mat_red <- readRDS(file.path(path,"results/int_morph/mat_red_1px_int-morphology.rds"))
```

Next we will visualize the tissue type in the UMAP space.

```{r visualizing-umap-by-phenograph-cluster, message=F, fig.width=17}

#clusters <- clusters[!clusters %in% c("1", "29")]

mat_red_df <- as.data.frame(mat_red)
mat_red_df["tissue"] <- tissue
mat_red_df_rand <- mat_red_df[sample(1:nrow(mat_red_df)),]
  
plot <- ggplot(mat_red_df_rand, aes(x=V1, y=V2, colour=tissue)) +
    geom_point(alpha=0.5, show.legend=T) + 
    ggtitle("Tissue type") +
    scale_colour_manual(values = col_tissue) +
    theme(plot.title = element_text(size = 15), 
          axis.title = element_text(size=15), 
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(), 
          panel.background = element_blank(), 
          axis.line = element_line(colour = "black"),
          legend.text = element_text(size=15))

plot
```

Next we will visualize the clusters in the UMAP space.

```{r visualizing-umap-by-phenograph-cluster, message=F, fig.width=17}

#clusters <- clusters[!clusters %in% c("1", "29")]

mat_red_df <- as.data.frame(mat_red)
mat_red_df["clusters"] <- clusters
mat_red_df_rand <- mat_red_df[sample(1:nrow(mat_red_df)),]
  
plot <- ggplot(mat_red_df_rand, aes(x=V1, y=V2, colour=clusters)) +
    geom_point(alpha=0.5, show.legend=T) + 
    ggtitle("Phenograph cluster") +
    scale_colour_manual(values = col_clusters) +
    theme(plot.title = element_text(size = 15), 
          axis.title = element_text(size=15), 
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(), 
          panel.background = element_blank(), 
          axis.line = element_line(colour = "black"),
          legend.text = element_text(size=15))

plot
```

Now, we will plot all samples in the dim-red space. 

```{r visualizing-umap-by-sample, message=F, fig.width=20}

library(RColorBrewer)


mat_red_df <- as.data.frame(mat_red)
mat_red_df["sample"] <- rownames(mat_red)
mat_red_df_rand <- mat_red_df[sample(1:nrow(mat_red_df)),]
  
plot <- ggplot(mat_red_df_rand, aes(x=V1, y=V2, colour=sample)) +
    geom_point(size=0.05, alpha=0.5, show.legend=T) + 
    ggtitle("Sample") +
    scale_colour_manual(values = col_sample) +
    theme(plot.title = element_text(size = 5), 
          axis.title = element_text(size=5), 
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(), 
          panel.background = element_blank(), 
          axis.line = element_line(colour = "black"),
          legend.text = element_text(size=5))

plot
```

Now, we will plot the marker separately in the dim-red space. 

```{r visualizing-umap-by-marker, message=F, fig.width=20}
mat_tmp <- rbind(mat, intensity_mat_lq_wo_zeros)

for (i in 1: nrow(mat_tmp)){
  marker <- rownames(mat_tmp)[i]
  mat_red_df <- as.data.frame(mat_red)
  mat_red_df["marker"] <- mat_tmp[i,]
  #mat_red_df_rand <- mat_red_df[sample(1:nrow(mat_red_df)),]
  mat_red_df_rand <- mat_red_df[order(mat_red_df["marker"], decreasing=F),]
    
  plot <- ggplot(mat_red_df_rand, aes(x=V1, y=V2, colour=marker)) +
      geom_point(size=0.05, alpha=0.2, show.legend=T) + 
      ggtitle(marker) +
      scale_colour_viridis_c() +
      theme(plot.title = element_text(size = 5), 
            axis.title = element_text(size=5), 
            panel.grid.major = element_blank(), 
            panel.grid.minor = element_blank(), 
            panel.background = element_blank(), 
            axis.line = element_line(colour = "black"),
            legend.text = element_text(size=5))
  
  ggsave(filename=file.path(path, paste0("results/intensity_morph_markers_increasing/", marker , ".tiff")), width = 10, height = 5) #units = "in", device='tiff', dpi=500)
} 
```

Next, we will plot the tissue type separately in the dim-red space.

```{r visualizing-umap-by-tissuetype}

var <- "tissue"

meta <- colData(spe)[match(rownames(mat_red), spe$sample),var]

samples <- unique(meta)

bin_col <- setNames(c(adjustcolor("gray90",alpha.f=1), "palegreen4"), c(FALSE,TRUE))

plot_list <- list()

for(i in 1: length(samples)){

  sample_binary <- meta == samples[i] 
  
  background <- as.data.frame(mat_red[!sample_binary,])
  foreground <- as.data.frame(mat_red[sample_binary,])
  plot_list[[i]] <- ggplot(background, aes(x=V1, y=V2) ) +
    geom_point(color="gray90", size=0.02) +
    geom_point(data=foreground, color="palegreen4", show.legend=F, size=0.02, alpha=0.25) +
    ggtitle(samples[i]) +
    theme(plot.title = element_text(size = 5), 
          axis.title = element_text(size=5), 
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(), 
          panel.background = element_blank(), 
          axis.line = element_line(colour = "black"))
}


plot_list[[1]]
plot_list[[2]]
```

Now, we will plot the clusters separately in the dim-red space. 

```{r visualizing-umap-by-marker, message=F, fig.width=20}

samples <- unique(clusters)

for(i in 1: length(samples)){

  sample_binary <- clusters == samples[i] 
  
  background <- as.data.frame(mat_red[!sample_binary,])
  foreground <- as.data.frame(mat_red[sample_binary,])
  plot <- ggplot(background, aes(x=V1, y=V2) ) +
    geom_point(color="gray90", size=0.02) +
    geom_point(data=foreground, color="palegreen4", show.legend=F, size=0.02, alpha=0.25) +
    ggtitle(samples[i]) +
    theme(plot.title = element_text(size = 5), 
          axis.title = element_text(size=5), 
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(), 
          panel.background = element_blank(), 
          axis.line = element_line(colour = "black"))
  
  ggsave(filename=file.path(path, paste0("results/cluster/cluster_", samples[i] , ".tiff")), width = 10, height = 5, units = "in", device='tiff', dpi=500)
}

```


Finally, we will visualize the data in the dimensionality reduced space and color the dots by the sample they belong to. 

```{r visualizing-umap-by-sample-single}

var <- "sample"

meta <- colData(spe)[match(rownames(mat_red), spe$sample),var]

samples <- unique(meta)

bin_col <- setNames(c(adjustcolor("gray90",alpha.f=1), "palegreen4"), c(FALSE,TRUE))

plot_list <- list()

for(i in 1: length(samples)){

  sample_binary <- meta == samples[i] 
  
  background <- as.data.frame(mat_red[!sample_binary,])
  foreground <- as.data.frame(mat_red[sample_binary,])
  plot_list[[i]] <- ggplot(background, aes(x=V1, y=V2) ) +
    geom_point(color="gray90", size=0.05) + 
    geom_point(data=foreground, color="palegreen4", show.legend=F, size=0.05, alpha=0.25) +
    ggtitle(samples[i]) +
    theme(plot.title = element_text(size = 5), 
          axis.title = element_text(size=5), 
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(), 
          panel.background = element_blank(), 
          axis.line = element_line(colour = "black"))
}


plot_sublists <- split(plot_list, ceiling(seq_along(plot_list) / 33)) 

save_tiff <- function(sublist, j){
  plot <- plot_grid(plotlist = sublist, nrow=11, ncol=3) 
  ggsave(filename=file.path(path, paste("/data/sample/sample_", j, ".tiff", sep="")), width = 7, height = 20, units = "in", device='tiff', dpi=500)
}

mapply(save_tiff, plot_sublists, 1:length(plot_sublists))
```

Next, we will visualize the cluster per sample and the sample per cluster as described [here](https://r-graph-gallery.com/48-grouped-barplot-with-ggplot2.html).
```{r barplot-cluster-per-sample, fig.width=18}
 # library
library(ggplot2)
library(tidyverse)

col_clusters <- col_clusters[order(as.integer(names(col_clusters)))]

data <- data.frame(sample=colnames(mat), clusters)
data$freq <- 1

data_wide <- data %>% pivot_wider(names_from = c("clusters"), values_from = "freq", values_fn = sum, values_fill = 0)

#write.csv(data_wide, file.path(path, "results/int_morph/clusters-per-sample.csv"))

data_long <- data_wide[1:50,] %>% pivot_longer(cols = !sample, names_to = "cluster", values_to = "count") 

data_long$cluster <- factor(data_long$cluster, levels=levels(clusters))

 
# Stacked + percent
ggplot(data_long, aes(fill=cluster, y=count, x=sample)) + 
  ggtitle("Clusters per BM sample 1:50") +
  geom_bar(position="fill", stat="identity") + 
  scale_fill_manual(values = col_clusters) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 
```


```{r barplot-samples-per-cluster, fig.width=20}
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector_433 = colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
col_sample = setNames(sample(col_vector_433, length(unique(data$sample))), unique(data$sample))

data_wide <- data %>% pivot_wider(names_from = c("sample"), values_from = "freq", values_fn = sum, values_fill = 0)

#write.csv(data_wide, file.path(path, "results/int_morph/samples-per-cluster.csv"))

data_long <- data_wide %>% pivot_longer(cols = !clusters, names_to = "sample", values_to = "count") 

 
# Stacked + percent
ggplot(data_long, aes(fill=sample, y=count, x=clusters)) + 
  ggtitle("Samples per cluster") +
  geom_bar(position="fill", stat="identity", show.legend = F) + 
  scale_fill_manual(values = col_sample) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 
```

We will now visualize the tissues per cluster. 

```{r barplot-tissues-per-cluster, fig.width=20}
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector_433 = colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
#col_sample = setNames(sample(col_vector_433, length(unique(data$sample))), unique(data$sample))

data <- data.frame(tissue=gsub(".*_*_", "", colnames(mat)), clusters)
data[data$tissue%in%"TU",]$tissue <- "PT"
data$freq <- 1
data_wide <- data %>% pivot_wider(names_from = c("tissue"), values_from = "freq", values_fn = sum, values_fill = 0)

#write.csv(data_wide, file.path(path, "/results/int_morph/tissues-per-cluster.csv"))

data_long <- data_wide %>% pivot_longer(cols = !clusters, names_to = "tissue", values_to = "count") 

 
# Stacked + percent
ggplot(data_long, aes(fill=tissue, y=count, x=clusters)) + 
  ggtitle("Samples per cluster") +
  geom_bar(position="fill", stat="identity", show.legend = T) + 
  scale_fill_manual(values = col_tissue) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 
```

We will now visualize the clusters in a few samples to see if they make sense.

```{r visualize-clusters-in-image, message=FALSE, fig.width=15}
library(cytomapper)

spe$pg_clusters <- clusters

files <- list.files(file.path(path, "masks_temp"))

for(i in 1: length(files)){
  masks <- loadImages(file.path(path, "masks_temp", files[i]), as.is = TRUE)
  
  mcols(masks) <- DataFrame(sample_id = names(masks))
  
  
  plotCells(masks,
            object = spe, 
            cell_id = "ObjectNumber", img_id = "sample_id",
            colour_by = "pg_clusters",
            colour = list(pg_clusters = col_clusters),
            display = "single",
            save_plot = list(filename = file.path(path, "results/", paste0(files[i], "f"))),
            legend = NULL)

}

```

The next steps are to exclude sticky cells and low-quality markers and then to find a way to include morphological features.


