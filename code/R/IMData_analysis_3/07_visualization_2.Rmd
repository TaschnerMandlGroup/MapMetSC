# Single cell visualization {#single-cell-visualization}

The following section describes typical approaches on how to visualize
single-cell data.

This chapter is divided into three parts. Section \@ref(cell-type-level)
will highlight visualization approaches downstream of our cell type
classification from Section \@ref(classification). We will then focus on
visualization methods that relate single-cell data to the sample level
in Section \@ref(sample-level). Lastly, Section \@ref(rich-example) will
provide a more customized example on how to integrate various
single-cell and sample metadata into one heatmap using the
[ComplexHeatmap](https://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html)
package [@Gu2016].

Visualization functions from popular R packages in single-cell research
such as
[scater](https://bioconductor.org/packages/release/bioc/html/scater.html),
[DittoSeq](https://bioconductor.org/packages/release/bioc/html/dittoSeq.html)
and
[CATALYST](https://bioconductor.org/packages/release/bioc/html/CATALYST.html)
will be utilized. We will recycle methods and functions that we have
seen in previous sections, while also introducing new ones.

Please note that this chapter aims to provide an overview on **common**
visualization options and should be seen as a stepping-stone. However,
many more options exist and the user should customize the visualization
according to the biological question at hand.

## Load data

First, we will read in the previously generated `SpatialExperiment`
object.

```{r read-data-scviz, message=FALSE}
path <- "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS"

spe <- readRDS(file.path(path,"results/spe_processed.rds"))
```

For visualization purposes, we will define markers that were used for
cell type classification and markers that can indicate a specific cell
state (e.g. Ki67).

```{r define-markers, message=FALSE}
# Define cell_type_markers 
type_markers <- c("MPO_Y89_mean", "CD44_In115_mean", "CD11b_Nd142_mean", "HLA-DR_Nd143_mean", "PRPH_Nd144_mean", "HLA-ABC_Sm147_mean", "CD20_Nd148_mean", "LUM_Sm149_mean", "CD11c_Nd150_mean",
                  "CD24_Eu151_mean", "CD3_Sm152_mean", "CD45_Eu153_mean", "CD8a_Sm154_mean", "GD2_Gd155_mean", "CD34_Gd156_mean", "CD10_Gd158_mean", "CXCR4_Tb159_mean","SOX10_Dy162_mean",
                  "FOXP3_Dy163_mean", "CHGA_Dy164_mean", "GATA3_Er168_mean", "CD56_Er170_mean", "CD4_Yb171_mean", "ELAVL4_Yb174_mean", "CD14_Lu175_mean", "Vimentin_Pt196_mean", "CD15_Bi209_mean")

# Define cell_state_markers 
state_markers <- c("CD274_Gd160_mean", "S100B_Dy161_mean", "CD279_Ho165_mean", "Ki-67_Tm169_mean", "GZMB_Yb173_mean")

# Add to spe
rowData(spe)$marker_class <- ifelse(rownames(spe) %in% type_markers, "type",
                                    ifelse(rownames(spe) %in% state_markers, "state", 
                                    "other"))
```

## Cell-type level {#cell-type-level}

In the first section of this chapter, the grouping-level for the
visualization approaches will be the cell type classification from
Section \@ref(classification). Other grouping levels (e.g. cluster
assignments from Section \@ref(clustering)) are possible and the user
should adjust depending on the chosen analysis workflow.

### Dimensionality reduction visualization

As seen before, we can visualize single-cells in low-dimensional space.
Often, non-linear methods for dimensionality reduction such as tSNE and
UMAP are sued. They aim to preserve the distances between each cell and its
neighbors in the high-dimensional space.

Interpreting these plots is not trivial, but local neighborhoods in the
plot can suggest similarity in expression for given cells. See
[Orchestrating Single-Cell Analysis with
Bioconductor](https://bioconductor.org/books/release/OSCA/) for more
details.

Here, we will use `dittoDimPlot` from the
[DittoSeq](https://bioconductor.org/packages/release/bioc/html/dittoSeq.html)
package and `plotReducedDim` from the 
[scater](https://bioconductor.org/packages/release/bioc/html/scater.html) package
to visualize the fastMNN-corrected UMAP colored by cell type and
expression, respectively.

Both functions are highly flexible and return `ggplot` objects which can
be further modified.

```{r cell type umap, fig.width=15, fig.height=15, message=FALSE}
library(dittoSeq)
library(scater)
library(patchwork)
library(cowplot)
library(viridis)


## UMAP colored by cell type and expression - dittoDimPlot
p1 <- dittoDimPlot(spe, var = "metacluster", 
             reduction.use = "UMAP", size = 1, labels.size=2,
             do.label = T,
             legend.show=F) +
  scale_color_manual(values = metadata(spe)$color_vectors$col_metacluster) +
  #scale_color_manual(values = col_clusters) + 
  theme(legend.title = element_blank()) +
  ggtitle("Celltype on UMAP")

p2 <- dittoDimPlot(spe, var = "ELAVL4_Yb174_mean", assay = "exprs",
             reduction.use = "UMAP", size = 0.2, 
             colors = viridis(100), do.label = TRUE) +
    scale_color_viridis()
  
p1 + p2
tiff(filename = file.path(path, "results/in_house/20231030/UMAP_metacluster2.tiff"),
     width = 115, height = 95, units = "mm", res=600)
p1
dev.off()

# setEPS()
# postscript(file.path(path, "results/in_house/20231030/UMAP_predicted_celltype_fetahu.eps"), height=3.74, width=4.52)
# p1
# dev.off()
```
```{r cell type umap, fig.width=30, fig.height=15, message=FALSE}

col_tmp <- c(metadata(spe)$color_vectors$col_celltype, setNames("gray90", "background"))
t <- "BM"
spe$celltype_tissue <- spe$celltype
spe[,spe$tissue!=t]$celltype_tissue <- "background"

#to plot background first, we will change the order
spe_tmp <- cbind(spe[,spe$tissue!=t], spe[,spe$tissue==t])
## UMAP colored by cell type and expression - dittoDimPlot
p1 <- dittoDimPlot(spe_tmp, var = "celltype_tissue", 
             reduction.use = "UMAP", size = 1,
             do.label = TRUE,
             legend.show=F) +
  scale_color_manual(values = col_tmp) +
  theme(legend.title = element_blank()) +
  ggtitle(paste0(t, " cell types on UMAP"))

rm(spe_tmp)
p1
```

```{r cell type umap 2, fig.width=8, fig.height= 16, message=FALSE}
# UMAP colored by expression for all markers - plotReducedDim
plot_list  <- lapply(rownames(spe)[rowData(spe)$marker_class == "type"], function(x){
  p <- dittoDimPlot(spe, 
                     var = x, 
                     assay = "exprs",
                     reduction.use = "UMAP",
                     order="increasing",
                     size = 0.2, 
                     colors = viridis(100), 
                     legend.show=F,
                     do.label = TRUE) + scale_color_viridis()

                      return(p)
                    })


plot_grid(plotlist = plot_list, ncol=4, nrow=8)

```

```{r cell type umap 2, fig.width=8, fig.height= 4, message=FALSE}
# UMAP colored by expression for all markers - plotReducedDim
plot_list  <- lapply(rownames(spe)[rowData(spe)$marker_class == "state"], function(x){
  p <- dittoDimPlot(spe, 
                     var = x, 
                     assay = "exprs",
                     reduction.use = "UMAP",
                     order="randomize",
                     size = 0.2, 
                     colors = viridis(100), 
                     legend.show=F,
                     do.label = TRUE) + scale_color_viridis()

                      return(p)
                    })


plot_grid(plotlist = plot_list, ncol=4, nrow=2)

```

### Scatter plot visualization

Moreover, a protein expression based scatter plot can be generated with
`dittoScatterPlot` (returns a `ggplot` object). We overlay the plot with
the cell type information.

```{r celltype scatter, message=FALSE}
#Scatter plot
dittoScatterPlot(spe, 
                 x.var = "CD20_Nd148_mean", y.var="CD8a_Sm154_mean", 
                 assay.x = "exprs", assay.y = "exprs", 
                 color.var = "celltype") +
    scale_color_manual(values = metadata(spe)$color_vector$col_celltype) +
    ggtitle("Scatterplot for CD20/CD3 labelled by celltype")

```

We can nicely observe how the "B next to T cell" phenotype (`BnTcell`)
has high expression values for both CD20 and CD3.

**Of note**, in a setting where the user aims to assign labels to
clusters based on marker genes/proteins, all of the above plots can be
particularly helpful.

### Barplot visualization

In order to display frequencies of cell types per sample/patient, the
`dittoBarPlot` function will be used. Data can be represented as
percentages or counts and again `ggplot` objects are outputted.

```{r barplot celltype, fig.height=15, fig.width=15, message=FALSE}
# by sample_id
#figure out later how to appropriately change order of clusters
#cluster_order <- c(1:7, 79, 8:29, 80, 30:31, 81, 32:37, 82, 38:39, 83, 40:48, 84, 49, 85, 50:54, 86, 55, 87, 56, 88, 57, 89, 58:60, 90, 61:62, 91, 63:67, 92, 68: 71, 93, 72:73, 94, 74:76, 95, 77:78, 96)

dittoBarPlot(spe, var = "celltype", group.by = "sample", #var.labels.reorder=cluster_order, 
             legend.show=T) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype)

# by sample_id -count
dittoBarPlot(spe, var = "celltype", scale = "count", group.by = "sample", retain.factor.levels=T, legend.show=T) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype)

# by patient_id - percentage
dittoBarPlot(spe[,spe$tissue=="PT" & spe$metacluster=="tumor"], var = "celltype", group.by = "MYCN_amp", retain.factor.levels=T) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype)

# by patient_id - count
dittoBarPlot(spe[,spe$control=="no"], scale = "count", var = "celltype", group.by = "study_id", retain.factor.levels=T) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype)

# by timepoint - percentage
dittoBarPlot(spe[,spe$tissue=="BM" & spe$control=="no"], var = "celltype", group.by = "timepoint", retain.factor.levels=T) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype)

# by timepoint - count
dittoBarPlot(spe[,spe$tissue=="BM" & spe$control=="no"], scale = "count", var = "celltype", group.by = "timepoint", retain.factor.levels=T) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype)

# by infiltration - percentage
dittoBarPlot(spe[,spe$tissue=="BM"], var = "metacluster", group.by = "control", retain.factor.levels=T) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_metacluster)

# by infiltration - count
dittoBarPlot(spe[,spe$tissue=="BM"], scale = "count", var = "metacluster", group.by = "control", retain.factor.levels=T) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_metacluster)

# by tissue - percentage
dittoBarPlot(spe[,spe$timepoint=="DE"], var = "celltype", group.by = "tissue", retain.factor.levels=T) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype)

# by tissue - count
dittoBarPlot(spe[,spe$timepoint=="DE"], scale = "count", var = "celltype", group.by = "tissue", retain.factor.levels=T) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype)

```

We can see that cell type frequencies change between samples/patients
and that the highest proportion/counts of plasma cells and stromal
cells can be observed for Patient 2 and Patient 4, respectively.

### CATALYST-based visualization

In the following, we highlight some useful visualization
functions from the
[CATALYST](https://bioconductor.org/packages/release/bioc/html/CATALYST.html)
package.

To this end, we will first convert the `SpatialExperiment` object into a
CATALYST-compatible format.

```{r celltype CATALYST}
library(CATALYST)

# save spe in CATALYST-compatible object with renamed colData entries and 
# new metadata information
spe_cat <- spe 

spe_cat$sample_id <- factor(spe$sample_id)
spe_cat$condition <- factor(spe$tissue)
spe_cat$cluster_id <- factor(spe$celltype)

#add celltype information to metadata
metadata(spe_cat)$cluster_codes <- data.frame(celltype = factor(spe_cat$celltype))
```

All of the `CATALYST` functions presented below return `ggplot` objects,
which allow flexible downstream adjustment.

#### Pseudobulk-level MDS plot

Pseudobulk-level multi-dimensional scaling (MDS) plots can be rendered
with the exported `pbMDS` function.

Here, we will use `pbMDS` to highlight expression similarities between
cell types and subsequently for each celltype-sample-combination.

```{r celltype pbmds, fig.height=15, fig.width=18, message=FALSE}
# MDS pseudobulk by cell type
pbMDS(spe_cat, by = "cluster_id", 
      features = rownames(spe_cat)[rowData(spe_cat)$marker_class == "type"], 
      label_by = "cluster_id", k = "celltype") +
  scale_color_manual(values = metadata(spe_cat)$color_vector$col_celltype)

# MDS pseudobulk by cell type and sample_id
pbMDS(spe_cat, by = "both", 
      features = rownames(spe_cat)[rowData(spe_cat)$marker_class == "type"], 
      k = "celltype", shape_by = "condition", 
      size_by = TRUE) +
  scale_color_manual(values = metadata(spe_cat)$color_vector$col_celltype)
```

We can see that the pseudobulk-expression profile of neutrophils seems
markedly distinct from the other cell types, while comparable cell types
such as the T cell subtypes group together. Furthermore, pseudobulk
cell-type profiles from SCCHN appear different from the other
indications.

#### Reduced dimension plot on CLR of proportions

The `clrDR` function produces dimensionality reduction plots on centered
log-ratios (CLR) of sample/cell type proportions across cell
type/samples.

As with `pbMDS`, the output plots aim to illustrate the degree of
similarity between cell types based on sample proportions.

```{r celltype - clrDR, message=FALSE}
# CLR on cluster proportions across samples
clrDR(spe_cat, dr = "PCA", 
      by = "cluster_id", k = "celltype", 
      label_by = "cluster_id", arrow_col = "study_id", 
      point_pal = metadata(spe_cat)$color_vector$col_celltype) +
  scale_color_manual(values = metadata(spe_cat)$color_vector$study_id)
```

We can again observe that neutrophils have a divergent profile also in
terms of their sample proportions.


## Further examples {#rich-example}

In the last section of this chapter, we will use the popular
[ComplexHeatmap](https://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html)
package to create a visualization example that combines various
cell-type- and sample-level information.

[ComplexHeatmap](https://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html)
is highly versatile and is originally inspired from the
[pheatmap](https://cran.r-project.org/web/packages/pheatmap/index.html)
package. Therefore, many arguments have the same/similar names.

For more details, we would recommend to read the [reference
book](https://jokergoo.github.io/ComplexHeatmap-reference/book/).

### Publication-ready ComplexHeatmap

For this example, we will concatenate heatmaps and annotations
horizontally into one rich heatmap list. The grouping-level for the
visualization will again be the cell type information from Section
\@ref(classification)

Initially, we will create two separate `Heatmap` objects for cell type
and state markers.

Then, metadata information, including the cancer type proportion and
number of cells/patients per cell type, will be extracted into
`HeatmapAnnotation` objects.

Notably, we will add spatial features per cell type, here the number of
neighbors extracted from `colPair(spe)` and cell area, in another
`HeatmapAnnotation` object.

Ultimately, all objects are combined in a `HeatmapList` and visualized.

```{r complex-heatmap, warning = FALSE, message = FALSE, fig.width=9, fig.height=5}
library(ComplexHeatmap)
library(circlize)
library(tidyverse)
set.seed(22)

### 1. Heatmap bodies ###

# Heatmap body color 
col_exprs <- colorRamp2(c(0,1,2,3,4), 
                        c("#440154FF","#3B518BFF","#20938CFF",
                          "#6ACD5AFF","#FDE725FF"))

# Create Heatmap objects
# By celltype markers
celltype_mean <- aggregateAcrossCells(as(spe, "SingleCellExperiment"),  
                     ids = spe$celltype, 
                     statistics = "mean",
                     use.assay.type = "exprs", 
                     subset.row = rownames(spe)[rowData(spe)$marker_class == "type"])

h_type <- Heatmap(t(assay(celltype_mean, "exprs")),
        column_title = "type_markers",
        col = col_exprs,
        name= "mean exprs",
        show_row_names = TRUE, 
        show_column_names = TRUE)
    
# By cellstate markers
cellstate_mean <- aggregateAcrossCells(as(spe, "SingleCellExperiment"),  
                     ids = spe$celltype, 
                     statistics = "mean",
                     use.assay.type = "exprs", 
                     subset.row = rownames(spe)[rowData(spe)$marker_class == "state"])

h_state <- Heatmap(t(assay(cellstate_mean, "exprs")),
        column_title = "state_markers",
        col = col_exprs,
        name= "mean exprs",
        show_row_names = TRUE,
        show_column_names = TRUE)


### 2. Heatmap annotation ###

### 2.1  Metadata features

anno <- colData(celltype_mean) %>% as.data.frame %>% select(celltype, ncells)

# Proportion of indication per celltype
indication <- colData(spe) %>% 
    as.data.frame() %>% 
    select(celltype, indication) %>% 
    group_by(celltype) %>% 
    table() %>% 
    as.data.frame()

indication <- indication %>% 
    group_by(celltype) %>% 
    mutate(fra = Freq/sum(Freq)) 

indication <- indication %>% 
    select(-Freq) %>% 
    pivot_wider(id_cols = celltype, 
                names_from = indication, 
                values_from = fra) %>% 
    column_to_rownames("celltype")

# Number of contributing patients per celltype
cluster_PID <- colData(spe) %>% 
    as.data.frame() %>% 
    select(celltype, patient_id) %>% 
    group_by(celltype) %>% table() %>% 
    as.data.frame()

n_PID <- cluster_PID %>% 
    filter(Freq>0) %>% 
    group_by(celltype) %>% 
    count(name = "n_PID") %>% 
    column_to_rownames("celltype")

# Create HeatmapAnnotation objects
ha_anno <- HeatmapAnnotation(celltype = anno$celltype,
                            border = TRUE, 
                            gap = unit(1,"mm"),
                            col = list(celltype = metadata(spe)$color_vectors$celltype),
                            which = "row")
    
ha_meta <- HeatmapAnnotation(n_cells = anno_barplot(anno$ncells, width = unit(10, "mm")),
                            n_PID = anno_barplot(n_PID, width = unit(10, "mm")),
                            indication = anno_barplot(indication,width = unit(10, "mm"),
                                                      gp = gpar(fill = metadata(spe)$color_vectors$indication)),
                            border = TRUE, 
                            annotation_name_rot = 90,
                            gap = unit(1,"mm"),
                            which = "row")

### 2.2 Spatial features

# Add number of neighbors to spe object (saved in colPair)
n_neighbors <- colPair(spe) %>% 
    as.data.frame() %>% 
    group_by(from) %>% 
    count() %>% 
    arrange(desc(n))

spe$n_neighbors <- n_neighbors$n[match(seq_along(colnames(spe)), n_neighbors$from)]
spe$n_neighbors <- spe$n_neighbors %>% replace_na(0)

# Select spatial features and average over celltypes
spatial <- colData(spe) %>% 
    as.data.frame() %>% 
    select(area, celltype, n_neighbors)

spatial <- spatial %>% 
    select(-celltype) %>% 
    aggregate(by = list(celltype = spatial$celltype), FUN = mean) %>% 
    column_to_rownames("celltype")

# Create HeatmapAnnotation object
ha_spatial <- HeatmapAnnotation(
    area = spatial$area,
    n_neighbors = spatial$n_neighbors,
    border = TRUE,
    gap = unit(1,"mm"),
    which = "row")

### 3. Plot rich heatmap ###

# Create HeatmapList object
h_list <- h_type +
    h_state +
    ha_anno +
    ha_spatial +
    ha_meta

# Add customized legend for anno_barplot()
lgd <- Legend(title = "indication", at = colnames(indication), 
              legend_gp = gpar(fill = metadata(spe)$color_vectors$indication))
             
# Plot
draw(h_list,annotation_legend_list = list(lgd))
```

This plot summarizes most of the information we have seen in this
chapter previously. In addition, we can observe that tumor cells have
the largest mean cell area, high number of neighbors and elevated Ki67
expression. BnT cells have the highest number of neighbors on average,
which is biological sound given their predominant location in highly
immune infiltrated regions (such as TLS).

### Interactive visualization

For interactive visualization of the single-cell data the 
[iSEE](https://www.bioconductor.org/packages/release/bioc/html/iSEE.html) shiny 
application can be used. For a comprehensive tutorial, please refer to the
[iSEE vignette](https://www.bioconductor.org/packages/release/bioc/vignettes/iSEE/inst/doc/basic.html).

```{r iSEE, message=FALSE}
if (interactive()) {
    library(iSEE)

    iSEE(spe)   
}
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>