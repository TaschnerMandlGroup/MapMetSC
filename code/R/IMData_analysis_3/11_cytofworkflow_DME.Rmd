---
title: "Differential analaysis of marker expression"
output: html_document
date: '2023-08-19'
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = "120%")
```

## Load data

First, we will find paired samples. 

```{r selection-paired-sample, message=FALSE}
library(SpatialExperiment)
library(CATALYST)
library(cowplot)
library(ggplot2)
library(diffcyt)
library(flowCore)
library(readxl)
library(scater)
library(dplyr)
library(tidyr)

path <- "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS"

spe <- readRDS(file.path(path,"results/in_house/spe_clustered_4.rds"))

meta_path <- file.path(path, '20230617_metadata_complete.csv')
meta_all = read.csv(meta_path)

samples <- unique(spe[,spe$tissue=="BM" & spe$control=="no" & spe$metacluster=="tumor"]$fm_id)
meta_positive <-meta_all[meta_all$control == 'no'& meta_all$Sample%in%samples,]
meta_pos_reduced <- meta_positive[c("Study_ID", "Tissue", "Timepoint")]
meta_pos_reduced$new <- 1 
meta_pos_reduced_tidy <- meta_pos_reduced %>% pivot_wider(names_from = c("Tissue", "Timepoint"), values_from = "new")
meta_timepoint <- meta_pos_reduced_tidy[, c("Study_ID", "PT_DE", "BM_DE", "BM_RE1", "BM_RE2", "BM_REL")]
meta_timepoint[is.na(meta_timepoint)] <- 0
meta_timepoint <- as.data.frame(meta_timepoint)
rownames(meta_timepoint) <- meta_timepoint$Study_ID
meta_timepoint$Study_ID <- NULL

paired_patients <- rownames(meta_timepoint)[meta_timepoint$BM_DE==1 & meta_timepoint$BM_RE2==1]
```

We will first read in the previously generated `SpatialExperiment` object and transform it into a catalyst compatible object.

```{r read-data-pheno, message=FALSE}
# path <- "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS"
# spe <- readRDS(file.path(path,"results/in_house/spe_clustered.rds"))
#spe <- readRDS(file.path(path,"results/public_datasets/Jansky_Lee/spe_predicted-clusters_Jansky-Lee_2.RDS"))
keep_rows <- rowData(spe)$use_channel
keep_cols <- spe$tissue=="BM" & spe$timepoint=="DE" & spe$metacluster=="tumor"
#spe$metacluster!="LIN- prol." & spe$metacluster!="other" #spe$study_id%in%paired_patients & (spe$timepoint=="DE" | spe$timepoint=="RE1") 
# keep_cols <- spe$tissue=="BM" & spe$control=="no" & spe$celltype!="other" & spe$metacluster!="tumor" & spe$timepoint=="DE" & spe$MYCN_amp!=9

# Define cell_type_markers 
type_markers <- c("MPO_Y89_mean", "CD44_In115_mean", "CD11b_Nd142_mean", "HLA-DR_Nd143_mean", "PRPH_Nd144_mean", "HLA-ABC_Sm147_mean", "CD20_Nd148_mean", "LUM_Sm149_mean", "CD11c_Nd150_mean",
                  "CD24_Eu151_mean", "CD3_Sm152_mean", "CD45_Eu153_mean", "CD8a_Sm154_mean", "GD2_Gd155_mean", "CD34_Gd156_mean", "CD10_Gd158_mean", "CXCR4_Tb159_mean","SOX10_Dy162_mean",
                  "FOXP3_Dy163_mean", "CHGA_Dy164_mean", "GATA3_Er168_mean", "CD56_Er170_mean", "CD4_Yb171_mean", "ELAVL4_Yb174_mean", "CD14_Lu175_mean", "Vimentin_Pt196_mean", "CD15_Bi209_mean")

# Define cell_state_markers 
state_markers <- c("CD274_Gd160_mean", "S100B_Dy161_mean", "CD279_Ho165_mean", "Ki-67_Tm169_mean", "GZMB_Yb173_mean")

# delete when not using mean-80
# type_markers <- paste0(type_markers, "-80")
# state_markers <- paste0(state_markers, "-80")
# keep_rows <- rownames(spe)%in% c(type_markers, state_markers) 
# keep_rows <- tumor_markers

# Add rowData
channel_name <- sapply(strsplit(rownames(rowData(spe)[keep_rows,]), "_"), "[[", 2)
marker_name <- sapply(strsplit(rownames(rowData(spe)[keep_rows,]), "_"), "[[", 1)
marker_class <-ifelse(rownames(spe)[keep_rows] %in% type_markers, "type",
                                    ifelse(rownames(spe)[keep_rows] %in% state_markers, "state", 
                                    "other"))
row_data <- data.frame(cbind(channel_name, marker_name), row.names=marker_name)
row_data$marker_class <- as.factor(marker_class)

counts <- assay(spe, "counts")[keep_rows, keep_cols]
counts <- counts +1 #to avoid having so many zeros
rownames(counts) <- marker_name
sce <- SingleCellExperiment(assays=list(counts=counts, exprs=counts), rowData=row_data)

#add coldata
sce$timepoint <- factor(spe[keep_rows, keep_cols]$timepoint)
sce$control <- factor(spe[keep_rows, keep_cols]$control)
sce$cluster_id <- factor(spe[keep_rows, keep_cols]$metacluster)
sce$patient <- factor(spe[keep_rows, keep_cols]$study_id)
sce$tissue <- factor(spe[keep_rows, keep_cols]$tissue)

sce$mna <- factor(spe[keep_rows, keep_cols]$MYCN_amp)
mna <- as.vector(sce$mna)
mna <- replace(x = mna, list =  mna %in% c(1, 3), values =  'MNA')
mna <- replace(x = mna, list =  mna %in% c(0), values =  'nMNA')
mna <- replace(x = mna, list =  mna %in% c(9), values =  'unknown')
sce$mna <- as.factor(mna)

sce$progress <- factor(spe[keep_rows, keep_cols]$progression)
progress <- as.vector(sce$progress)
progress <- replace(x = progress, list =  progress==0, values =  'NoProg')
progress <- replace(x = progress, list =  progress==1, values =  'Prog')
sce$progress <- as.factor(progress)

sce$condition <- sce$progress

sce$sample_id <- factor(paste0(sce$mna, "_", sce$progress, "_", spe[keep_rows, keep_cols]$study_id, "_", spe[keep_rows, keep_cols]$fm_id, "_", spe[keep_rows, keep_cols]$tissue))

# Add celltype information to metadata
metadata(sce)$cluster_codes <- data.frame(celltype = factor(spe[keep_rows, keep_cols]$metacluster))

# Add metadata
metadata(sce)$experiment_info <- as.data.frame(colData(sce)) %>% group_by(sample_id,patient, mna, condition, progress) %>% 
    summarise(n_cells=n(),.groups = 'drop') %>%
    as.data.frame()

#Add dim reduction
reducedDim(sce, "UMAP") <- reducedDim(spe, "UMAP")[keep_cols,]
```

## Differential analysis of marker expression stratified by cell population

For this part of the analysis, we calculate the median expression of the 14 signaling markers in each cell population (merged cluster) and sample. These will be used as the response variable $Y_{ij}$ in the linear model (LM) or linear mixed model (LMM), for which we assume that the median marker expression follows a Gaussian distribution (on the already arcsinh-transformed scale).
Analogous to the model above, the linear model is formulated as follows:

$$Y_{ij} = \beta_0 + \beta_1 x_{ij} + \epsilon_{ij},$$
where $\epsilon_{ij} \sim N(0, \sigma^2)$, and the mixed model includes a random intercept for each patient:

$$Y_{ij} = \beta_0 + \beta_1 x_{ij} + \gamma_{i} + \epsilon_{ij},$$
where $\gamma_{i} \sim N(0, \sigma^2_\gamma)$.  In the current experiment, we have an intercept (basal level) and a single covariate, $x_{ij}$, which is represented as a binary (stimulated/unstimulated) variable.  For more complicated designs or batch effects, additional columns of a design matrix can be used.

One drawback of summarizing the protein marker intensity with a median over cells is that all the other characteristics of the distribution, such as bimodality, skewness and variance, are ignored. On the other hand, it results in a simple, easy to interpret approach, which in many cases will be able to detect interesting changes. Another issue that arises from using a summary statistic is the level of uncertainty, which increases as the number of cells used to calculate it decreases.  In the statistical modeling, this problem could be partially handled by assigning observation weights (number of cells) to each cluster and sample (parameter `weights` in the `lm` and `lmer` functions used within the `r Biocpkg("diffcyt")` testing functions). However, since each cluster is tested separately, these weights do not account for the differences in size between clusters.

There might be instances of small cell populations for which no cells are observed in some samples or where the number of cells is very low.  For clusters absent from a sample (e.g., due to biological variance or insufficient sampling), NAs are introduced because no median expression can be calculated; in the case of few cells, the median may be quite variable.  Thus, we apply a filter to remove clusters with very low counts (by default, clusters are kept if they have at least 3 cells in at least half the total number of samples, which is appropriate for a two-group comparison with equal numbers of samples per condition).

It is helpful to plot the median expression of all markers in each cluster for each sample colored by condition, to get a rough image of how strong the differences might be (Figure \@ref(fig:diff-expr2-plot-median-expr)).  We do this by combining boxplots and jitter.

```{r diff-expr2-plot-median-expr, fig.height = 8, fig.width=10, fig.cap = "Median (arcsinh-transformed) expression of 14 signaling markers (x-axis) across the 8 identified PBMC cell populations (individual panels). Values for the two conditions are indicated with different colors: red for the unstimulated (Ref) and blue for the stimulated with BCR/FcR-XL (BCRXL) samples. Values for each patient are indicated with different shape. The 8 cell populations are a result of manual merging of the 20 FlowSOM metaclusters.", fig.width=20, fig.height=30}
p <- plotMedExprs(sce, k = "celltype", 
    facet_by = "cluster_id", shape_by = "patient", features = NULL)
p$facet$params$ncol <- 2
p
```
#Diffcyt using list of dataframes
We will test diffcyt according to their [tutorial](https://www.bioconductor.org/packages/devel/bioc/manuals/diffcyt/man/diffcyt.pdf).

```{r prepare-data, message=FALSE}
#Create list of samples as input to diffcyt methods
df_list <- lapply(unique(sce$sample_id), function(x){as.data.frame(t(counts(sce[,sce$sample_id==x])))})
names(df_list) <- unique(sce$sample_id)

#Create experiment info
experiment_info <- metadata(sce)$experiment_info
experiment_info <- experiment_info[match(names(df_list),experiment_info$sample_id),]

#Create marker info
marker_info <-  row_data

#Create summarized experiment - not working propoerly for some reason - cannot be fed to function diffcyt
d_se <- prepareData(df_list, experiment_info, marker_info)
rowData(d_se)$cluster_id <- sce[,rownames(d_se)]$cluster_id #check
metadata(d_se)$cluster_codes <- metadata(sce)$cluster_codes

# Transform data
d_se <- transformData(d_se)

# Calculate counts
d_counts <- calcCounts(d_se)

# Calculate medians
d_medians <- calcMedians(d_se)

# Create design matrix
#design <- createDesignMatrix(experiment_info, cols_design = c("condition", "patient"))
design <- createDesignMatrix(experiment_info, cols_design = "condition")

# Create contrast matrix
contrast <- createContrast(c(0, 1)) # unpaired
#contrast <- createContrast(c(0, 1, rep(0, length(unique(experiment_info$patient))-1))) #paired
nrow(contrast) == ncol(design)

# Test for differential states (DS) within clusters with limma
res_DS_limma <- testDS_limma(d_counts, d_medians, design, contrast, 
                       min_cells=1, 
                       min_samples=1,
                       #trend=F,
                       #weights=F, #whether to use cluster cell counts as precision weights
                       markers_to_test=marker_info$marker_class%in%c("state","type"))

# Test for differential states (DS) within clusters with LMM
res_DS_LMM <- testDS_LMM(d_counts, d_medians, design, contrast, 
                       min_cells=1, 
                       min_samples=1,
                       #trend=F,
                       #weights=F, #whether to use cluster cell counts as precision weights
                       markers_to_test=marker_info$marker_class%in%c("state","type"))


FDR_cutoff = 0.1
rowData(res_DS_limma)[rowData(res_DS_limma)$p_adj<FDR_cutoff,]
result_limma<- data.frame(rowData(res_DS_limma))
result_cluster_limma <- result_limma[result_limma$cluster_id=="monocyte",]
result_LMM<- data.frame(rowData(res_DS_LMM))

# Test for differential states (DS) within clusters (using default method 'diffcyt-DS-limma') - this is generating new clusters - does not work with our sce or d_se object
out_DS <- diffcyt(df_list, experiment_info, marker_info,
design = design, contrast = contrast,min_cells=1, min_samples=1, markers_to_test=marker_info$marker_class%in%c("state","type"),
analysis_type = "DS", method_DS = "diffcyt-DS-limma", transform=F, clustering_to_use = "celltype", 
verbose = FALSE)

result_diffcyt_wrapper <- data.frame(rowData(out_DS$res))
#plotDiffHeatmap(sce, rowData(res_DS), fdr = FDR_cutoff)
```

LMM results in all NA values independent of the parameters set. Limma returns very low FC values, however the lowest p-values per cluster are really assigned to the markers, which visually appear to be most differentially expressed. Applying tranformation before calculating counts and medians does not affect the result. The diffcyt wrapper requires the clustering_to_use to be set, otherwise FlowSOM clustering is performed- however we could not figure out, how to set the clusters when a list has to be fed to diffcyt. 

#Diffcyt using CATALYST SCE object
To present how accounting for the between patient variability with the mixed model increases sensitivity, we also fit a regular linear model.  The linear mixed model has a random intercept for each patient.

```{r ds-formula}
ei <- metadata(sce)$experiment_info
rownames(ei) <- ei$sample_id
contrast <- createContrast(c(0, 1))

ds_formula1 <- createFormula(ei, cols_fixed = "condition")
ds_formula2 <- createFormula(ei, 
    cols_fixed = "condition", cols_random = "patient")

ds_design1 <- createDesignMatrix(ei, cols_design = "condition")

```

Using `r Biocpkg("diffcyt")`, we calculate differential tests using method `diffcyt-DS-LMM`, which implements the DS methodology based on mixed models. This method can be selected by providing the arguments `method = "DS"` and `method_DS = "diffcyt-DS-LMM"` to the `diffcyt()` wrapper function. The remaining arguments are the same as for the DA tests.

By accounting for the patient effect, we detect almost twice as many cases of differential signaling compared to the regular linear model.  

```{r ds-analysis}
ds_res1 <- diffcyt(sce, 
    formula = ds_design1, contrast = contrast, 
    analysis_type = "DS", method_DS = "diffcyt-DS-limma", markers_to_test=rowData(sce)$marker_class%in%c("state","type"),
    clustering_to_use = "celltype", verbose = T, min_cells=1, min_samples=1)
table(rowData(ds_res1$res)$p_adj < FDR_cutoff)
ds_res2 <- diffcyt(sce, 
    formula = ds_formula2, contrast = contrast,
    analysis_type = "DS", method_DS = "diffcyt-DS-LMM",
    clustering_to_use = "celltype", verbose = FALSE)
table(rowData(ds_res2$res)$p_adj < FDR_cutoff)
```

Using diffcyt-DS-LMM we get all NA values. diffcyt-DS-limma returns: Number of rows of contrast matrix must match number of coefficients in fit. 

topTable()` is again used to assemble a summary table.

```{r ds-output}
topTable(ds_res2, top_n = 5, order_by = "cluster_id", 
    show_meds = TRUE, format_vals = TRUE, digits = 3)
```

We use a heatmap to report the differential signals (Figure \@ref(fig:diff-expr2-plot-heatmap-with-significant-markers)).  Instead of plotting the absolute expression, we display the normalized expression, which better highlights the direction of marker changes.  In addition, the cluster-marker combinations are sorted according to adjusted p-value.

```{r diff-expr2-plot-heatmap-with-significant-markers, fig.height = 10, fig.cap = "DS test results and normalized expression of signaling markers in PBMC populations in BCR/FcR-XL stimulated and unstimulated conditions. The heat represents median (arcsinh-transformed) marker expression that was subsequently normalized per cluster-marker combination (rows) to mean of zero and standard deviation of one. The color of the heat varies from blue representing relative under-expression to orange representing relative over-expression. Bars at the top of the heatmap indicate patient IDs and the condition the samples (columns) belong to: red for the unstimulated (Ref) and brown for the stimulated with BCR/FcR-XL (BCRXL) condition. Bar and numbers at the right indicate significant differential cluster-marker combinations (green) and adjusted p-values. Cluster-marker combinations are sorted according to adjusted p-value, so that the cluster-marker combinations at the top show the most significant differential signals between the two conditions. Shown are only the top 50 most highly significant cluster-marker combinations."}
plotDiffHeatmap(sce, rowData(ds_res2$res), top_n = 50, fdr = FDR_cutoff)
```

#EdgeR
Hence, we test for differential expression with edgeR. 

```{r}
library(edgeR)

cluster= "tumor"

#pseudobulk
pseudobulk <- aggregate(t(counts(sce)), list(paste0(sce$sample_id, ".", sce$cluster_id)), median)
pseudobulk_t <- t(pseudobulk[,2:ncol(pseudobulk)])
colnames(pseudobulk_t) <- pseudobulk[,"Group.1"]
pseudobulk_subset <- pseudobulk_t[,grepl(cluster, colnames(pseudobulk_t))]
colnames(pseudobulk_subset) <- sapply(strsplit(colnames(pseudobulk_subset), "[.]"), "[[", 1)
pseudobulk_subset <- unclass(pseudobulk_subset) 
head(pseudobulk_subset)

#Lib size
n_cells <- as.data.frame(colData(sce)) %>% group_by(sample_id,cluster_id) %>% 
    summarise(n_cells=n(),.groups = 'drop') %>%
    as.data.frame()



# Attaching some column metadata.
extra.info <- colData(sce)[match(colnames(pseudobulk_subset), sce$sample_id),]
y.ab <- DGEList(pseudobulk_subset, samples=extra.info, lib.size=n_cells[n_cells$cluster_id==cluster, "n_cells"])
y.ab
```

We filter out lowly expressed genes using the following commands:

```{r}
keep <- filterByExpr(y.ab, group=y.ab$samples$condition, min.count=0.01, min.total.count=0.01)
#y.ab <- y.ab[keep,]
summary(keep)
```

```{r}
#unpaired
design <- model.matrix(~condition, y.ab$samples)
```

The second most important technical influence on differential expression is one that is less
obvious. RNA-seq provides a measure of the relative abundance of each gene in each RNA
sample, but does not provide any measure of the total RNA output on a per-cell basis.
In other words, RNA-seq measure relative expression rather than absolute expression. This
becomes important for differential expression analyses when a small number of genes are very
highly expressed in some samples but not in others. If a small proportion of highly expressed
genes consume a substantial proportion of the total library size for a particular sample, this
will cause the remaining genes to be under-sampled for that sample. Unless this effect is
adjusted for, the remaining genes may falsely appear to be down-regulated in that sample
[39].
The normLibSizes function normalizes the library sizes in such a way to minimize the log-fold
changes between the samples for most genes. The default method for computing these scale
factors uses a trimmed mean of M-values (TMM) between each pair of samples [39]. We
call the product of the original library size and the scaling factor the effective library size,
i.e., the normalized library size. The effective library size replaces the original library size in
all downsteam analyses.
TMM is recommended for most RNA-Seq data where the majority (more than half) of the
genes are believed not differentially expressed between any pair of the samples. If y is a
DGEList object, then the following commands perform the TMM normalization and display
the normalization factors.

```{r}
#y.ab <- calcNormFactors(y.ab) better results without normalization
```

We use the `estimateDisp()` function to estimate the NB (negative binomial) dispersion for each cluster (Figure \@ref(fig:abplotbcv)).
We turn off the trend as we do not have enough points for its stable estimation. 

```{r abplotbcv, fig.cap="Biological coefficient of variation (BCV) for each label with respect to its average abundance. BCVs are defined as the square root of the NB dispersion. Common dispersion estimates are shown in red."}
y.ab <- estimateDisp(y.ab, design)#, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)
```

We repeat this process with the QL dispersion, again disabling the trend (Figure \@ref(fig:abplotql)).

```{r abplotql, fig.cap="QL dispersion estimates for each label with respect to its average abundance. Quarter-root values of the raw estimates are shown in black while the shrunken estimates are shown in red. Shrinkage is performed towards the common dispersion in blue."}
fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
summary(fit.ab$df.prior)
plotQLDisp(fit.ab, cex=1)
```
We test for differences in expression between conditions using `glmQLFTest()`. When there are multiple groups, we can perform the gLmQLFTest according to [this](https://www.biostars.org/p/382480/).

```{r}
res <- glmQLFTest(fit.ab)
summary(decideTests(res))
topTags(res, n=Inf)

```

Next, we will plot these significance values onto a boxplot according to [this](https://www.datanovia.com/en/blog/ggpubr-how-to-add-p-values-generated-elsewhere-to-a-ggplot/).
```{r, fig.width=16, fig.height=18}
library(tidyr)
library(ggpubr)
library(rstatix)
library(gridExtra)
library(gtools)

p <- plotMedExprs(sce, k = "celltype", 
    facet_by = "cluster_id", shape_by = "patient", features = "type")
p$facet$params$ncol <- 2

p$data <- p$data[p$data$cluster_id==cluster & p$data$antigen%in%rownames(res),]
#comparisons <-colnames(contrasts)
#only for one comparison
comparisons <- c("NoProgvsProg")

plot_list_values <- list()
plot_list_stars <- list()
plot_list_fc <- list()
for(i in 1:length(unique(p$data$antigen))){
  cluster_name <- unique(p$data$antigen)[i]
  expressions <- data.frame(p$data[p$data$antigen == cluster_name, c("sample_id", "condition", "value")])
  
  p_adj <- c()
  group1 <- c()
  group2 <- c()
  logFC <- c()
  
  #for(j in 1:ncol(contrasts)){
  for(j in 1:1){
    #stats <- as.data.frame(topTags(res[[j]], n=Inf))
    stats <- as.data.frame(topTags(res, n=Inf))
    p_adj <- c(p_adj, stats[rownames(stats)==droplevels(cluster_name), "FDR"])
    #logFC <- c(logFC, -1*round(stats[rownames(stats)==droplevels(cluster_name), "logFC"],2))
    logFC <- c(logFC, round(stats[rownames(stats)==droplevels(cluster_name), "logFC"],2))
    group1 <- c(group1, unlist(strsplit(comparisons[j], "vs"))[1])
    group2 <- c(group2, unlist(strsplit(comparisons[j], "vs"))[2])
  }
  
  stats_df <- data.frame(p_adj=p_adj, group1=group1, group2=group2, logFC=logFC)
  stats_df$p_adj_signif <- stars.pval(stats_df$p_adj)
  stats_df$p_adj_signif[stats_df$p_adj_signif==" "] <- "ns"
  stats_df$p_fc <- paste0(stats_df$logFC, " (", stats_df$p_adj_signif, ")")
  
  plot_list_values[[i]] <- ggboxplot(expressions, x = "condition", y = "value",
                  color = "condition", palette =c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3"),
                  add = "jitter", title=cluster_name, show.legend = F) +
          stat_pvalue_manual(
            stats_df, 
            y.position = max(expressions$value), 
            step.increase = 0.2,
            label = "p_adj"
            )  + 
          theme(aspect.ratio = 0.8, legend.position="none") +
      scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
  
  plot_list_stars[[i]] <- ggboxplot(expressions, x = "condition", y = "value",
                color = "condition", palette =c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3"),
                add = "jitter", title=cluster_name, show.legend = F) +
        stat_pvalue_manual(
          stats_df, 
          y.position = max(expressions$value), 
          step.increase = 0.2,
          label = "p_adj_signif"
          )  + 
        theme(aspect.ratio = 0.8, legend.position="none") +
      scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
  
  plot_list_fc[[i]] <- ggboxplot(expressions, x = "condition", y = "value",
              color = "condition", palette =c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3"),
              add = "jitter", 
              title=cluster_name, show.legend = F) +
      stat_pvalue_manual(
        stats_df, 
        y.position = max(expressions$value), 
        step.increase = 0.2,
        label = "p_fc"
        )  + 
      theme(aspect.ratio = 2, legend.position="none") +
      scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
}


grid.arrange(grobs = plot_list_values, ncol = 6)
grid.arrange(grobs = plot_list_stars, ncol = 6)
grid.arrange(grobs = plot_list_fc, ncol = 6)
```
#GGboxplot with statistical test - Wilcox

We will then apply a simple statistical test. 

```{r, fig.width=16, fig.height=18}
library(grid)
library(gridExtra)

pseudobulk <- aggregate(t(counts(sce)), list(paste0(sce$sample_id, ".", sce$cluster_id, ".", sce$condition)), mean)
pseudobulk_t <- t(pseudobulk[,2:ncol(pseudobulk)])
colnames(pseudobulk_t) <- pseudobulk[,"Group.1"]

#comparisons <-colnames(contrasts)
#only for one comparison
comparisons <- c("NoProgvsProg")

plot_list <- list()
for (j in 1:length(unique(sce$cluster_id))){
  clust = unique(sce$cluster_id)[j]
  pseudobulk_subset <- pseudobulk_t[,grepl(clust, colnames(pseudobulk_t))]
  sample_id <- sapply(strsplit(colnames(pseudobulk_subset), "[.]"), "[[", 1)
  condition <- sapply(strsplit(colnames(pseudobulk_subset), "[.]"), "[[", 3)
  colnames(pseudobulk_subset) <- sample_id
  
  plot_list_values <- list()
  for(i in 1:nrow(pseudobulk_subset)){
    antigen <- rownames(pseudobulk_subset)[i]
    value <- as.vector(pseudobulk_subset[antigen,])
    expressions <- data.frame(sample_id, condition, value)
    
    
    plot_list_values[[i]] <- ggboxplot(expressions, x = "condition", y = "value",
                    color = "condition", palette =c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3"),
                    add = "jitter", title=antigen, show.legend = F)  + 
            stat_compare_means() + 
            theme(aspect.ratio = 1, legend.position="none") +
        scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
  
  }
  plot_list[[j]] <- grid.arrange(grobs = plot_list_values, ncol = 5, top = textGrob(clust,gp=gpar(fontsize=20,font=3)))
}

```
The problem with Wilcoxon Rank Sum and Signed Rank Tests is that you cannot include blocking factor, i.e. consider batch effects. 

# CytoGLMM

Flow and mass cytometry are important modern immunology tools for measuring expression levels of multiple proteins on single cells. The goal is to better understand the mechanisms of responses on a single cell basis by studying differential expression of proteins. Most current data analysis tools compare expressions across many computationally discovered cell types. Our goal is to focus on just one cell type. Differential analysis of marker expressions can be difficult due to marker correlations and inter-subject heterogeneity, particularly for studies of human immunology. We address these challenges with two multiple regression strategies: A bootstrapped generalized linear model (GLM) and a generalized linear mixed model (GLMM). Here, we illustrate the `CytoGLMM` _R_ package and workflow for simulated mass cytometry data.

```{r glmm_fit}
library(parallel)
library("CytoGLMM")
library("magrittr")
n <- detectCores()

# pseudobulk <- aggregate(t(counts(sce)), list(paste0(sce$sample_id, ".", sce$cluster_id)), mean)
# pseudobulk_t <- t(pseudobulk[,2:ncol(pseudobulk)])
# colnames(pseudobulk_t) <- pseudobulk[,"Group.1"]
# rownames(pseudobulk_t) <- sub("-", "", rownames(pseudobulk_t))
# 
# clust <- "tumor"
# df <- data.frame(t(pseudobulk_t[,grepl(clust, colnames(pseudobulk_t))]))
# df$mna <- as.factor(sapply(strsplit(rownames(df), "[_]"), "[[", 1))
# df$condition <- as.factor(sapply(strsplit(rownames(df), "[_]"), "[[", 2))
# df$patient <- as.factor(sapply(strsplit(rownames(df), "[_]"), "[[", 3))
# df$tissue <- as.factor(sapply(strsplit(rownames(df), "[_]"), "[[", 5))

clust <- "tumor"
sce_subset <- sce[,sce$cluster_id==clust]

df <- as.data.frame(t(counts(sce_subset)))
colnames(df) <- sub("-", "", colnames(df))
proteins <- colnames(df)
df$patient <- sce_subset$patient
df$condition <- sce_subset$condition
df$mna <- sce_subset$mna
df$tissue <- sce_subset$tissue

glmm_fit = CytoGLMM::cytoglmm(df,
                              protein_names = proteins,
                              condition = "condition",
                              group = "patient")
                              #covariate_names = c("mna", "tissue"))
                              #num_cores = 5)
glmm_fit
plot(glmm_fit)
summary(glmm_fit)
```

Unfortunately, CytoGLMM returns non-representative results with the highest differential expression for CD11c. 


