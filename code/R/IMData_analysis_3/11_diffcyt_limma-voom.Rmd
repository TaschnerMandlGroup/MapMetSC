---
title: "Differential abundance testing with limma-voom"
output: html_document
date: '2023-08-19'
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = "120%")
```

## Load data

First, we will find paired samples. 

```{r selection-paired-sample, message=FALSE}
library(SpatialExperiment)
library(CATALYST)
library(cowplot)
library(ggplot2)
library(diffcyt)
library(flowCore)
library(readxl)
library(scater)
library(dplyr)
library(tidyr)

path <- "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS"
spe <- readRDS(file.path(path,"results/in_house/spe_clustered_13.rds"))

clusternames_ordered <- read.csv(file.path(path, "results/in_house/20231030/celltypes_ordered_2.csv"), sep=";", colClasses = c("order" = "character"))
codes <- setNames(paste0(clusternames_ordered$order, "_", clusternames_ordered$celltype), clusternames_ordered$celltype)
spe$celltype_ordered <- recode(spe$celltype, !!!codes)

metadata(spe)$color_vectors$col_celltype_ordered <- metadata(spe)$color_vectors$col_celltype
names(metadata(spe)$color_vectors$col_celltype_ordered) <- recode(names(metadata(spe)$color_vectors$col_celltype), !!!codes)

#spe$celltype_ordered_2 <- spe$celltype_ordered
#spe[,spe$celltype_ordered_2=="30_marker-lo TC2"]$celltype_ordered_2 <- "29_marker-lo TC1"
#spe[,spe$celltype_ordered_2=="31_marker-lo TC3"]$celltype_ordered_2 <- "29_marker-lo TC1"

spe$metacluster_2 <- spe$metacluster
spe[,spe$metacluster_2%in%c("B cell", "granulocyte", "MO/DC/NK", "T cell")]$metacluster_2 <- "immune"
spe[,spe$metacluster_2!="immune"]$metacluster_2 <- "other"
```

## Subset dataset

We will first read in the previously generated `SpatialExperiment` object and transform it into a catalyst compatible object.

```{r read-data-pheno, message=FALSE}
BM_patients_1 <- unique(spe[,spe$tissue=="BM" & spe$control=="no" & spe$metacluster=="tumor" & spe$timepoint == "DE"]$study_id )
BM_patients_2 <- unique(spe[,spe$tissue=="BM" & spe$control=="no" & spe$metacluster=="tumor" & spe$timepoint == "RE1"]$study_id)
BM_patients_3 <- unique(spe[,spe$tissue=="BM" & spe$control=="no" & spe$metacluster=="tumor" & spe$timepoint == "RE2"]$study_id)
PT_patients <- unique(spe[,spe$tissue=="PT"& spe$metacluster=="tumor"]$study_id)
paired_patients <- intersect(BM_patients_1, BM_patients_3)

samples_with_tumor_cells <- unique(spe[,spe$tissue=="BM"& spe$metacluster=="tumor"]$sample_id) #be careful here- use sample_id when looking for samples with and sample when looking for samples without tumor cells

spe$tmp <- "na"
keep_rows <- rowData(spe)$use_channel 
keep_cols <- spe$celltype != "other" & spe$tissue=="BM" & spe$timepoint=="DE" & spe$sample_id%in%samples_with_tumor_cells & spe$metacluster!="tumor" & spe$metacluster!="mesenchymal" #& (spe$MYCN_amp==0 | spe$MYCN_amp==1) # # (spe$timepoint=="DE" | spe$timepoint=="RE2") & spe$study_id%in%paired_patients & spe$sample_id%in%samples_with_tumor_cells 

sce <- SingleCellExperiment(assays=list(counts=assay(spe, "counts")[keep_rows, keep_cols], exprs=assay(spe, "counts")[keep_rows, keep_cols]))

#for combining RE1 and RE2
# sce$timepoint <- factor(spe[keep_rows, keep_cols]$timepoint)
# sce[,sce$timepoint=="RE1"]$timepoint <- "RE2"
# sce$condition <- factor(sce$timepoint)


#sce$condition <- factor(spe[keep_rows, keep_cols]$timepoint)
sce$control <- factor(spe[keep_rows, keep_cols]$control)
sce$cluster_id <- factor(spe[keep_rows, keep_cols]$celltype_ordered)
#sce$cluster_id <- factor(spe[keep_rows, keep_cols]$predicted_clusters)
sce$patient <- factor(spe[keep_rows, keep_cols]$study_id)
sce$tissue <- factor(spe[keep_rows, keep_cols]$tissue)
sce$metacluster <- factor(spe[keep_rows, keep_cols]$metacluster)
sce$tmp <- factor(spe[keep_rows, keep_cols]$tmp)

sce$mna <- factor(spe[keep_rows, keep_cols]$MYCN_amp)
mna <- as.vector(sce$mna)
mna <- replace(x = mna, list =  mna %in% c(1), values =  'MNA')
mna <- replace(x = mna, list =  mna %in% c(3), values =  'het')
mna <- replace(x = mna, list =  mna %in% c(0), values =  'nMNA')
mna <- replace(x = mna, list =  mna %in% c(9), values =  'unknown')
sce$mna <- as.factor(mna)

sce$progress <- factor(spe[keep_rows, keep_cols]$progression)
progress <- as.vector(sce$progress)
progress <- replace(x = progress, list =  progress==0, values =  'NoProg')
progress <- replace(x = progress, list =  progress==1, values =  'Prog')
sce$progress <- as.factor(progress)

sce$timepoint <- spe[keep_rows, keep_cols]$timepoint
#sce[,sce$control=="yes"]$timepoint <- "crtl"
sce$timepoint <- factor(sce$timepoint)
sce$condition <- sce$tmp 

sce$sample_id <- factor(paste0(sce$progress, "_", sce$mna, "_", spe[keep_rows, keep_cols]$study_id, "_", spe[keep_rows, keep_cols]$fm_id, "_", sce$tissue))

#Sorting subset of samples based on specific order from other vector (e.g. clustering performed on entire cohort)
# vec1 <- clustered_samples_all
# vec2<- paste0(unique(spe[keep_rows, keep_cols]$fm_id),"_BM")
# index_in_vec1 <- match(vec2, vec1)
# fm_id <- vec2[order(index_in_vec1)]
# sce$sample_id <- factor(paste0(spe[keep_rows, keep_cols]$fm_id, "_BM"), levels=fm_id)
#sce$sample_id <- factor(paste0(spe[keep_rows, keep_cols]$fm_id, "_", spe[keep_rows, keep_cols]$tissue), levels=clustered_samples)

# Add celltype information to metadata
metadata(sce)$cluster_codes <- data.frame(celltype = factor(spe[keep_rows, keep_cols]$celltype_ordered))

# Add metadata
metadata(sce)$experiment_info <- as.data.frame(colData(sce)) %>% group_by(sample_id,patient, mna, condition, progress) %>% 
    summarise(n_cells=n(),.groups = 'drop') %>%
    as.data.frame()

# Define cell_type_markers 
type_markers <- c("MPO_Y89_mean", "CD44_In115_mean", "CD11b_Nd142_mean", "HLA-DR_Nd143_mean", "PRPH_Nd144_mean", "HLA-ABC_Sm147_mean", "CD20_Nd148_mean", "LUM_Sm149_mean", "CD11c_Nd150_mean",
                  "CD24_Eu151_mean", "CD3_Sm152_mean", "CD45_Eu153_mean", "CD8a_Sm154_mean", "GD2_Gd155_mean", "CD34_Gd156_mean", "CD10_Gd158_mean", "CXCR4_Tb159_mean","SOX10_Dy162_mean",
                  "FOXP3_Dy163_mean", "CHGA_Dy164_mean", "GATA3_Er168_mean", "CD56_Er170_mean", "CD4_Yb171_mean", "ELAVL4_Yb174_mean", "CD14_Lu175_mean", "Vimentin_Pt196_mean", "CD15_Bi209_mean")

# Define cell_state_markers 
state_markers <- c("CD274_Gd160_mean", "S100B_Dy161_mean", "CD279_Ho165_mean", "Ki-67_Tm169_mean", "GZMB_Yb173_mean")

# Add to spe
rowData(sce)$marker_class <- ifelse(rownames(sce) %in% type_markers, "type",
                                    ifelse(rownames(sce) %in% state_markers, "state", 
                                    "other"))

#Add dim reduction

reducedDim(sce, "UMAP") <- reducedDim(spe, "UMAP")[keep_cols,]


# keep <- as.vector(spe_cat[,spe_cat$tissue=="BM" & spe_cat$control=="no" & spe_cat$metacluster=="tumor"]$sample_id)
# sce <- filterSCE(spe_cat, sample_id %in% keep) 
```

## Plot overview of cohort

Differential analysis of cell population abundance compares the proportions of cell types across experimental conditions and aims to highlight populations that are present at different ratios. First, we calculate two tables: one that contains cell counts for each sample and population and one with the corresponding  proportions of cell types by sample.  The proportions are used only for plotting, since the statistical modeling takes the cell counts by cluster and sample as input.

For each sample, we plot its PBMC cell type composition represented with colored bars, where the size of a given stripe reflects the proportion of the corresponding cell type in a given sample (Figure \@ref(fig:diff-freqs-plot-props-barplot)).

```{r diff-freqs-plot-props-barplot, fig.cap = "Relative abundance of the 8 PBMC populations in each sample (x-axis), in the PBMC dataset, represented with a barplot. The 8 cell populations are a result of manual merging of the 20 FlowSOM metaclusters", fig.width=20, fig.height=10}
#sce_ME <- sce[,sce$metacluster!="tumor" & sce$metacluster!="mesenchymal"]
sce_ME <- sce[,sce$metacluster=="tumor"]

set.seed(20231103)
p <- plotAbundances(sce, k = "celltype", by = "sample", col_clust=T, k_pal=metadata(spe)$color_vectors$col_celltype_ordered, 
                    linkage="ward.D", distance="manhattan") 
#Best linkage: ward.D
#Best distance: manhattan

#PCA
#pbMDS(sce, color_by = "condition", label_by = NULL)

#clustered_samples <- sapply(strsplit(levels(p$data$sample_id), "_"), function(x) paste(x[4], x[5], sep = "_"))

clustered_samples <- levels(p$data$sample_id) #when subsetting the dataset

#Dendogram
set.seed(20231103)
wide_df <- p$data %>%
  select(-condition) %>%
  pivot_wider(names_from = cluster_id, values_from = Freq)

wide_df <- data.frame(wide_df)
rownames(wide_df) <- wide_df$sample_id
wide_df <- wide_df %>% select(-sample_id)

dist_matrix <- dist(wide_df, method = "manhattan")
hc <- hclust(dist_matrix, method = "ward.D")

#Extract clusters of cellular communities
cellular_communities <- as.data.frame(cutree(hc, k = 3)[levels(p$data$sample_id)])
colnames(cellular_communities) <- c("community_cluster")
cluster_names <- setNames(order(unique(cellular_communities$community_cluster)), c(1:max(cellular_communities$community_cluster)))
cellular_communities$community_cluster <- recode(cellular_communities$community_cluster, !!!cluster_names)

#for DA between cellular communities
# sce$sample_id <- factor(sce$sample_id, levels=clustered_samples)
# sce$condition <- sce$sample_id
# sample_clusters <- setNames(paste0("c_", cellular_communities$community_cluster), rownames(cellular_communities))
# sce$condition <- as.factor(recode(sce$condition, !!!sample_clusters))
# metadata(sce)$experiment_info <- as.data.frame(colData(sce)) %>% group_by(sample_id,patient, mna, condition, progress) %>% 
#     summarise(n_cells=n(),.groups = 'drop') %>%
#     as.data.frame()

setEPS()
postscript(file.path(path, "results/in_house/20231206/dendogram_PT_DE_samples.eps"), height=12, width=30)
plot(hc)
dev.off()

setEPS()
postscript(file.path(path, "results/in_house/20231206/barplot_BM_DE_samples_metacluster.eps"), height=12, width=20)
p
dev.off()
```

We now want to plot the tumor cells of the clustered microenvironments. 

```{r plot-tumor-compositions, message=FALSE, fig.width=20, fig.height=10}

sce$sample_id <- factor(paste0(spe[keep_rows, keep_cols]$fm_id, "_", spe[keep_rows, keep_cols]$tissue), levels=clustered_samples)
#sce_tumor <- sce[,sce$metacluster=="tumor"]
sce_tumor <- sce[,sce$metacluster!="tumor" & sce$metacluster!="mesenchymal"]
sce_ME <- sce[,sce$metacluster=="tumor"]
tumor_free_samples <- setdiff(levels(sce_tumor$sample_id), unique(sce_tumor$sample_id))

select_random <- function(sce_object, sample){
  cells_of_sample <- grepl(sample, colnames(sce_object))
  random_cell <- sample(colnames(sce_object[,cells_of_sample]),1)
  #cell <- filterSCE(sce_object, colnames(sce_object)%in%c(random_cell))
  cell <- sce_object[,colnames(sce_object)==random_cell]
  cell$cluster_id <- "non-tumor"
  return(cell)
}

random_cells <- sapply(tumor_free_samples, function(x) select_random(sce_ME, x))

if (length(random_cells)>0){
  sce_tumor_free <- do.call(cbind, random_cells)
  
  #Re-define metadata
  
  metadata(sce_tumor_free) <- list(cluster_codes="")
  metadata(sce_tumor_free)$cluster_codes <- data.frame(celltype = factor(sce_tumor_free$cluster_id))
  
  # Add metadata
  metadata(sce_tumor_free)$experiment_info <- as.data.frame(colData(sce_tumor_free)) %>% group_by(sample_id,patient, mna, condition, progress) %>% 
      summarise(n_cells=n(),.groups = 'drop') %>%
      as.data.frame()
  
  sce_tumor <- cbind(sce_tumor, sce_tumor_free)
  sce_tumor$sample_id <- factor(sapply(strsplit(as.vector(sce_tumor$sample_id), "_"), function(x) paste(x[length(x) - 1], x[length(x)], sep = "_")), levels=clustered_samples)
}

p_tu <- plotAbundances(sce_tumor, k = "celltype", by = "sample", col_clust=F, k_pal=metadata(spe)$color_vectors$col_celltype_ordered)

setEPS()
postscript(file.path(path, "results/in_house/20231206/barplot_PT_DE_samples_TU.eps"), height=12, width=20)
p_tu
dev.off()
```

As a next step, we will compute the heterogeneity of samples based on the ME and tumor cell composition.
```{r heterogeneity, message=FALSE, fig.width=7, fig.height=7}
library(BioQC)
library(hrbrthemes)

proportions <- plotAbundances(sce, k = "celltype", by = "sample")
prop <- proportions$data %>%
  select(-condition) %>%
  pivot_wider(names_from = cluster_id, values_from = Freq)

prop <- data.frame(prop)
rownames(prop) <- prop$sample_id
prop <- prop %>% select(-sample_id)

prop <- t(prop)
rownames(prop) <- levels(sce$cluster_id)
me_clusters <- unique(sce[,sce$metacluster!="tumor" & sce$metacluster!="mesenchymal"]$cluster_id)
me_prop <- prop[rownames(prop)%in%me_clusters,]
me_het <- apply(me_prop,2, entropy)
  
tumor_clusters <- unique(sce[,sce$metacluster=="tumor"]$cluster_id)
tumor_prop <- prop[rownames(prop)%in%tumor_clusters,]
tumor_het <- apply(tumor_prop,2, entropy)

# data <- data.frame(cbind(me_het, tumor_het))
# ggplot(data, aes(x=me_het, y=tumor_het)) +
#   geom_point() +
#   geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) #+
#   #theme_ipsum()
# 
# data <- data.frame(cbind(data.frame(table(sce_tumor$sample_id)), tumor_het))
# ggplot(data, aes(x=Freq, y=tumor_het)) +
#   geom_point() +
#   geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)
# 
# test <- spe[,spe$celltype=="GD2+MPO+"]
# MPO <- unname(assay(test["MPO_Y89_mean",],"counts")[1,])
# GD2 <-unname(assay(test["GD2_Gd155_mean",],"counts")[1,])
# data <- data.frame(MPO, GD2)
# ggplot(data, aes(x=MPO, y=GD2)) +
#   geom_point(alpha = 0.3, size=0.5) +
#   geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) 
```


Next, we will plot metadata on top of the clustered barplot. First, we will define the color code for the metadata. Find all built-in R color names [here](https://www.farb-tabelle.de/de/farbtabelle.htm). The [paletteer package](https://r-charts.com/color-palettes/) offers a wide range of color palettes.  

```{r define-color-code, message=FALSE}
library(ComplexHeatmap)
library(RColorBrewer)
library(paletteer)
library(bruceR)
library(circlize)
library(viridis)

meta_path <- file.path(path, '20231128_metadata_complete.csv')

qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector_74 = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

col_vector_433 = colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]

meta_all = read.csv(meta_path)
meta_all <- meta_all[order(meta_all$Study_ID),] #order by study-id

exclude <- replace(x = meta_all$exclude, list =  !meta_all$exclude %in% c('no', 'maybe'), values =  'partially')

#DE_year <- sub("-.*", "", meta_all$DE_date)

col_sample = setNames(sample(col_vector_433, length(unique(meta_all$Sample))), unique(meta_all$Sample))
col_puncture_side = setNames(brewer.pal(length(unique(meta_all$Puncture_side)), 'Set3'), unique(meta_all$Puncture_side))
col_staining_batch = setNames(viridis(length(unique(meta_all$Staining_date))), sort(unique(meta_all$Staining_date)))
col_stainer = setNames(c('#a6611a', '#dfc27d', '#80cdc1', '#018571'), unique(meta_all$Stainer))
col_imc_batch = setNames(viridis(length(unique(meta_all$IMC_date))), sort(unique(meta_all$IMC_date)))
col_imc_score = colorRamp2(c(min(meta_all$IMC_score, na.rm = TRUE), max(meta_all$IMC_score, na.rm = TRUE)/2, max(meta_all$IMC_score, na.rm = TRUE)), viridis(3)) 
col_study_id = setNames(sample(col_vector_433, length(unique(meta_all$Study_ID))), unique(meta_all$Study_ID))
col_DE_year = setNames(viridis(length(unique(meta_all$DE_date))), sort(unique(meta_all$DE_date)))
col_timepoint = setNames(c('#7fc97f', '#beaed4', '#386cb0', '#ffff99', '#386cb0'), unique(meta_all$Timepoint)) #'#fdc086'
col_aberrations = setNames(c('#a6611a','#018571','#80cdc1','#f5f5f5'), c(0,1,2,9))
col_stages = setNames(c('#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c'), unique(meta_all$stage4))
col_efs_dur = colorRamp2(c(min(meta_all$efs_dur, na.rm = TRUE), max(meta_all$efs_dur, na.rm = TRUE)/2, max(meta_all$efs_dur, na.rm = TRUE)), viridis(3))
col_tissue = setNames(c('aquamarine4','brown'), unique(meta_all$Tissue))
col_control = setNames(c('gray77', 'mediumseagreen'), unique(meta_all$control))
col_exclude = setNames(c('#018571','#a6611a','#80cdc1'), unique(exclude))
col_progress = setNames(c('gray77', 'palegreen3', 'firebrick1'), c('n.a.', 0, 1))
#col_age_diag = colorRamp2(c(min(meta_all$age_at_diag, na.rm = TRUE), max(meta_all$age_at_diag, na.rm = TRUE)/2, max(meta_all$age_at_diag, na.rm = TRUE)), viridis(3))
col_age_diag = colorRamp2(c(min(meta_all$age_at_diag, na.rm = TRUE), (quantile(meta_all$age_at_diag, 0.95, na.rm = TRUE)-min(meta_all$age_at_diag, na.rm = TRUE))/2, quantile(meta_all$age_at_diag,0.95, na.rm = TRUE)), viridis(3))
col_therapy = setNames(c('#a6611a', '#018571'), c('RAPID COJEC', 'MOD. N7'))

col_me_het = colorRamp2(c(min(me_het, na.rm = TRUE), (max(me_het, na.rm = TRUE)-min(me_het, na.rm = TRUE))/2, max(me_het, na.rm = TRUE)), viridis(3))
#col_tumor_het = colorRamp2(c(sort(unique(tumor_het))[2], (max(tumor_het, na.rm = TRUE)-sort(unique(tumor_het))[2])/2, max(tumor_het, na.rm = TRUE)), viridis(3))
col_tumor_het = colorRamp2(c(min(tumor_het, na.rm = TRUE), (max(tumor_het, na.rm = TRUE)-min(tumor_het, na.rm = TRUE))/2, max(tumor_het, na.rm = TRUE)), viridis(3))
```

Now, we will plot an overview of the cohort.

```{r overview-cohort, message=FALSE, fig.height=25}

#clustered_samples <- sapply(strsplit(levels(p$data$sample_id), "_"), function(x) paste(x[4], x[5], sep = "_"))
#condition <- "Prog"
#clustered_samples <- sapply(strsplit(levels(droplevels(p$data[p$data$condition==condition,]$sample_id)), "_"), function(x) paste(x[4], x[5], sep = "_"))
#clustered_samples <- levels(p$data$sample_id)

rownames(meta_all) <- paste0(meta_all$Sample, "_", meta_all$Tissue)
meta_all <- meta_all[clustered_samples,]

setEPS()
postscript(file.path(path, "results/in_house/20231206/PT_DE_annotation_bar.eps"), height=30, width=30)

columnAnnotation(control=meta_all$control, col=list(control=col_control)) %v%
columnAnnotation(sample=meta_all$Sample, col=list(sample=col_sample), annotation_legend_param = list(sample = list(grid_height=unit(0.05, "cm"), labels_gp = gpar(fontsize = 5)))) %v%
#columnAnnotation(exclusion=exclude, col=list(exclusion=col_exclude)) %v%
columnAnnotation(imc_score=meta_all$IMC_score, col=list(imc_score=col_imc_score))  %v%
columnAnnotation(staining_batch=meta_all$Staining_date, col=list(staining_batch=col_staining_batch)) %v%
columnAnnotation(stainer=meta_all$Stainer, col=list(stainer=col_stainer)) %v%
columnAnnotation(imc_batch=meta_all$IMC_date, col=list(imc_batch=col_imc_batch)) %v%
columnAnnotation(D_year=meta_all$DE_date, col=list(D_year=col_DE_year))  %v%
columnAnnotation(study_id=meta_all$Study_ID, col=list(study_id=col_study_id))  %v%
columnAnnotation(timepoint=meta_all$Timepoint, col=list(timepoint=col_timepoint))  %v%
columnAnnotation(tissue=meta_all$Tissue, col=list(tissue=col_tissue)) %v%
columnAnnotation(stage=meta_all$stage4, col=list(stage=col_stages)) %v%
columnAnnotation(progression=meta_all$efs, col=list(progression=col_progress))  %v%
columnAnnotation(efs_dur=meta_all$efs_dur, col=list(efs_dur=col_efs_dur)) %v%

columnAnnotation(X1p_loss=meta_all$X1p_loss, col=list(X1p_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X1q_gain=meta_all$X1q_gain, col=list(X1q_gain=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X1q_loss=meta_all$X1q_loss, col=list(X1q_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X2p_gain=meta_all$X2p_gain, col=list(X2p_gain=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X3p_loss=meta_all$X3p_loss, col=list(X3p_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X3q_loss=meta_all$X3q_loss, col=list(X3q_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X4p_loss=meta_all$X4p_loss, col=list(X4p_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X6q_loss=meta_all$X6q_loss, col=list(X6q_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X7q_gain=meta_all$X7q_gain, col=list(X7q_gain=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(PTPRD_del=meta_all$PTPRD_del, col=list(PTPRD_del=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(CDKN2AB_del=meta_all$CDKN2AB_del, col=list(CDKN2AB_del=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X11q_loss=meta_all$X11q_loss, col=list(X11q_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X12q_gain=meta_all$X12q_gain, col=list(X12q_gain=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X14q_loss=meta_all$X14q_loss, col=list(X14q_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X17p_loss=meta_all$X17p_loss, col=list(X17p_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X17q_gain=meta_all$X17q_gain, col=list(X17q_gain=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X19p_loss=meta_all$X19p_loss, col=list(X19p_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X19q_loss=meta_all$X19q_loss, col=list(X19q_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X22q_loss=meta_all$X22q_loss, col=list(X22q_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(CDKN2AB_del=meta_all$CDKN2AB_del, col=list(CDKN2AB_del=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X11q_loss=meta_all$X11q_loss, col=list(X11q_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X12q_gain=meta_all$X12q_gain, col=list(X12q_gain=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(X14q_loss=meta_all$X14q_loss, col=list(X14q_loss=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(MYCN_amp=meta_all$MYCN_amp, col=list(MYCN_amp=col_aberrations)) %v% #annotation_legend_param = list(MYCN_amp = list(title='aberration', 
                                                                                                              #labels = c('no','yes','het'))))  %v%
                                                                                                              #labels = c('no', 'yes', 'het', 'NA'))))  %v%
columnAnnotation(TERT_rear=meta_all$TERT_rear, col=list(TERT_rear=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(ATRX_del=meta_all$ATRX_del, col=list(ATRX_del=col_aberrations), show_legend=FALSE) %v% 
columnAnnotation(ALK_amp=meta_all$ALK_amp, col=list(ALK_amp=col_aberrations), show_legend=FALSE) %v%
columnAnnotation(ALK_mut=meta_all$ALK_mut, col=list(ALK_mut=col_aberrations), show_legend=FALSE) %v%

columnAnnotation(age=meta_all$age_at_diag, col=list(age=col_age_diag)) %v%
columnAnnotation(therapy=meta_all$therapy, col=list(therapy=col_therapy)) %v%
columnAnnotation(ME_het=me_het, col=list(ME_het=col_me_het)) %v%
columnAnnotation(TUM_het=tumor_het, col=list(TUM_het=col_tumor_het))


dev.off()

#absolute cellcount
setEPS()
postscript(file.path(path, paste0("results/in_house/20231206/BM_DE_annotationbar_ncells.eps")), height=30, width=30)
draw(anno_barplot(as.vector(unname(table(sce$sample_id))), add_numbers=T, height = unit(1, "cm")))
dev.off() 

setEPS()
postscript(file.path(path, paste0("results/in_house/20231206/BM_DE_annotationbar_ntumorcells.eps")), height=30, width=30)
draw(anno_barplot(as.vector(unname(table(sce_ME$sample_id))), add_numbers=T, height = unit(1, "cm")))
dev.off() 

#tumor cell proportion
norm_minmax <- function(x){(x- min(x)) /(max(x)-min(x))}

robust_scalar<- function(x){(x- median(x)) /(quantile(x,probs = .75)-quantile(x,probs = .25))}

clipper <- function(data, lower, upper) {
  data[data > quantile(data, probs = c(upper))] <- quantile(data, probs = c(upper))
  data[data < quantile(data, probs = c(lower))] <- quantile(data, probs = c(lower))
  clipped_data <- norm_minmax(data)
  return(clipped_data)}

tumor_infiltration <- round((unname(table(sce_ME$sample_id))/unname(table(sce$sample_id)))*100,3)
tumor_inf_norm <- round(clipper(tumor_infiltration, 0, 0.65),3)
setEPS()
postscript(file.path(path, paste0("results/in_house/20231206/BM_DE_annotationbar_tumor_inf.eps")), height=30, width=30)
draw(anno_barplot(as.vector(tumor_infiltration), add_numbers=T, height = unit(1, "cm")))
dev.off() 

setEPS()
postscript(file.path(path, paste0("results/in_house/20231206/BM_DE_annotationbar_tumor_inf_norm.eps")), height=30, width=30)
draw(anno_barplot(as.vector(tumor_inf_norm), add_numbers=T, height = unit(1, "cm")))
dev.off() 
```

As a last step, we will plot summary plots (boxplots, piecharts) of continuous and discrete metavariables per derived community cluster.
```{r summary_plots-dis, message=FALSE, fig.height=40}
library(gridExtra)

#Add derived community clusters to metadata

#cellular_communities <- cellular_communities[clustered_samples,,drop=F] #when subsetting the dataset

#when testing between other groups than cellular communities
# tmp <- meta_all$Timepoint
# tmp[tmp=="RE1"] <- "RE2"
# cellular_communities$community_cluster <- tmp

rownames(cellular_communities) <- sapply(strsplit(as.vector(rownames(cellular_communities)), "_"), function(x) paste(x[length(x) - 1], x[length(x)], sep = "_"))
meta_all[rownames(cellular_communities),"community_clusters"] <- cellular_communities$community_cluster

discrete_metadata <- c("control", "Tissue", "Timepoint", "X1p_loss", "X1q_gain", "X1q_loss", "X2p_gain", "X3p_loss", "X3q_loss", "X4p_loss",
                       "X6q_loss", "X7q_gain", "PTPRD_del", "CDKN2AB_del", "X11q_loss", "X12q_gain", "X14q_loss", "X17p_loss", "X17q_gain",
                       "X19p_loss", "X19q_loss", "X22q_loss", "MYCN_amp", "TERT_rear", "ATRX_del", "ALK_amp", "ALK_mut", "efs", "therapy")

col_timepoint = setNames(c('#beaed4', '#386cb0', '#386cb0', '#ffff99'), c("DE", "RE1", "RE2", "REL")) 
#col_aberrations = setNames(c('#a6611a','#018571','#80cdc1','#f5f5f5'), c(0,1,3,9))

discrete_metadata_colors <- list(col_control, col_tissue, col_timepoint, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_aberrations, col_progress, col_therapy)

plot_list <- list()
for (d in seq_along(discrete_metadata)) {
  meta <- na.omit(meta_all[,c(discrete_metadata[d], "community_clusters")]) #filter out rows with NA values
  meta <- meta[rowSums(meta == "") == 0, ] # filter out rows with "", e.g. for timepoint in controls
  meta <- meta[rowSums(meta == 9) == 0, ] # filter out rows with "", e.g. for timepoint in controls
  #meta <- meta_all[,c(discrete_metadata[d], "community_clusters")] #%>% replace(is.na(.), "na")
  colnames(meta) <- c("dis_var", "condition")
  
  result <- meta %>%
    group_by(condition, dis_var) %>%
    summarise(Freq = n(), .groups = 'drop')
  
  result[,"dis_var"]<- as.factor(unlist(result[,"dis_var"]))
  
plot_list[[d]] <- ggplot(result, aes(x="", y=Freq, fill=dis_var, group=dis_var)) +
    geom_col(position = "fill") +
    scale_fill_manual(values = discrete_metadata_colors[[d]], name=discrete_metadata[d]) +
    coord_polar("y", start=0)  +  
    facet_grid(.~ condition) +
    theme_void()
}

do.call("grid.arrange", c(plot_list, ncol=1))
```
We will then plot continuous variables in boxplots. 

```{r summary_plots-con, message=FALSE, fig.height=25, fig.width=5}
library("ggpubr")

n_overall <- as.vector(unname(table(sce$sample_id)[clustered_samples]))
n_tumor <- as.vector(unname(table(sce_ME$sample_id)[clustered_samples]))
perc_tumor <- round((as.vector(unname(table(sce_ME$sample_id)[clustered_samples]))/as.vector(unname(table(sce$sample_id)[clustered_samples])))*100,3)
perc_tumor_norm <- round(clipper(perc_tumor, 0, 0.65),3)
het_m <- as.vector(unname(me_het[clustered_samples]))
het_t <- as.vector(unname(tumor_het[clustered_samples]))

age <- meta_all$age_at_diag
age_clipped <- meta_all$age_at_diag
age_clipped[age_clipped > quantile(age_clipped, 0.95, na.rm=T) & !is.na(age_clipped)] <- quantile(age_clipped, 0.95, na.rm=T)

cont_df <- data.frame(cbind(n_overall, n_tumor, perc_tumor, perc_tumor_norm, het_m, het_t, age, age_clipped, cellular_communities),row.names=clustered_samples)

plot_list <- list()
comp <- list( c("1", "2"), c("1", "3"), c("2", "3") )

for (d in colnames(cont_df)[1:ncol(cont_df)-1]) {

  df <- cont_df[,c(d, "community_cluster")] 

plot_list[[d]] <- ggboxplot(df, x = "community_cluster", y = d,
                color = "community_cluster", #palette =c("#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"),
                add = "jitter")+ 
                #stat_compare_means() +
                stat_compare_means(comparisons = comp) +
                theme(aspect.ratio = 1.5, legend.position="none") 
}

do.call("grid.arrange", c(plot_list, ncol=1))
```


## Differential cell population abundance
Since the diffcyt wrapper does not work, we will test the test-functions from the diffcyt package. 

```{r test-diffcyt, message=FALSE}

#Create list of samples as input to diffcyt methods
df_list <- lapply(unique(sce$sample_id), function(x){as.data.frame(t(counts(sce[,sce$sample_id==x])))})
names(df_list) <- unique(sce$sample_id)

#Create experiment info
experiment_info <- metadata(sce)$experiment_info
experiment_info <- experiment_info[match(names(df_list),experiment_info$sample_id),]

#Create marker info
# Add rowData
channel_name <- sapply(strsplit(rownames(rowData(spe)[keep_rows,]), "_"), "[[", 2)
marker_name <- sapply(strsplit(rownames(rowData(spe)[keep_rows,]), "_"), "[[", 1)
marker_class <-ifelse(rownames(spe)[keep_rows] %in% type_markers, "type",
                                    ifelse(rownames(spe)[keep_rows] %in% state_markers, "state", 
                                    "other"))
row_data <- data.frame(cbind(channel_name, marker_name), row.names=marker_name)
row_data$marker_class <- as.factor(marker_class)

marker_info <-  row_data

#Create summarized experiment - not working properly for some reason - cannot be fed to function diffcyt
d_se <- prepareData(df_list, experiment_info, marker_info)
rowData(d_se)$cluster_id <- sce[,rownames(d_se)]$cluster_id 
metadata(d_se)$cluster_codes <- metadata(sce)$cluster_codes

# Transform data
d_se <- transformData(d_se)

# Calculate counts
d_counts <- calcCounts(d_se)
```

```{r test-diffcyt, message=FALSE}
# Create design matrix
#design <- createDesignMatrix(experiment_info, cols_design = c("condition", "patient")) #paired
design <- createDesignMatrix(experiment_info, cols_design = "condition")

# Create contrast matrix
contrast <- createContrast(c(0, 1)) # unpaired
#contrast <- createContrast(c(0, 1, rep(0, length(unique(experiment_info$patient))-1))) #paired
nrow(contrast) == ncol(design)

# Test for differential abundance (DA) of clusters
res_DA <- testDA_voom(d_counts,design, contrast, 
                       min_cells=1, 
                       min_samples=1
                       )


FDR_cutoff = 0.1
rowData(res_DA)[rowData(res_DA)$p_adj<FDR_cutoff,]
res<- data.frame(rowData(res_DA))
```


```{r test-diffcyt-forloop, message=FALSE}
library(edgeR)
#Create design matrix
design <- model.matrix(~0+condition, experiment_info) 

# colnames(design) <- c("DE", "RE2", "REL")
# contrasts <- makeContrasts(#DEvsRE1 = DE-RE1,
#                            DEvsRE2 = DE-RE2,
#                            DEvsREL = DE-REL,
#                            #RE1vsREL = RE1-REL,
#                            RE2vsREL = RE2-REL,
#                            levels = design)

#when comparng between cellular communities
# colnames(design) <- c("c_1", "c_2", "c_3")
# contrasts <- makeContrasts(c_1vsc_2 = c_1-c_2,
#                            c_1vsc_3 = c_1-c_3,
#                            c_2vsc_3 = c_2-c_3,
#                            levels = design)

res <- list()

set.seed(230722)
for (i in 1:ncol(contrasts)){

    res_DA <- testDA_voom(d_counts,design, contrasts[,i], 
                       #min_cells=1, 
                       #min_samples=1
                       )
    
    res <- append(res, list(data.frame(rowData(res_DA))))
}


```

Next, we will plot these significance values onto a boxplot according to [this](https://www.datanovia.com/en/blog/ggpubr-how-to-add-p-values-generated-elsewhere-to-a-ggplot/).
```{r, fig.width=22, fig.height=18}
library(tidyr)
library(ggpubr)
library(rstatix)
library(gridExtra)
library(gtools)

p <- plotAbundances(sce, k = "celltype", by = "cluster_id", shape_by = "sample_id")


comparisons <-colnames(contrasts)
#only for one comparison
#comparisons <- c("novsyes")

plot_list_values <- list()
plot_list_stars <- list()
plot_list_fc <- list()
for(i in 1:length(unique(p$data$cluster_id))){
  cluster_name <- unique(p$data$cluster_id)[i]
  proportions <- data.frame(p$data[p$data$cluster_id == cluster_name, c("sample_id", "condition", "Freq")])
  
  p_adj <- c()
  group1 <- c()
  group2 <- c()
  logFC <- c()
  
  for(j in 1:ncol(contrasts)){
  #for(j in 1:1){
  stats <- res[[j]]
  #stats <- res
  p_adj <- c(p_adj, round(stats[rownames(stats)==droplevels(cluster_name), "p_adj"],3))
  logFC <- c(logFC, -1*round(stats[rownames(stats)==droplevels(cluster_name), "logFC"],2))
  #logFC <- c(logFC, round(stats[rownames(stats)==droplevels(cluster_name), "logFC"],2))
  group1 <- c(group1, unlist(strsplit(comparisons[j], "vs"))[1])
  group2 <- c(group2, unlist(strsplit(comparisons[j], "vs"))[2])
  }

  stats_df <- data.frame(p_adj=p_adj, group1=group1, group2=group2, logFC=logFC)
  stats_df$p_adj_signif <- stars.pval(stats_df$p_adj)
  stats_df$p_adj_signif[stats_df$p_adj_signif==" "] <- "ns"
  stats_df$p_fc <- paste0(stats_df$logFC, " (", stats_df$p_adj, ")", " (", stats_df$p_adj_signif, ")")
  
  plot_list_fc[[i]] <- ggboxplot(proportions, x = "condition", y = "Freq", #order=c("c_1", "c_2", "c_3"),
              color = "condition", palette =c("gray","#e41a1c", "#377eb8", "#4daf4a", "#984ea3"),
              add = "jitter", title=cluster_name, show.legend = F) +
      stat_pvalue_manual(
        stats_df,
        y.position = max(proportions$Freq),
        step.increase = 0.4,
        label = "p_fc"
        )  +
      theme(aspect.ratio = 1.5, legend.position="none") +
      scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
  
  # plot_list_fc[[i]] <- ggpaired(proportions, x = "condition", y = "Freq",
  #             fill = "condition", palette =c("jco"),
  #             add = "jitter", title=cluster_name, show.legend = F) +
  #     # stat_pvalue_manual(
  #     #   stats_df,
  #     #   y.position = max(proportions$Freq),
  #     #   step.increase = 0.4,
  #     #   label = "p_fc"
  #     #   )  +
  #     theme(aspect.ratio = 2, legend.position="none") +
  #     scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
}
pdf(file = "/mnt/Multimodal_Imaging_Daria/PIPELINE/NEWEST_RESULTS/results/poster/DA_paired.pdf",   
    width = 15, # The width of the plot in inches
    height = 10)
grid.arrange(grobs = plot_list_fc, ncol = 6)
dev.off()

setEPS()
postscript(file.path(path, "results/in_house/20231206/PTvsBM_tumor_boxplot_paired.eps"), height=26, width=20)
grid.arrange(grobs = plot_list_fc, ncol = 6)
   dev.off()
```
Here we plot boxplots connecting paired samples and coloring the dynamics associated with progression in black. 

```{r, fig.width=14, fig.height=16}
p <- plotAbundances(sce, k = "celltype", by = "cluster_id", shape_by = "sample_id")
plot_list <- list()

#for(i in 1:length(unique(p$data$cluster_id))){
  #cluster_name <- unique(p$data$cluster_id)[i]
  cluster_name <- "30_marker-lo TC2"
  proportions <- data.frame(p$data[p$data$cluster_id == cluster_name, c("sample_id", "condition", "Freq")])
  
  proportions$progress <- sapply(strsplit(as.vector(proportions$sample_id), "_"), function(x) x[2])
  proportions$sample_id <- sapply(strsplit(as.vector(proportions$sample_id), "_"), function(x) x[3])
  
  
  # Reshape data from long to wide format
  data_wide <- proportions %>%
    pivot_wider(
      names_from = condition,
      values_from = Freq,
      #values_fill = list(Freq = 120)  # This fills missing values with 120
    )
  
  data <- as.data.frame(data_wide)
  
  data_long <- data_wide %>%
    pivot_longer(
      cols = -c(sample_id, progress),  # Exclude the sample_id column from pivoting
      names_to = "condition",
      values_to = "Freq"
    )
  
  
  # ggpaired(data, cond1 = "DE", cond2 = "RE2",
  #     fill = "condition", palette = "jco")
  
  # setEPS()
  # postscript(file.path(path, "results/in_house/20231030/ggpaired-test.eps"), height=6, width=20)
  # 
  # ggpaired(data_long, x = "condition", y = "Freq",
  #               line.color = "gray", color="condition",
  #               add = "jitter", line.size=0.4,
  #               title=cluster_name, show.legend = F) +
  #               theme(aspect.ratio = 2, legend.position="none") +
  #               scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) +
  #   geom_line(data_long = ~subset(., ID %in% c("A", "B")), aes(group = id), color = "red") +
  #   theme(plot.title = element_text(colour = "Black", size = 14, face = "bold.italic"))
  # 
  # dev.off()
  

    plot_list[[i]] <- ggplot(data_long, aes(x = condition, y = Freq)) +
      ggtitle(cluster_name) +
      geom_boxplot(aes(fill = condition), alpha = 0.2, col = "grey") +
      geom_point(aes(col = condition)) +
      geom_line(aes(group = sample_id), color="gray") +
      geom_line(data = ~subset(., progress %in% c("Prog")),aes(group = sample_id), color="black") +
    theme(aspect.ratio=1.5, plot.title = element_text(colour = "Black", size = 14, face = "bold.italic"))
#}

setEPS()
postscript(file.path(path, "results/in_house/20231030/BM_timepoint_ggpaired.eps"), height=14, width=9)
grid.arrange(grobs = plot_list, ncol = 3)
dev.off()
```

Here we plot the abundances of celltypes however, we divide by the number of samples per group so that the result is not driven by outliers. 

```{r}
p <- plotAbundances(sce, k = "celltype", by = "cluster_id", shape_by = "sample_id")

df_normalized <- p$data %>%
  group_by(cluster_id, condition) %>%
  summarise(normalized_count = mean(Freq, na.rm = TRUE)) %>%
  ungroup()


df_normalized$cluster_id <- factor(df_normalized$cluster_id)
#df_normalized$cluster_id <- factor(df_normalized$cluster_id, levels=c("GD2lo TC", "CHGAhi TC", "GATA3hi TC", "marker-hi TC", "marker-lo TC2", "marker-lo TC3", "Ki67hi TC", "CXCR4hi TC", "marker-lo TC1", "CD44+ marker-hi TC"))
# Stacked + percent
setEPS()
postscript(file.path(path, "results/in_house/20231030/PT_MNAvsnMNA_dodge.eps"), height=4, width=8)


ggplot(df_normalized, aes(fill=cluster_id, y=normalized_count, x=condition)) + 
  #ggtitle(paste0("celltype per ", groupname)) +
  geom_bar(
    #position="fill", 
    #position="stack",
    stat="identity",
    position="dodge",
    show.legend = T) + 
  scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype_ordered) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

dev.off()

#Piechart
setEPS()
postscript(file.path(path, "results/in_house/20231030/BM_timepoint_piechart.eps"), height=2, width=6.5)

ggplot(df_normalized, aes(x="", y=normalized_count, fill=cluster_id, group=cluster_id)) +
  geom_bar(stat="identity", width=1, color="white") +
  scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype_ordered) +
  coord_polar("y", start=0)  +  
  facet_grid(.~ condition) +
  theme_void()
dev.off()

#one pie chart inside the other
# ggplot(df_normalized, aes(x=condition, y=normalized_count, fill=cluster_id)) +
#   geom_bar(stat="identity", width=1, color="white") +
#   scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype) +
#   coord_polar("y", start=0) 
#   theme_void()
```

