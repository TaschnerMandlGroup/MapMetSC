---
title: "Cell classification"
output: html_document
date: '2022-08-14'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load data

We will first read in the previously generated `SpatialExperiment` object and
sample 2000 cells to visualize cluster membership.

```{r read-data-pheno, message=FALSE}
library(SpatialExperiment)
spe <- readRDS("data/spe.rds")

# Sample cells
set.seed(220619)
cur_cells <- sample(seq_len(ncol(spe)), 2000)
```

## Cell type classification {#classification}

In this section, we will highlight a cell type classification approach based
on ground truth labeling and random forest classification. The rational for
this supervised cell phenotyping approach is to use the information contained
in the pre-defined markers to detect cells of interest. This approach was
used by Hoch _et al._ to classify cell types in a metastatic melanoma IMC
dataset [@Hoch2022].

The antibody panel used in the example data set mainly focuses on immune cell
types and little on tumor cell phenotypes. Therefore we will label the following
cell types:

* Tumor (GD2 positive)
* CD8+ T cells (CD3, CD8 positive)
* CD4+ T cells (CD3, CD4 positive)
* Plasma cells (CD38 positive)
* Immature Neutrophil (CD24, CD10 positive)
* Myeloid cells (HLA-DR, CD14 positive)
* B cells (CD20 positive)

As related approaches, [Astir](https://github.com/camlab-bioml/astir) and
[Garnett](https://cole-trapnell-lab.github.io/garnett/) use pre-defined panel
information to classify cell phenotypes based on their marker expression.

### Manual labeling of cells

The [cytomapper](https://www.bioconductor.org/packages/release/bioc/html/cytomapper.html)
package provides the `cytomapperShiny` function that allows gating of cells
based on their marker expression and visualization of selected cells directly
on the images. 

```{r cytomapperShiny, message=FALSE}
library(cytomapper)
if (interactive()) {
    
    images <- readRDS("data/images.rds")
    masks <- readRDS("data/masks.rds")
    
    cytomapperShiny(object = spe, mask = masks, image = images, 
                    cell_id = "ObjectNumber", img_id = "sample_id")
}
```

Per image, the `cytomapperShiny`
function allows the export of gated cells in form of a `SingleCellExperiment` or
`SpatialExperiment` object. The cell label is stored in
`colData(object)$cytomapper_CellLabel` and the gates are stored in
`metadata(object)`. In the next section, we will read in and consolidate the
labeled data.

### Define color vectors

For consistent visualization of cell types, we will no pre-define their colors:

```{r cell-type-colors}
celltype <- setNames(c("#3F1B03", "#F4AD31", "#894F36", "#1C750C", "#EF8ECC", 
                       "#6471E2", "#4DB23B", "grey", "#F4800C", "#BF0A3D", "#066970"),
                     c("Tumor", "Stroma", "Myeloid", "CD8", "Plasma_cell", 
                       "Treg", "CD4", "undefined", "BnTcell", "Bcell", "Neutrophil"))

metadata(spe)$color_vectors$celltype <- celltype
```

### Read in and consolidate labeled data

Here, we will read in the individual `SpatialExperiment` objects containing the
labeled cells and concatenate them. In the process of concatenating the 
`SpatialExperiment` objects along their columns, the `sample_id` entry is 
appended by `.1, .2, .3, ...` due to replicated entries. 

```{r, read-in-labeled-data, message=FALSE}
library(SingleCellExperiment)
label_files <- list.files("data/gated_cells", 
                          full.names = TRUE, pattern = ".rds$")

# Read in SPE objects
spes <- lapply(label_files, readRDS)

# Merge SPE objects
concat_spe <- do.call("cbind", spes)
```

In the following code chunk we will identify cells that were labeled multiple
times. This occurs when different cell phenotypes are gated per image and can
affect immune cells that are located inside the tumor compartment.

We will first identify those cells that were uniquely labeled. In the next step,
we will identify those cells that were labeled twice AND were labeled as Tumor
cells. These cells will be assigned their immune cell label. Finally, we will
save the unique labels within the original `SpatialExperiment` object.

```{r, consolidate-labels}
cur_tab <- unclass(table(colnames(concat_spe), 
                         concat_spe$cytomapper_CellLabel))
cur_labels <- rep("doublets", nrow(cur_tab))
names(cur_labels) <- rownames(cur_tab)

# Single assignments
single_index <- rowSums(cur_tab) == 1
cur_labels[single_index] <- colnames(cur_tab)[apply(cur_tab[single_index,], 1, 
                                                    which.max)]

# Double assignment within the tumor
double_index <- rowSums(cur_tab) == 2 & cur_tab[,"Tumor"] == 1
no_tumor <- cur_tab[,colnames(cur_tab) != "Tumor"]
cur_labels[double_index] <- colnames(no_tumor)[apply(no_tumor[double_index,], 1, 
                                                    which.max)]

# Remove doublets
cur_labels <- cur_labels[cur_labels != "doublets"]
table(cur_labels)

# Transfer labels to SPE object
spe_labels <- rep("unlabeled", ncol(spe))
names(spe_labels) <- colnames(spe)
spe_labels[names(cur_labels)] <- cur_labels
spe$cell_labels <- spe_labels

# Number of cells labeled per patient
table(spe$cell_labels, spe$patient_id)
```

Based on these labels, we can now train a random forest classifier to classify
all remaining, unlabeled cells.

### Train classifier

In this section, we will use the
[caret](https://topepo.github.io/caret/index.html) framework for machine
learning in R. This package provides an interface to train a number of
regression and classification models in a coherent fashion. We use a random
forest classifier due to low number of parameters, high speed and an observed
high performance for cell type classification [@Hoch2022].

In the following section, we will first split the `SpatialExperiment` object
into labeled and unlabeled cells. Based on the labeled cells, we split
the data into a train (75% of the data) and test (25% of the data) dataset. 
We currently do not provide an independently labeled validation dataset.

The `caret` package provides the `trainControl` function, which specifies model
training parameters and the `train` function, which performs the actual model
training. While training the model, we also want to estimate the best model
parameters. In the case of the chosen random forest model (`method = "rf"`), we
only need to estimate a single parameters (`mtry`) which corresponds to the
number of variables randomly sampled as candidates at each split. To estimate
the best parameter, we will perform a 5-fold cross validation (set within
`trainControl`) over a tune length of 5 entries to `mtry`.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r train-classifier, message=FALSE}
library(caret)

# Split between labeled and unlabeled cells
lab_spe <- spe[,spe$cell_labels != "unlabeled"]
unlab_spe <- spe[,spe$cell_labels == "unlabeled"]

# Randomly split into train and test data
set.seed(220510)
trainIndex <- createDataPartition(factor(lab_spe$cell_labels), p = 0.75)
train_spe <- lab_spe[,trainIndex$Resample1]
test_spe <- lab_spe[,-trainIndex$Resample1]

# Specify train parameters for 5-fold cross validation
fitControl <- trainControl(method = "cv",
                           number = 5)

# Select the data for training
cur_mat <- t(assay(train_spe, "exprs")[rowData(train_spe)$use_channel,])

# Train a random forest model for predicting cell labels
# This call also performs parameter tuning
set.seed(220510)
rffit <- train(x = cur_mat, 
               y = factor(train_spe$cell_labels),
               method = "rf", ntree = 1000,
               tuneLength = 5,
               trControl = fitControl)

rffit
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

Training the classifier took 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

### Classifier performance

We next observe the accuracy of the classifer when predicting cell 
phenotypes across the cross-validation as well as the test dataset.

First, we can visualize the classification accuracy during parameter
tuning:

```{r accuracy-tuning}
ggplot(rffit) + 
  geom_errorbar(data = rffit$results,
                aes(ymin = Accuracy - AccuracySD,
                    ymax = Accuracy + AccuracySD),
                width = 0.4) +
    theme_classic(base_size = 15)
```

The best value for `mtry` is 28 and is used when predicting new data.

It is often recommended to visualize the variable importance of the
classifier. The following plot specifies which variables (markers) are 
most important for classifying the data.

```{r variable-importance, fig.height = 10}
plot(varImp(rffit))
```

As expected, the markers that were used for gating (Ecad, CD3, CD20, HLADR,
CD8a, CD38, FOXP3) were important for classification.

To assess the accuracy, sensitivity, specificity, among other quality measures of
the classifier, we will now predict cell phenotypes in the test data.

```{r model-testing, message=FALSE}
# Select test data
cur_mat <- t(assay(test_spe, "exprs")[rowData(test_spe)$use_channel,])

# Predict cell phenotypes in test data
cur_pred <- predict(rffit, 
                    newdata = cur_mat)
```

While the overall classification accuracy can appear high, we also want
to check if each cell phenotype class is correctly predicted.
For this, we will calculate the confusion matrix between predicted and actual 
cell labels. This measure highlights individual cell phenotype classes that 
were not correctly predicted by the classifier. When setting `mode = "everything"`,
the `confusionMatrix` function returns all available prediction measures including
sensitivity, specificity, precision, recall and the F1 score per cell 
phenotype class.

```{r confusion-matrix}
cm <- confusionMatrix(data = cur_pred, 
                      reference = factor(test_spe$cell_labels), 
                      mode = "everything")

cm
```

To easily visualize these results, we can now plot the true positive rate (sensitivity)
versus the false positive rate (1 - specificity):

```{r specificity-sensitivity, message=FALSE}
library(tidyverse)

data.frame(cm$byClass) %>%
  mutate(class = sub("Class: ", "", rownames(cm$byClass))) %>%
  ggplot() + 
  geom_point(aes(1 - Specificity, Sensitivity, 
                 size = Detection.Rate,
                 fill = class),
             shape = 21) + 
  scale_fill_manual(values = metadata(spe)$color_vectors$celltype) +
  theme_classic(base_size = 15) + 
  ylab("Sensitivity (TPR)") +
  xlab("1 - Specificity (FPR)")
```

We observe high sensitivity and specificity for most cell types. Plasma cells
show the lowest true positive rate with 88% being sufficiently high. The size of
the circle specifies the number of cells per class.

Finally, to observe which cell phenotypes were wrongly classified, we can visualize
the distribution of classification probabilities per cell phenotype class:

```{r prediciton-probability, fig.height=15}
cur_pred <- predict(rffit, 
                    newdata = cur_mat, 
                    type = "prob")
cur_pred$truth <- factor(test_spe$cell_labels)

cur_pred %>%
  pivot_longer(cols = Bcell:Tumor) %>%
  ggplot() +
  geom_boxplot(aes(x = name, y = value, fill = name), outlier.size = 0.5) +
  facet_wrap(. ~ truth, ncol = 1) + 
  scale_fill_manual(values = metadata(spe)$color_vectors$celltype)  +
  theme(panel.background = element_blank(), 
        axis.text.x = element_text(angle = 45, hjust = 1))
```

The boxplots indicate the classification probabilities per class. The classifier
is well trained if classification probabilities are only high for the one 
specific class.

### Classification of new data

In the final section, we will now use the tuned and tested random forest 
classifier to predict the cell phenotypes of the unlabeled data.

First, we predict the cell phenotypes and extract their classification
probabilities.

```{r, unlabeled-prediction}
# Select unlabeled data
cur_mat <- t(assay(unlab_spe, "exprs")[rowData(unlab_spe)$use_channel,])

# Predict cell phenotypes
cell_class <- as.character(predict.train(rffit, 
                                         newdata = cur_mat, 
                                         type = "raw"))
names(cell_class) <- rownames(cur_mat)

# Extract classification probabilities
cell_prob <- predict.train(rffit, 
                           newdata = cur_mat, 
                           type = "prob")
```

Each cell is assigned to the class with highest probability. There are however
cases, where the highest probability is low meaning the cell can not be uniquely
assigned to a class. We next want to identify these cells and label them as 
"undefined". Here, we select a maximum classification probability threshold 
of 40% but this threshold needs to be adjusted for other datasets. The adjusted
cell labels are then stored in the `SpatialExperiment` object.

```{r, undefined-cells}
library(ggridges)

# Distribution of maximum probabilities
tibble(max_prob = rowMax(as.matrix(cell_prob)),
       type = cell_class) %>%
    ggplot() +
        geom_density_ridges(aes(x = max_prob, y = cell_class, fill = cell_class)) +
        scale_fill_manual(values = metadata(spe)$color_vectors$celltype) +
        theme_classic(base_size = 15) +
        xlab("Maximum probability") +
        ylab("Cell type") + 
        xlim(c(0,1.2))

# Label undefined cells
cell_class[rowMax(as.matrix(cell_prob)) < 0.4] <- "undefined"

# Store labels in SpatialExperiment onject
cell_labels <- spe$cell_labels
cell_labels[colnames(unlab_spe)] <- cell_class
spe$celltype <- cell_labels 

table(spe$celltype, spe$patient_id)
```

We can now compare the cell labels derived by classification to the different
clustering strategies. The first comparison is against the clustering results
using the asinh-transformed counts.

```{r compare-raw, message=FALSE}
tab1 <- table(spe$celltype, 
              paste("Rphenograph", spe$pg_clusters))
tab2 <- table(spe$celltype, 
              paste("SNN", spe$nn_clusters))
tab3 <- table(spe$celltype, 
              paste("SOM", spe$som_clusters))

pheatmap(log10(tab1 + 10), color = viridis(100))
pheatmap(log10(tab2 + 10), color = viridis(100))
pheatmap(log10(tab3 + 10), color = viridis(100))
```

We can see that Tumor and Myeloid cells span multiple clusters while
Neutrophiles are detected as an individual cluster by all clustering approaches.

We next compare the cell classification against clustering results using the 
integrated cells.

```{r compare-corrected, message=FALSE}
tab1 <- table(spe$celltype, 
              paste("Rphenograph", spe$pg_clusters_corrected))
tab2 <- table(spe$celltype, 
              paste("SNN", spe$nn_clusters_corrected))
tab3 <- table(spe$celltype, 
              paste("SOM", spe$som_clusters_corrected))

pheatmap(log10(tab1 + 10), color = viridis(100))
pheatmap(log10(tab2 + 10), color = viridis(100))
pheatmap(log10(tab3 + 10), color = viridis(100))
```

We observe a high agreement between the shared nearest neighbor clustering
approach using the integrated cells and the cell phenotypes derived by
classification.

In the next sections, we will highlight visualization strategies to verify the
correctness of the phenotyping approach. Specifically, Section
\@ref(outline-cells) shows how to outline identified cell phenotypes on
composite images.

```{r display-images, echo=FALSE, message = FALSE, results='hide'}
# This section serves quality control purposes.
library(testthat)
test_that("images are written out", {
    skip_on_ci()
    expect_true(TRUE)
    cell_types <- unique(spe$celltype)

    markers <- vector(mode = "list", length = length(cell_types))
    names(markers) <- cell_types

    markers[["Bcell"]] <- c("CD20", "CD3")
    markers[["Plasma_cell"]] <- c("CD38")
    markers[["CD4"]] <- c("CD4", "CD8a", "FOXP3")
    markers[["BnTcell"]] <- c("CD20","CD3")
    markers[["CD8"]] <- c("CD4", "CD8a", "FOXP3")
    markers[["Treg"]] <- c("CD4", "CD8a", "FOXP3")
    markers[["Myeloid"]] <- c("CD11c", "CD68", "HLADR", "CD163")
    markers[["Neutrophil"]] <- c("CD15", "MPO")
    markers[["Stroma"]] <- c("SMA", "PDGFRb")
    markers[["Tumor"]] <- c("Ecad")
    markers[["undefined"]] <- c("Ecad", "CD3", "CD20", "MPO", "CD38")
    
    images <- readRDS("data/images.rds")
    masks <- readRDS("data/masks.rds")
    
    images <- cytomapper::normalize(images, separateImages = TRUE)
    images <- cytomapper::normalize(images, separateImages = TRUE, 
                        inputRange = c(0, 0.2))
    
    if (!dir.exists("data/CellTypeValidation")) {
        dir.create("data/CellTypeValidation")
    }
    
    for(j in unique(spe$celltype)){
        cur_sce <- spe[,spe$celltype == j]
        cur_markers <- markers[[j]]
  
        if(dim(cur_sce)[2] == 0) {
            next(j)
        }
    
        if (length(cur_markers) == 1) {
            cur_col <- "red"
            names(cur_col) <- j
            cur_col <- list(cur_col)
            names(cur_col) <- "celltype"
            plotPixels(image = images, 
                object = cur_sce, 
                mask = masks, 
                cell_id = "ObjectNumber",
                img_id = "sample_id", 
                colour_by = cur_markers, 
                outline_by = "celltype",
                image_title = list(text = names(images),
                                cex = 1), 
                colour = cur_col,
                save_plot = list(filename = paste0("data/CellTypeValidation/",
                            j, ".png")))
        } else {
            plotPixels(image = images,
                   object = cur_sce, 
                   mask = masks, 
                   cell_id = "ObjectNumber",
                   img_id = "sample_id", 
                   colour_by = cur_markers, 
                   outline_by = "celltype",
                   image_title = list(text = names(images),
                                  cex = 1),
                   save_plot = list(filename = paste0("data/CellTypeValidation/",
                            j, ".png")))
        }
    }
    expect_true(TRUE)
    
})
```

Finally, we save the updated `SpatialExperiment` object.

```{r phenotyping-save-object}
saveRDS(spe, "data/spe.rds")
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>
