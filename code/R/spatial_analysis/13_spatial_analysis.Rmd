# Performing spatial analysis

Highly multiplexed imaging technologies measure the spatial distributions of
molecule abundances across tissue sections. As such, having the option to
analyze single cells in their spatial tissue context is a key strength of these
technologies.

A number of software packages such as
[squidpy](https://squidpy.readthedocs.io/en/stable/),
[giotto](https://giottosuite.readthedocs.io/en/master/) and
[Seurat](https://satijalab.org/seurat/articles/spatial_vignette_2.html) have
been developed to analyse and visualize cells in their spatial context. The
following chapter will highlight the use of
[imcRtools](https://bioconductor.org/packages/release/bioc/html/imcRtools.html)
and other Bioconductor packages to visualize and analyse single-cell data
obtained from highly multiplexed imaging technologies.

We will first read in the spatially-annotated single-cell data processed in the 
previous sections.

```{r spatial-load-data, message=FALSE}
library(SpatialExperiment)
library(imcRtools)
path <- "/mnt/Multimodal_Imaging_Daria/PIPELINE"

spe <- readRDS(file.path(path,"NEWEST_RESULTS/results/Manuscript/spe_clustered.rds"))
spe <- spe[,spe$tissue=="PT"]

spe_neighbors <- read_steinbock(path=file.path(path, "PT_neighbors_15"), image_file=NULL, panel_file = NULL, intensities_folder = "intensities-0px-ref",regionprops_folder = NULL, graphs_folder="neighbors") 
colnames(spe_neighbors) <- paste0(spe_neighbors$sample_id, "_", spe_neighbors$ObjectNumber)

colPair(spe, "neighborhood") <- colPair(spe_neighbors[,colnames(spe)], "neighborhood")

spe$celltype_2 <- spe$metacluster
spe[,spe$metacluster=="tumor"]$celltype_2 <- spe[,spe$metacluster=="tumor"]$celltype

spe_red <- spe[,spe$metacluster!="other" & spe$metacluster!="progenitor"]
```

## Spatial interaction graphs

Many spatial analysis approaches either compare the observed versus expected
number of cells around a given cell type (point process) or utilize interaction
graphs (spatial object graphs) to estimate clustering or interaction frequencies
between cell types.

The [steinbock](https://bodenmillergroup.github.io/steinbock/latest/cli/measurement/) 
framework allows the construction of these spatial graphs. During image 
processing (see Section \@ref(image-processing)), we have constructed
a spatial graph by expanding the individual cell masks by 4 pixels. 

The `imcRtools` package further allows the *ad hoc* consctruction of spatial
graphs directly using a `SpatialExperiment` or `SingleCellExperiment` object
while considering the spatial location (centroids) of individual cells. The
[buildSpatialGraph](https://bodenmillergroup.github.io/imcRtools/reference/buildSpatialGraph.html)
function allows constructing spatial graphs by detecting the k-nearest neighbors
in 2D (`knn`), by detecting all cells within a given distance to the center cell
(`expansion`) and by Delaunay triangulation (`delaunay`).

When constructing a knn graph, the number of neighbors (`k`) needs to be set and
(optionally) the maximum distance to consider (`max_dist`) can be specified.
When constructing a graph via expansion, the distance to expand (`threshold`)
needs to be provided. For graphs constructed via Delaunay triangulation,
the `max_dist` parameter can be set to avoid unusually large connections at the
edge of the image.

```{r build-spatial-graphs}
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "knn", k = 20)
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "expansion", threshold = 20)
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "delaunay", max_dist = 20)
```

The spatial graphs are stored in `colPair(spe, name)` slots. These slots store
`SelfHits` objects representing edge lists in which the first column indicates
the index of the "from" cell and the second column the index of the "to" cell.
Each edge list is newly constructed when subsetting the object.

```{r show-colPairNames}
colPairNames(spe)
```

Here, `colPair(spe, "neighborhood")` stores the spatial graph constructed by
`steinbock`, `colPair(spe, "knn_interaction_graph")` stores the knn spatial
graph, `colPair(spe, "expansion_interaction_graph")` stores the expansion graph
and `colPair(spe, "delaunay_interaction_graph")` stores the graph constructed by
Delaunay triangulation.

## Spatial visualization {#spatial-viz}

Section \@ref(image-visualization) highlights the use of the
[cytomapper](https://www.bioconductor.org/packages/release/bioc/html/cytomapper.html)
package to visualize multichannel images and segmentation masks. Here, we
introduce the
[plotSpatial](https://bodenmillergroup.github.io/imcRtools/reference/plotSpatial.html)
function of the [imcRtools](https://www.bioconductor.org/packages/release/bioc/html/imcRtools.html) package to visualize the cells' centroids and
cell-cell interactions as spatial graphs.

In the following example, we select one image for visualization purposes. 
Here, each dot (node) represents a cell and edges are drawn between cells
in close physical proximity as detected by `steinbock` or the `buildSpatialGraph`
function. Nodes are variably colored based on the cell type and edges are
colored in grey.

```{r spatial-viz-1, message=FALSE, fig.width=15, fig.height=10}
library(ggplot2)
library(viridis)

# steinbock interaction graph 
plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-1927_TU_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "neighborhood", 
            nodes_first = FALSE, 
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$col_celltype) +
    ggtitle("steinbock interaction graph")

# knn interaction graph 
plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-1927_TU_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "knn_interaction_graph", 
            nodes_first = FALSE,
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$col_celltype) +
    ggtitle("knn interaction graph")

# expansion interaction graph 
plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-1927_TU_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            nodes_first = FALSE,
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$col_celltype) +
    ggtitle("expansion interaction graph")

# delaunay interaction graph 
plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-1927_TU_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "delaunay_interaction_graph", 
            nodes_first = FALSE,
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$col_celltype) +
    ggtitle("delaunay interaction graph")
```

Nodes can also be colored based on the cells' expression levels (e.g.,
E-cadherin expression) and their size can be adjusted (e.g., based on measured
cell area).

```{r spatial-viz-2, fig.width=12, fig.height=10}
plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-1927_TU_001"], 
            node_color_by = "ELAVL4_Yb174_mean", 
            assay_type = "exprs",
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "neighborhood", 
            nodes_first = FALSE, 
            node_size_by = "area", 
            directed = FALSE,
            edge_color_fix = "grey") + 
    scale_size_continuous(range = c(0.1, 2)) +
    ggtitle("ELAVL4")
```

Finally, the `plotSpatial` function allows displaying all images at once. This
visualization can be useful to quickly detect larger structures of interest.

```{r spatial-viz-3, fig.height=12, fig.width=12}
plotSpatial(spe, 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            node_size_fix = 0.5) + 
    scale_color_manual(values = metadata(spe)$color_vectors$col_celltype)
```

For a full documentation on the `plotSpatial` function, please refer to
`?plotSpatial`.

## Cellular neighborhood analysis

The following section highlights the use of the `imcRtools` package to
detect cellular neighborhoods. This approach has been proposed by
[@Goltsev2018] and [@Schurch2020] to group cells based on information
contained in their direct neighborhood.

[@Goltsev2018] perfomed Delaunay triangulation-based graph construction,
neighborhood aggregation and then clustered cells. [@Schurch2020] on the
other hand constructed a 10-nearest neighbor graph before aggregating
information across neighboring cells.

In the following code chunk we will use the 20-nearest neighbor graph as
constructed above to define the direct cellular neighborhood. The
[aggregateNeighbors](https://bodenmillergroup.github.io/imcRtools/reference/aggregateNeighbors.html)
function allows neighborhood aggregation in 2 different ways:

1.  For each cell the function computes the fraction of cells of a
    certain type (e.g., cell type) among its neighbors.
2.  For each cell it aggregates (e.g., mean) the expression counts
    across all neighboring cells.

Based on these measures, cells can now be clustered into cellular
neighborhoods. We will first compute the fraction of the different cell
types among the 20-nearest neighbors and use kmeans clustering to group
cells into 6 cellular neighborhoods.

**Of note:** constructing a 20-nearest neighbor graph and clustering
using kmeans with `k=6` is only an example. Similar to the analysis done
in Section \@ref(snn-graph), it is recommended to perform a parameter
sweep across different graph construction algorithms and different
parmaters `k` for kmeans clustering. Finding the best CN detection
settings is also subject to the question at hand. Constructing graphs
with more neighbors usually results in larger CNs.

```{r cn-analysis, fig.width=20, fig.height=50}
library(RColorBrewer)
library(circlize)
library(patchwork)
library(ggplot2)

# By celltypes
spe <- aggregateNeighbors(spe, 
                          colPairName = "neighborhood", 
                          aggregate_by = "metadata", 
                          count_by = "celltype")

set.seed(220705)

cn_1 <- kmeans(spe$aggregatedNeighbors, centers = 6)
spe$cn_celltypes <- as.factor(cn_1$cluster)

plotSpatial(spe, 
            node_color_by = "cn_celltypes", 
            img_id = "sample_id", 
            ncols=6,
            node_size_fix = 0.5) +
    scale_color_brewer(palette = "Set3")

saveRDS(spe, file.path(path, "NEWEST_RESULTS/results/spatial_analysis/spe_CNs.rds"))
```

There are now different visualizations to examine the cell type composition 
of the detected cellular neighborhoods (CN). First we can look at the total 
number of cells per cell type and CN.

```{r, fig.width=10, fig.height=6}
library(pheatmap)
library(viridis)

for_plot <- table(as.character(spe$cn_celltypes), spe$celltype)

pheatmap(for_plot, 
         color = viridis(100), display_numbers = TRUE, 
         number_color = "white", number_format = "%.0f")
```

Next, we can observe per cell type the fraction of CN that they are distributed
across.

```{r, fig.width=15, fig.height=6}
for_plot <- prop.table(table(as.character(spe$cn_celltypes), spe$celltype_2), margin = 2)

pheatmap(for_plot, 
         color = viridis(100), display_numbers = TRUE, 
         number_color = "white", number_format = "%.2f")
```

Similarly, we can visualize the fraction of each CN made up of each cell type.

```{r, fig.width=15, fig.height=6}
for_plot <- prop.table(table(as.character(spe$cn_celltypes), spe$celltype_2), margin = 1)

pheatmap(for_plot, 
         color = viridis(100), display_numbers = TRUE, 
         number_color = "white", number_format = "%.2f")
```

This visualization can also be scaled by column to account for the relative 
cell type abundance.

```{r, fig.width=15, fig.height=6}
pheatmap(for_plot, 
         color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")
```

Lastly, we can visualize the enrichment of cell types within cellular neighborhoods
using the `regionMap` function of the `lisaClust` package.

```{r, fig.height=10, fig.width=5}
library(lisaClust)
regionMap(spe, 
          cellType = "celltype",
          region = "cn_celltypes")
```

It is also recommended to visualize some images to confirm the interpretation of
cellular neighborhoods. For this we can either use the `lisClust::hatchingPlot` or
the `imcRtools::plotSpatial` functions:

```{r}
# hatchingPlot
cur_spe <- spe[,spe$sample_id == "20220926_20220809_16-1927_TU_001"]
cur_sce <- as(cur_spe, "SingleCellExperiment")
cur_sce$x <- spatialCoords(cur_spe)[,1]
cur_sce$y <- spatialCoords(cur_spe)[,2]
cur_sce$region <- as.character(cur_sce$cn_celltypes)

hatchingPlot(cur_sce, region = "region", cellType = "celltype") +
    scale_color_manual(values = metadata(spe)$color_vectors$col_celltype)
```

```{r, fig.height=8, fig.width=10}
# plotSpatial
plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-1927_TU_001"],
            img_id = "cn_celltypes", node_color_by = "celltype", node_size_fix = 0.7) +
    scale_color_manual(values = metadata(spe)$color_vectors$col_celltype)
```

CN 1 and CN 6 are mainly enriched for tumor cells with CN 6 forming the
tumor/stroma border. CN 3 is mainly enriched for B and BnT cells
indicating TLS. CN 5 is composed of aggregated plasma cells and most T
cells.

We will now detect cellular neighborhoods by computing the mean
expression across the 20-nearest neighbor prior to kmeans clustering
(k=6).

```{r, fig.height=15, fig.width=20}
# By expression

spe <- aggregateNeighbors(spe, 
                          colPairName = "knn_interaction_graph", 
                          aggregate_by = "expression", 
                          assay_type = "exprs",
                          subset_row = rowData(spe)$use_channel)

set.seed(220705)

cn_2 <- kmeans(spe$mean_aggregatedExpression, centers = 10)
spe$cn_expression <- as.factor(cn_2$cluster)

plotSpatial(spe[,spe_red$sample%in%unique(spe_red$sample)[5:9]], 
            node_color_by = "cn_expression", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_brewer(palette = "Set3")
```

Also here, we can visualize the cell type composition of each cellular
neighborhood.

```{r, fig.width=15, fig.height=6}
for_plot <- prop.table(table(spe$cn_expression, spe$celltype), 
                  margin = 1)

pheatmap(for_plot, 
         color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")
```

When clustering cells based on the mean expression within the direct
neighborhood, tumor cells are split across CN 6, CN 1 and CN 4 without
forming a clear tumor/stroma interface. This result reflects
patient-to-patient differences in the expression of tumor markers.

CN 3 again contains B cells and BnT cells but also CD8 and undefined
cells, therefore it is less representative of TLS compared to CN 3 in
previous CN approach. CN detection based on mean marker expression is
therefore sensitive to staining/expression differences between samples
as well as lateral spillover due to imperfect segmentation.

An alternative to the `aggregateNeighbors` function is provided by the
[lisaClust](https://bioconductor.org/packages/release/bioc/html/lisaClust.html)
Bioconductor package [@Patrick2023]. In contrast to `imcRtools`, the
`lisaClust` package computes local indicators of spatial associations
(LISA) functions and clusters cells based on those. More precise, the
package summarizes L-functions from a Poisson point process model to
derive numeric vectors for each cell which can then again be clustered
using kmeans. All steps are supported by the `lisaClust` function which
can be applied to a `SingleCellExperiment` and `SpatialExperiment` object.

In the following example, we calculate the LISA curves within a 10µm, 20µm and
50µm neighborhood around each cell. Increasing these radii will lead to broader
and smoother spatial clusters. However, a number of parameter settings should be
tested to estimate the robustness of the results.

```{r lisaClust, fig.height=12, fig.width=12, message=FALSE}
set.seed(220705)
spe <- lisaClust(spe, 
                 k = 6,
                 Rs = c(10, 20, 50),
                 spatialCoords = c("Pos_X", "Pos_Y"),
                 cellType = "celltype",
                 imageID = "sample_id")

plotSpatial(spe[, spe$sample%in%unique(spe$sample)[5:9]], 
            node_color_by = "region", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_brewer(palette = "Set3")
```

Similar to the example above, we can now observe the cell type
composition per spatial cluster.

```{r lisaClust-3, fig.width=15, fig.height=6}
for_plot <- prop.table(table(spe$region, spe$celltype), 
                  margin = 1)

pheatmap(for_plot, 
         color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")
```

In this case, CN 1 and 4 contain tumor cells but no CN is forming the
tumor/stroma interface. CN 3 represents TLS. CN 2 indicates T cell
subtypes and plasma cells are aggregated to CN 5.

## Patch detection

The previous section focused on detecting cellular neighborhoods in a rather
unsupervised fashion. However, the `imcRtools` package also provides methods for
detecting spatial compartments in a supervised fashion. The
[patchDetection](https://bodenmillergroup.github.io/imcRtools/reference/patchDetection.html)
function allows the detection of connected sets of similar cells as proposed by
[@Hoch2022]. In the following example, we will use the `patchDetection` function
to detect tumor patches in three steps:

1. Find connected sets of tumor cells (using the `steinbock` graph).  
2. Components which contain less than 10 cells are excluded.  
3. Expand the components by 1µm to construct a concave hull around the patch and
include cells within the patch.

```{r patchDetection-1, fig.height=20, fig.width=20}
library(ggplot2)
spe <- patchDetection(spe, 
                      patch_cells = spe$metacluster == "tumor",
                      img_id = "sample_id",
                      min_patch_size=20,
                      expand_by=1,
                      colPairName = "neighborhood")

plotSpatial(spe, 
            node_color_by = "patch_id", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none")
    #scale_color_manual(values = rev(colors()))
```

We can now plot the proportion of celltypes within these patches.
```{r immune-infiltration}
# overall
spe_red <- spe[, spe$metacluster=="T cell" | spe$metacluster=="B cell" | spe$metacluster=="granulocyte" | spe$metacluster=="MO/DC/NK"]
counts <- as.data.frame(table(spe_red$celltype))

ggplot(counts, aes(x = "", y = Freq, fill = Var1)) +
  geom_col(position = "fill") + 
  coord_polar(theta = "y") +
  xlab(NULL) +
  scale_fill_manual(values=metadata(spe)$color_vectors$col_celltype)

# within patches
spe_red <- spe[, !is.na(spe$patch_id) & (spe$metacluster=="T cell" | spe$metacluster=="B cell" | spe$metacluster=="granulocyte" | spe$metacluster=="MO/DC/NK")]
counts <- table(spe_red$celltype)
counts <- as.data.frame(table(spe_red$celltype))

ggplot(counts, aes(x = "", y = Freq, fill = Var1)) +
  geom_col(position = "fill") + 
  coord_polar(theta = "y") +
  xlab(NULL) +
  scale_fill_manual(values=metadata(spe)$color_vectors$col_celltype)
```

We can see that most of the infiltrating immune cells are T cells. Let's see which T cells those are.

```{r immune-infiltration2}
spe_red <- spe[, !is.na(spe$patch_id) & spe$metacluster=="T cell"]
counts <- table(spe_red$celltype)
plot_colors <- metadata(spe)$color_vectors$col_celltype[names(counts)]

pie(counts, 
    col=plot_colors)
```
Let's compare progress versus no progress.

```{r immune-infiltration2}
spe_red <- spe[, !is.na(spe$patch_id) & spe$metacluster=="T cell" & spe$progression==0]
counts <- table(spe_red$celltype)
plot_colors <- metadata(spe)$color_vectors$col_celltype[names(counts)]

pie(counts, 
    col=plot_colors)

spe_red <- spe[, !is.na(spe$patch_id) & spe$metacluster=="T cell" & spe$progression==1]
counts <- table(spe_red$celltype)
plot_colors <- metadata(spe)$color_vectors$col_celltype[names(counts)]

pie(counts, 
    col=plot_colors)
```

We can now calculate the fraction of T cells within each tumor patch to roughly
estimate T cell infiltration.

```{r patchDetection-2, fig.width=20, fig.height=8, message=FALSE}
library(tidyverse)
colData(spe) %>% as_tibble() %>%
    group_by(patch_id, sample) %>%
    summarize(Tcell_count = sum(metacluster == "T cell"),
              patch_size = n(),
              Tcell_freq = Tcell_count / patch_size) %>%
    filter(!is.na(patch_id)) %>%
    ggplot() +
        geom_point(aes(log10(patch_size), Tcell_freq, color = sample)) +
    theme_classic()

```

Now we want to correlate T cell infiltration with progression.
```{r, fig.width=16, fig.height=15}
library("ggpubr")
library(gtools)

variable <- "progression"
plot_list <- list()
celltypes <- unique(spe[, spe$metacluster=="T cell" | spe$metacluster=="B cell" | spe$metacluster=="granulocyte" | spe$metacluster=="MO/DC/NK"]$celltype)
#spe <- spe[, spe$MYCN_amp == 0 | spe$MYCN_amp == 1]

for(i in 1:length(unique(celltypes))){
  
  c <- celltypes[i]
  
  cell_freq_per_patch <- colData(spe) %>% as_tibble() %>%
      group_by(patch_id, sample) %>%
      summarize(cell_count = sum(celltype == c),
                patch_size = n(),
                cell_freq = cell_count / patch_size) %>%
      filter(!is.na(patch_id)) 
    
  mean_cell_freq_per_sample <- cell_freq_per_patch %>%
    group_by(sample) %>%
    summarise(mean_cell_freq = mean(cell_freq, na.rm = TRUE))%>%
    arrange(desc(mean_cell_freq))
  
  df <- data.frame(
    sample = spe$sample,
    condition = colData(spe)[,variable]
  )
  
  progression_per_sample <- df %>%
    group_by(sample) %>%
    summarise(condition = first(condition))
  
  combined_data <- mean_cell_freq_per_sample %>%
    left_join(progression_per_sample, by = "sample")
  
  stats_df <- compare_means(mean_cell_freq ~ condition,  
                            method = "wilcox.test",  
                            data = combined_data) 
    
  stats_df$p_adj_signif <- stars.pval(stats_df$p.adj)
  stats_df$p_adj_signif[stats_df$p_adj_signif==" "] <- "ns"
  stats_df$p_long <- paste0(stats_df$p.adj, " (", stats_df$p_adj_signif, ")")
  
  color <- unname(metadata(spe)$color_vectors$col_celltype[as.character(c)])
  
  plot_list[[c]] <- ggboxplot(combined_data, x = "condition", y = "mean_cell_freq",
                  color = "condition", palette =c(color, color),
                  add.params = list(size = 3),
                  add = "jitter",
                  title=c) + 
                  stat_pvalue_manual(stats_df, label = "p_long", y.position = max(combined_data$mean_cell_freq), step.increase = 0.4,) +
                  theme(aspect.ratio = 1.6, legend.position="none") +
      scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
                  
  
}

grid.arrange(grobs = plot_list, ncol = 6)
```


We can now measure the size of each patch using the
[patchSize](https://bodenmillergroup.github.io/imcRtools/reference/patchSize.html)
function and visualize tumor patch distribution per patient.

```{r patch-size}
patch_size <- patchSize(spe, "patch_id")

patch_size <- merge(patch_size, 
                    colData(spe)[match(patch_size$patch_id, spe$patch_id),], 
                    by = "patch_id")

ggplot(as.data.frame(patch_size)) + 
    geom_boxplot(aes(sample, log10(size))) +
    geom_point(aes(sample, log10(size)))
```

The
[minDistToCells](https://bodenmillergroup.github.io/imcRtools/reference/minDistToCells.html)
function can be used to calculate the minimum distance between each cell and a
cell set of interest. Here, we highlight its use to calculate the minimum
distance of all cells to the detected tumor patches. Negative values indicate
the minimum distance of each tumor patch cell to a non-tumor patch cell.

```{r minDistCells, fig.height=20, fig.width=20}
spe <- minDistToCells(spe, 
                      x_cells = !is.na(spe$patch_id), 
                      img_id = "sample_id")

plotSpatial(spe, 
            node_color_by = "distToCells", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_gradient2(low = "dark blue", mid = "white", high = "dark red")
```

Let's only plot these cells with a distance of 50 pixels from the tumor border to find an appropriate threshold.
```{r, fig.height=40, fig.width=20}
threshold <- 100

spe$border <- "stroma"
spe[, abs(spe$distToCells) <= threshold & spe$sample_id != "20221018_20220906_03-0170_TU_001"]$border <- "border"
spe[,spe$border != "border" & spe$distToCells<0 & spe$sample_id != "20221018_20220906_03-0170_TU_001"]$border <- "core"

spe_red <- spe[, spe$border == "stroma"]


plotSpatial(spe_red, 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            ncols=6,
            node_size_fix = 0.5) +
        scale_color_manual(values = metadata(spe)$color_vectors$col_celltype) 
```

```{r}
plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-1927_TU_001"], 
            node_color_by = "GD2_Gd155_mean", 
            assay_type = "exprs",
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "neighborhood", 
            nodes_first = FALSE, 
            node_size_by = "area", 
            directed = FALSE,
            edge_color_fix = "grey") + 
    scale_size_continuous(range = c(0.1, 2)) +
    ggtitle("GD2")

plotSpatial(spe[,spe$sample_id == "20220926_20220809_16-1927_TU_001"], 
            node_color_by = "patch_id", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none")

plotSpatial(spe_red[,spe_red$sample_id == "20220926_20220809_16-1927_TU_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            ncols=6,
            node_size_fix = 0.5) +
        scale_color_manual(values = metadata(spe)$color_vectors$col_celltype) 
```

Next, we plot the composition of cells at the tumor-stroma border in piecharts.

```{r immune-infiltration2}

counts <- table(spe[, spe$border == "core" & spe$metacluster=="T cell"]$celltype)
#counts <- counts[sort(names(counts))]
plot_colors <- metadata(spe)$color_vectors$col_celltype[names(counts)]

pie(counts, 
    col=plot_colors,
    clockwise=T)

counts <- table(spe[, spe$border == "border" & spe$metacluster=="T cell"]$celltype)
#counts <- counts[sort(names(counts))]
plot_colors <- metadata(spe)$color_vectors$col_celltype[names(counts)]

pie(counts, 
    col=plot_colors,
    clockwise=T)

counts <- table(spe[, spe$border == "stroma" & spe$metacluster=="T cell"]$celltype)
#counts <- counts[sort(names(counts))]
plot_colors <- metadata(spe)$color_vectors$col_celltype[names(counts)]

pie(counts, 
    col=plot_colors,
    clockwise=T)
```
Let's compare the cell composition at and outside the border on the sample_level.

```{r, fig.width=10, fig.height=10}
library(tidyr)

df <- as.data.frame(colData(spe)[spe$metacluster =="tumor", c("sample", "celltype", "border")])

df_summary <- df %>%
  group_by(sample, celltype, border) %>%
  summarise(count = n(), .groups = 'drop') %>%
  ungroup() %>%
  complete(sample, celltype, border, fill = list(count = 0)) %>%
  group_by(sample, border) %>%
  mutate(total = sum(count)) %>%
  ungroup() %>%
  mutate(proportion = if_else(total == 0, 0, count / total))

#adjust the order
df_summary$border <- factor(df_summary$border, levels = c("core", "border", "stroma"))

# Calculate p-values and log2FC for each cell type
small_constant <- 1e-10

results <- df_summary %>%
  group_by(celltype) %>%
  summarise(
    test_results = list(compare_means(proportion ~ border, data = cur_data(), paired = TRUE, method = "wilcox.test", p.adjust.method = "BH")),
    .groups = 'drop'
  ) %>%
  unnest(cols = c(test_results))

#results <- add_y_position(data=df_summary, formula=proportion ~ border, test=results, scales="free_y")

# Custom function to adjust y positions for each celltype and comparison
adjust_y_positions <- function(results, df_summary) {
  results <- results %>%
    group_by(celltype) %>%
    mutate(y.position = seq(from = max(df_summary$proportion[df_summary$celltype == unique(celltype)]) * 1.0,
                            length.out = n(),
                            by = max(df_summary$proportion[df_summary$celltype == unique(celltype)]) * 0.08)) %>%
    ungroup()
  return(results)
}

# Adjust the y.position in the results data frame
results <- adjust_y_positions(results, df_summary)

ggplot(df_summary, aes(x = border, y = proportion)) +
  geom_boxplot(aes(color = celltype), fill = NA, position = position_dodge(0.9), alpha = 0.75) +
  geom_jitter(aes(color = celltype), position = position_jitterdodge(jitter.width = 0.35, dodge.width = 0.9), size = 2, alpha = 0.5) +
  stat_pvalue_manual(results, tip.length=0) +
  facet_wrap(~ celltype, scales = "free_y") +
  scale_color_manual(values = metadata(spe)$color_vectors$col_celltype) +
  labs(title = "Comparison of Cell Type Proportions at Border vs No Border",
       x = "Border Status", y = "Proportion of Cell Type") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
```{r, fig.width=10, fig.height=10}
library(tidyr)

df <- as.data.frame(colData(spe)[spe$metacluster =="MO/DC/NK", c("sample", "celltype", "border")])

df_summary <- df %>%
  group_by(sample, celltype, border) %>%
  summarise(count = n(), .groups = 'drop') %>%
  ungroup() %>%
  complete(sample, celltype, border, fill = list(count = 0)) %>%
  group_by(sample, border) %>%
  mutate(total = sum(count)) %>%
  ungroup() %>%
  mutate(proportion = if_else(total == 0, 0, count / total))

#adjust the order
df_summary$border <- factor(df_summary$border, levels = c("core", "border", "stroma"))

# Calculate p-values and log2FC for each cell type
small_constant <- 1e-10

# Custom function to calculate log2FC for each pair of conditions
calculate_log2FC <- function(df, condition1, condition2, celltype) {
  mean1 <- mean(df$proportion[df$border == condition1 & df$celltype == celltype] + small_constant)
  mean2 <- mean(df$proportion[df$border == condition2 & df$celltype == celltype] + small_constant)
  log2FC <- log2(mean1 / mean2)
  return(log2FC)
}

# Calculate p-values and log2FC for each cell type
results <- df_summary %>%
  group_by(celltype) %>%
  summarise(
    comparisons = list(compare_means(proportion ~ border, data = cur_data(), paired = TRUE, method = "wilcox.test", p.adjust.method = "BH")),
    .groups = 'drop'
  ) %>%
  unnest(cols = c(comparisons)) %>%
  rowwise() %>%
  mutate(
    log2FC = case_when(
      group1 == "core" & group2 == "border" ~ calculate_log2FC(df_summary, "border", "core", celltype),
      group1 == "core" & group2 == "stroma" ~ calculate_log2FC(df_summary, "stroma", "core", celltype),
      group1 == "border" & group2 == "stroma" ~ calculate_log2FC(df_summary, "stroma", "border", celltype),
      TRUE ~ NA_real_
    )
  ) %>%
  ungroup()

# Add custom labels with log2FC and p-value
results <- results %>%
  mutate(label = paste0(round(log2FC, 2), " (", format.pval(p.adj, digits = 3), ")"))

# Custom function to adjust y positions for each celltype and comparison
adjust_y_positions <- function(results, df_summary) {
  results <- results %>%
    group_by(celltype) %>%
    mutate(y.position = seq(from = max(df_summary$proportion[df_summary$celltype == unique(celltype)]) * 1.1,
                            length.out = n(),
                            by = max(df_summary$proportion[df_summary$celltype == unique(celltype)]) * 0.1)) %>%
    ungroup()
  return(results)
}

# Adjust the y.position in the results data frame
results <- adjust_y_positions(results, df_summary)

# Plot with custom labels
ggplot(df_summary, aes(x = border, y = proportion)) +
  geom_boxplot(aes(color = celltype), fill = NA, position = position_dodge(0.9), alpha = 0.75) +
  geom_jitter(aes(color = celltype), position = position_jitterdodge(jitter.width = 0.35, dodge.width = 0.9), size = 2, alpha = 0.5) +
  stat_pvalue_manual(results, label = "label", tip.length = 0) +
  facet_wrap(~ celltype, scales = "free_y") +
  scale_color_manual(values = metadata(spe)$color_vectors$col_celltype) +
  labs(title = "Comparison of Cell Type Proportions at Border vs No Border",
       x = "Border Status", y = "Proportion of Cell Type") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

Finally, we can  observe the minimum distances to tumor patches in a cell type
specific manner.

```{r celltype-distance, fig.height=15,fig.width=15, message=FALSE}
library(ggridges)

ggplot(as.data.frame(colData(spe))) + 
    geom_density_ridges(aes(distToCells, celltype, fill = celltype)) +
    geom_vline(xintercept = 0, color = "dark red", linewidth = 2) +
    scale_fill_manual(values = metadata(spe)$color_vectors$col_celltype)
```

## Interaction analysis

**Bug notice: we discovered and fixed a bug in the `testInteractions` function in version below 1.5.5 which affected `SingleCellExperiment` or `SpatialExperiment` objects in which cells were not grouped by image. Please make sure you have the newest version (>= 1.6.0) installed.**  

The next section focuses on statistically testing the pairwise interaction
between all cell types of the dataset. For this, the `imcRtools` package
provides the 
[testInteractions](https://bodenmillergroup.github.io/imcRtools/reference/testInteractions.html) 
function which implements the interaction testing strategy proposed by
[@Shapiro2017]. 

Per grouping level (e.g., image), the `testInteractions` function computes the 
averaged cell type/cell type interaction count and compares this count against
an empirical null distribution which is generated by permuting all cell labels (while maintaining the tissue structure).

In the following example, we use the `steinbock` generated spatial interaction
graph and estimate the interaction or avoidance between cell types in the
dataset.

```{r testInteractions-1, message=FALSE}
library(scales)
library(BiocParallel)
out <- testInteractions(spe, 
                        group_by = "sample_id",
                        label = "celltype", 
                        colPairName = "neighborhood")
                        #BPPARAM = SerialParam(RNGseed = 221029))

head(out)
```

The returned `DataFrame` contains the test results per grouping level (in this case
the image ID, `group_by`), "from" cell type (`from_label`) and "to" cell type
(`to_label`). The `sigval` entry indicates if a pair of cell types is
significantly interacting (`sigval = 1`), if a pair of cell types is
significantly avoiding (`sigval = -1`) or if no significant interaction or
avoidance was detected (`sigval = 0`).

These results can be visualized by computing the sum of the `sigval` entries
across all images:

```{r testInteractions-2, fig.width=10, fig.height=10, message=FALSE}
library(dplyr)
out %>% as_tibble() %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
    ggplot() +
        geom_tile(aes(from_label, to_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
Let's plot a heatmap with clustered rows and columns:
```{r, fig.width=15, fig.height=15}
library(pheatmap)
library(tidyverse)
data <- out %>% as_tibble() %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE))

# Reshaping the data to a wide format suitable for heatmap
data_wide <- data %>%
  pivot_wider(
    names_from = to_label,
    values_from = sum_sigval,
    values_fill = list(sum_sigval = 0)  # Fill missing combinations with 0 if any
  )

data_wide <- tibble::column_to_rownames(data_wide, var = "from_label")

# Define maximum range value for symmetric color scale
#max_range <- max(abs(max(data_wide)), abs(min(data_wide)))  # This would be 30 in your case
max_range <- max(abs(50), abs(50))

# Define breaks, making sure 0 is exactly in the middle
breaks <- seq(-max_range, max_range, length.out = 101)  # From -30 to 30

# Create a color palette from blue (negative) to white (zero) to red (positive)
colors <- colorRampPalette(c("blue", "white", "red"))(length(breaks) - 1)

# Plotting the heatmap
pheatmap(data_wide,
         color = colors,
         breaks = breaks,
         #clustering_distance_rows = "euclidean",
         #clustering_distance_cols = "euclidean",
         #clustering_method = "complete",
         cellwidth = 20,
         cellheight = 20,
         fontsize = 10,
         display_numbers = TRUE  # Optionally display the values in cells
)

```

In the plot above the red tiles indicate cell type pairs that were detected to 
significantly interact on a large number of images. On the other hand, blue
tiles show cell type pairs which tend to avoid each other on a large number 
of images. 

Here we can observe that tumor cells are mostly compartmentalized and are in
avoidance with other cell types. As expected, B cells interact with BnT cells; 
regulatory T cells interact with CD4+ T cells and CD8+ T cells. Most cell types
show self interactions indicating spatial clustering. 

The `imcRtools` package further implements an interaction testing strategy
proposed by [@Schulz2018] where the hypothesis is tested if at least n cells of
a certain type are located around a target cell type (`from_cell`). This type of
testing can be performed by selecting `method = "patch"` and specifying the
number of patch cells via the `patch_size` parameter.

```{r testInteractions-3, message=FALSE}
out <- testInteractions(spe, 
                        group_by = "sample_id",
                        label = "celltype", 
                        colPairName = "neighborhood",
                        method = "patch", 
                        patch_size = 3,
                        BPPARAM = SerialParam(RNGseed = 221029))

out %>% as_tibble() %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
    ggplot() +
        geom_tile(aes(from_label, to_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

These results are comparable to the interaction testing presented above. The
main difference comes from the lack of symmetry. We can now for example see that
3 or more myeloid cells sit around CD4$^+$ T cells while this interaction is not
as strong when considering CD4$^+$ T cells sitting around myeloid cells.

Finally, we save the updated `SpatialExperiment` object.

```{r spatial-save-object}
saveRDS(spe, file.path(path,"results/spatial_analysis/spe_CNs_border.rds"))
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>