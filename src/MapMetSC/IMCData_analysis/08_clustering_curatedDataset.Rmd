---
title: "Clustering on curated datset(without sticky cells)"
output: html_document
date: '2022-08-14'
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = "120%")

library(Rphenograph)
library(igraph)
library(dittoSeq)
library(viridis)

library(FastPG)
library(parallel)
library(CATALYST)

library(kohonen)
library(bluster)
library(ConsensusClusterPlus)
```

# Cell phenotyping 

A common step during single-cell data analysis is the annotation of cells based
on their phenotype. Defining cell phenotypes is often subjective and relies
on previous biological knowledge. The [Orchestrating Single Cell Analysis with Bioconductor](https://bioconductor.org/books/3.14/OSCA.basic/cell-type-annotation.html) book
presents a number of approaches to phenotype cells detected by single-cell RNA
sequencing based on reference datasets or prior knowledge of geneset importance.

In highly-multiplexed imaging, target proteins or molecules are manually
selected based on the biological question at hand. It narrows down the feature
space and facilitates the manual annotation of clusters to derive cell
phenotypes. We will therefore discuss and compare a number of clustering
approaches to group cells based on their similarity in marker expression in
Section \@ref(clustering).

Unlike single-cell RNA sequencing or CyTOF data, single-cell data derived from
highly-multiplexed imaging data often suffers from "lateral spillover" between
neighboring cells. This spillover caused by imperfect segmentation often hinders
accurate clustering to define specific cell phenotypes in multiplexed imaging
data. Tools have been developed to correct lateral spillover between cells
[@Bai2021] but the approach requires careful selection of the markers to
correct. In Section \@ref(classification) we will train and apply a random
forest classifier to classify cell phenotypes in the dataset as alternative
approach for clustering-based cell phenotyping. This approach has been previously used to
identify major cell phenotypes in metastatic melanoma and avoids clustering of
cells [@Hoch2022].

## Load data

We will first read in the previously generated `SpatialExperiment` object and
sample 2000 cells to visualize cluster membership.

```{r read-data-pheno, message=FALSE}
library(SpatialExperiment)
library(bruceR)

path <- "/mnt/Multimodal_Imaging_Daria/_Data_Analysis/_tmp_daria/Image_analysis/20220723_Steinbock_Mesmer_IFbased"
spe <- readRDS(file.path(path,"data/spe_curated_pg.rds"))

# Sample cells
set.seed(220619)
cur_cells <- sample(seq_len(ncol(spe)), 20000)

#Scale expression between 0 and 1 for later visualization
assay(spe, "scaled_exprs") <- t(apply(assay(spe, "exprs"), 1, RESCALE, to=0:1))
```

## Clustering approaches {#clustering}

In the first section to identify cellular phenotypes in the dataset, we will
present clustering approaches that group cells based on their similarity in
marker expression. A number of approaches have been developed to cluster data
derived from single-cell RNA sequencing technologies [@Yu2022] or CyTOF
[@Weber2016]. For demonstration purposes, we will highlight common clustering
approaches that are available in R and have been used for clustering cells
obtained from IMC. Two approaches rely on graph-based clustering and one
approach uses self organizing maps (SOM).

### Rphenograph

The PhenoGraph clustering approach was first described to group cells of a CyTOF
dataset [@Levine2015]. The algorithm first constructs a graph by detecting the
`k` nearest neighbours based on euclidean distance in expression space. In the
next step, edges between nodes (cells) are weighted by their overlap in nearest
neighbor sets. To quantify the overlap in shared nearest neighbor sets, the
jaccard index is used. The Louvain modularity optimization approach is used to
detect connected communities and partition the graph into cluster of cells. This
clustering strategy was used by Jackson, Fischer _et al._ to
cluster IMC data [@Jackson2020].

There are several different PhenoGraph implementations available in R. Here, we
use the one available at
[https://github.com/i-cyto/Rphenograph](https://github.com/i-cyto/Rphenograph).
For large datasets,
[https://github.com/stuchly/Rphenoannoy](https://github.com/stuchly/Rphenoannoy)
offers a more performant implementation of the algorithm.

In the following code chunk, we select the asinh-transformed mean pixel
intensities per cell and channel and subset the channels to the ones containing
biological variation. This matrix is transposed to store cells in rows. Within
the `Rphenograph` function, we select the 45 nearest neighbors for graph
building and louvain community detection (default). The function returns a list
of length 2, the first entry being the graph and the second entry containing the
community object. Calling `membership` on the community object will return
cluster IDs for each cell. These cluster IDs are then stored within the
`colData` of the `SpatialExperiment` object. Cluster IDs are mapped on top of
the UMAP embedding and single-cell marker expression within each cluster are
visualized in form of a heatmap.

```{r, echo=FALSE}
start_time <- Sys.time()
```

Here we will test [fastPG](https://www.biorxiv.org/content/10.1101/2020.06.19.159749v1.full.pdf) as the fast implementation of Phenograph, as it is
reported to be more accurate than FlowSOM.

```{r rphenograph-1, message=FALSE, eval=FALSE}

n_threads <- detectCores()

mat <- reducedDim(spe, "harmony")

out <- FastPG::fastCluster(data=mat, k=45, num_threads=n_threads)

clusters <- factor(out$communities)

spe$pg_clusters <- clusters
```

```{r rphenograph-clustering-1, message=FALSE}
dittoDimPlot(spe, var = "pg_clusters", 
             reduction.use = "UMAP", size = 0.2,
             do.label = TRUE) +
    ggtitle("Phenograph clusters expression on UMAP")
```

```{r phenograph-heatmap-1, fig.height=8}
dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "pg_clusters",
             annotation_legend = FALSE,
             fontsize=5,
             annot.colors = dittoColors(1)[1:length(unique(spe$pg_clusters))])
```

We will also look at all cells to avoid missing rare cell types. This is not shown in html due to large size plots. 

```{r phenograph-heatmap-1-allcells, fig.height=8, eval=FALSE}
dittoHeatmap(spe, 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "pg_clusters_corrected",
             annotation_legend = FALSE,
             fontsize=5,
             annot.colors = dittoColors(1)[1:length(unique(spe$pg_clusters_corrected))])
```

We don't really find rare cells. 

```{r, echo=FALSE}
end_time <- Sys.time()
```

The `Rphenograph` function call took 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

We can observe that some of the clusters only contain cells of a single patient.
This  can often be observed in the tumor compartment. In the next step, we
use the integrated cells (see Section \@ref(batch-effects)) in low dimensional
embedding for clustering. Here, the low dimensional embedding can
be directly accessed from the `reducedDim` slot.

Here we will test [fastPG](https://www.biorxiv.org/content/10.1101/2020.06.19.159749v1.full.pdf) as the fast implementation of Phenograph, as it is
reported to be more accurate than FlowSOM.

```{r rphenograph-2, message=FALSE, eval=FALSE}

n_threads <- detectCores()

mat <- reducedDim(spe, "harmony")

out <- FastPG::fastCluster(data=mat, k=45, num_threads=n_threads)

clusters <- factor(out$communities)

spe$pg_clusters_corrected <- clusters
```

```{r rphenograph-clustering-2, message=FALSE}
dittoDimPlot(spe, var = "pg_clusters_corrected", 
             reduction.use = "UMAP_harmony", size = 0.2,
             do.label = TRUE) +
    ggtitle("Phenograph clusters expression on UMAP, integrated cells")
```

We immediately see that we get less clusters.

```{r phenograph-heatmap-2, fig.height=8}
dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "pg_clusters_corrected",
             annotation_legend = FALSE,
             fontsize=5,
             annot.colors = dittoColors(1)[1:length(unique(spe$pg_clusters_corrected))])
```

We observe that we get more segregated clusters with biologically more realisitic assignment of cells. We see a clear HLA-DR+ CD14+ CD274+ CD11c+ cluster which could represent monocytes/macrophages and dendritic cells. We see clearT-cells clusters with activated T-cells expressing CD8 and Granzyme B. We see an interesting cluster of proliferating cells expressing Ki-67, GAT3, CXCR4 and ElAVL4. We see a tumor cluster expressing GD2, CD56, ELAVL4 and GATA3. Another cluster expresses CD24, CD10 and CD11b. CD45, HLA-ABC and MPO are very homogeneously expressed. 

```{r phenograph-heatmap-2-allcells, fig.height=8, eval=FALSE}
dittoHeatmap(spe, 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "pg_clusters_corrected",
             annotation_legend = FALSE,
             annot.colors = dittoColors(1)[1:length(unique(spe$pg_clusters_corrected))])
```

As some markers have really low expressions, we will look a min-max scale rows. 

```{r phenograph-heatmap-2-scale, message=FALSE, fig.height=7}

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "scaled_exprs", 
             scale="none",
             heatmap.colors = viridis(100), 
             annot.by = "pg_clusters_corrected",
             annotation_legend = FALSE,
             fontsize=5,
             annot.colors = dittoColors(1)[1:length(unique(spe$pg_clusters_corrected))])

apply(assay(spe, "scaled_exprs"), 1, max)
```
For some markers (FOXP3), it looks like we have outliers causing all cells to be squeezed to zero.

And as a last step, let's show the mean per cluster. For aggregating across clusters, we had to change the SPE to an SCE as explained [here](https://github.com/drighelli/SpatialExperiment/issues/104).

```{r phenograph-heatmap-2-allcells-mean, message=FALSE, fig.height=7}
library(scuttle)

sce <- as(spe, "SingleCellExperiment")

cluster_mean <- aggregateAcrossCells(sce,
                                    ids = sce$pg_clusters_corrected,
                                    statistics="mean",
                                    use.assay.type = "counts")
assay(cluster_mean, "exprs") <- asinh(counts(cluster_mean))
assay(cluster_mean, "scaled_exprs") <- t(apply(assay(cluster_mean, "exprs"), 1, RESCALE, to=0:1))

col_pg = setNames(dittoColors(1)[1:length(unique(sce$pg_clusters_corrected))], 
                sort(unique(sce$pg_clusters_corrected)))

column_annot = HeatmapAnnotation(clusters=colData(cluster_mean)$pg_clusters_corrected, 
                                 ncells=anno_barplot(colData(cluster_mean)$ncells, height = unit(3, "cm")),
                                 col=list(clusters=col_pg))

#not scaled
cluster_mean%>%dittoHeatmap(genes = rownames(sce)[rowData(sce)$use_channel],
            assay = "exprs", scale = "none",
            heatmap.colors = viridis(100),
            column_title = "Phenograph clusters on integrated cells (non-scaled)",
            cluster_cols=TRUE,
            show_colnames= TRUE,
            top_annotation=column_annot,
            complex=TRUE,
            annot.colors = dittoColors(1)[1:length(unique(sce$pg_clusters_corrected))])

#scaled
cluster_mean%>%dittoHeatmap(genes = rownames(sce)[rowData(sce)$use_channel],
            assay = "scaled_exprs", 
            column_title = "Phenograph clusters on integrated cells (scaled means)",
            cluster_cols=TRUE,
            scale="none",
            heatmap.colors = viridis(100),
            show_colnames = TRUE,
            top_annotation=column_annot,
            complex=TRUE,
            annot.colors = dittoColors(1)[1:length(unique(sce$pg_clusters_corrected))])

rm(sce)
rm(cluster_mean)

```

Now we will look at the mean of the scaled expressions.

```{r phenograph-heatmap-2-allcells-mean-of-scaled, message=FALSE, fig.height=7}
library(scuttle)

sce <- as(spe, "SingleCellExperiment")

cluster_mean <- aggregateAcrossCells(sce,
                                    ids = sce$pg_clusters_corrected,
                                    statistics="mean",
                                    use.assay.type = "scaled_exprs")


#scaled
cluster_mean%>%dittoHeatmap(genes = rownames(sce)[rowData(sce)$use_channel],
            assay = "scaled_exprs", 
            column_title = "Phenograph clusters on integrated cells (mean of scaled exprs)",
            cluster_cols=TRUE,
            scale="none",
            heatmap.colors = viridis(100),
            show_colnames = TRUE,
            top_annotation=column_annot,
            complex=TRUE,
            annot.colors = dittoColors(1)[1:length(unique(sce$pg_clusters_corrected))])

rm(sce)
rm(cluster_mean)

```

We can see that there are some clusters with almost no signal. Those could be cells that were detected based on DAPI, but actually swam off after IF image acquisition. 

Clustering using the integrated embedding leads to clusters that contain cells
of different patients. Cluster annotation can now be performed by manually
labeling cells based on their marker expression (see Notes in Section
\@ref(clustering-notes)).

### Self organizing maps

An alternative to graph-based clustering is offered by the
[CATALYST](https://bioconductor.org/packages/release/bioc/html/CATALYST.html)
package. The `cluster` function internally uses the
[FlowSOM](https://bioconductor.org/packages/release/bioc/html/FlowSOM.html)
package to group cells into 100 (default) clusters based on self organizing maps
(SOM). In the next step, the
[ConsensusClusterPlus](https://bioconductor.org/packages/release/bioc/html/ConsensusClusterPlus.html)
package is used to perform hierarchical consensus clustering of the previously
detected 100 SOM nodes into 1 to `maxK` clusters. Cluster stability for each `k`
can be assessed by plotting the `delta_area(spe)`. The optimal number
of clusters can be found by selecting the `k` at which a plateau is reached.
In the example below, the optimal `k` lies somewhere around 13.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r flowSOM-1, message=FALSE, eval=FALSE}

# Run FlowSOM and ConsensusClusterPlus clustering
spe <- cluster(spe, 
               features = rownames(spe)[rowData(spe)$use_channel],
               maxK = 30,
               seed = 220410)

# Assess cluster stability
delta_area(spe)

spe$som_clusters <- cluster_ids(spe, "meta13")
```

```{r flowSOM-clusteirng-1, message=FALSE}
dittoDimPlot(spe, var = "som_clusters", 
             reduction.use = "UMAP", size = 0.2,
             do.label = TRUE) +
    ggtitle("SOM clusters expression on UMAP")
```

```{r flowSOM-heatmap-1, fig.height=8}
dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "som_clusters",
             annotation_legend = FALSE,
             fontsize=5,
             annot.colors = dittoColors(1)[1:length(unique(spe$som_clusters))])
```

The flowSOM clustering looks very different as compared to the PG clustering. We detect a huge CD15+ CD24+ cluster, which might represent neutrohpils. It would be interesting to perform hierarchical clustering among those cells to find different levels of maturity. Also improvement of the segmentation might help to take into account nuclear roundness. We detect a large CD14+ cluster, tumor cells (GD2+, ELAVL4+, CD56+ and GATA3+). We detect B-cells (CD20+ HLA-DR+) and T-cells (CD3+, CD4+, CD8+, Granzyme B). 

```{r, echo=FALSE}
end_time <- Sys.time()
```

Running FlowSOM clustering took `r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

The `CATALYST` package does not provide functionality to perform `FlowSOM` and
`ConsensusClusterPlus` clustering directly on the integrated cells. As an
alternative to the `CATALYST` package, the `bluster` package provides SOM
clustering when specifying the `SomParam()` parameter. Similar to the `CATALYST`
approach, we will first cluster the dataset into 100 clusters (also called
"codes"). These codes are then further clustered into a maximum of 30 clusters
using `ConsensusClusterPlus` (using hierarchical clustering and euclidean
distance). The delta area plot can be accessed using the (not exported)
`.plot_delta_area` function from `CATALYST`. Here, it seems that the plateau is
reached at a `k` of 25 and we will store the final cluster IDs within the
`SpatialExperiment` object.

```{r flowSOM-2, message=FALSE, results='hide', fig.show='hide'}
# Select integrated cells
mat <- reducedDim(spe, "harmony")

# Perform SOM clustering
som.out <- clusterRows(mat, SomParam(100), full = TRUE)
# Cluster the 100 SOM codes into larger clusters
ccp <- ConsensusClusterPlus(t(som.out$objects$som$codes[[1]]),
                            maxK = 30,
                            reps = 100, 
                            distance = "euclidean", 
                            seed = 220410, 
                            plot = NULL)
```

```{r flowSOM-2-visualize-clusters}
# Visualize delta area plot
CATALYST:::.plot_delta_area(ccp)

# Link ConsensusClusterPlus clusters with SOM codes and save in object
som.cluster <- ccp[[25]][["consensusClass"]][som.out$clusters]
spe$som_clusters_corrected <- as.factor(som.cluster)

dittoDimPlot(spe, var = "som_clusters_corrected", 
             reduction.use = "UMAP_harmony", size = 0.2,
             do.label = TRUE) +
    ggtitle("SOM clusters expression on UMAP, integrated cells")
```

```{r flowSOM-2-heatmap}
dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "som_clusters_corrected",
             annotation_legend = FALSE,
             fontsize=5,
             annot.colors = dittoColors(1)[1:length(unique(spe$som_clusters_corrected))])
```

Again, we see a huge cluster pointing towards neutrophils. Sticky cells can be seen (positive for everything). Here, it looks like the uncorrected heatmap is more informative. 

```{r flowSOM-heatmap-2-scale, message=FALSE, fig.height=7}
dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "scaled_exprs", 
             scale="none",
             heatmap.colors = viridis(100), 
             annot.by = "som_clusters_corrected",
             annotation_legend = FALSE,
             fontsize=5,
             annot.colors = dittoColors(1)[1:length(unique(spe$som_clusters_corrected))])
```

And as a last step, let's show the mean per cluster. For aggregating across clusters, we had to change the SPE to an SCE as explained [here](https://github.com/drighelli/SpatialExperiment/issues/104).

```{r flowSOM-heatmap-2-allcells-mean, message=FALSE, fig.height=7}
library(scuttle)

sce <- as(spe, "SingleCellExperiment")

cluster_mean <- aggregateAcrossCells(sce,
                                    ids = sce$som_clusters_corrected,
                                    statistics="mean",
                                    use.assay.type = "counts")
assay(cluster_mean, "exprs") <- asinh(counts(cluster_mean))
assay(cluster_mean, "scaled_exprs") <- t(apply(assay(cluster_mean, "exprs"), 1, RESCALE, to=0:1))

#not scaled
cluster_mean%>%dittoHeatmap(genes = rownames(sce)[rowData(sce)$use_channel],
            assay = "exprs", scale = "none",
            heatmap.colors = viridis(100),
            cluster_cols=TRUE,
            annotation_legend = FALSE,
            fontsize=5,
            show_colnames=TRUE,
            annot.by = "som_clusters_corrected",
            annot.colors = dittoColors(1)[1:length(unique(sce$som_clusters_corrected))])

#scaled
cluster_mean%>%dittoHeatmap(genes = rownames(sce)[rowData(sce)$use_channel],
            assay = "scaled_exprs", 
            annot.by = "som_clusters_corrected",
            cluster_cols=TRUE,
            scale="none",
            annotation_legend = FALSE,
            fontsize=5,
            show_colnames=TRUE,
            heatmap.colors = viridis(100),
            annot.colors = dittoColors(1)[1:length(unique(sce$som_clusters_corrected))])

rm(sce)
rm(cluster_mean)

```

Now we will look at the mean of the scaled expressions.

```{r flowSOM-heatmap-2-allcells-mean-of-scaled, message=FALSE, fig.height=7}
library(scuttle)

sce <- as(spe, "SingleCellExperiment")

cluster_mean <- aggregateAcrossCells(sce,
                                    ids = sce$som_clusters_corrected,
                                    statistics="mean",
                                    use.assay.type = "scaled_exprs")

#scaled
cluster_mean%>%dittoHeatmap(genes = rownames(sce)[rowData(sce)$use_channel],
            assay = "scaled_exprs", 
            annot.by = "som_clusters_corrected",
            cluster_cols=TRUE,
            scale="none",
            annotation_legend = FALSE,
            fontsize=5,
            heatmap.colors = viridis(100),
            show_colnames = TRUE,
            annot.colors = dittoColors(1)[1:length(unique(sce$som_clusters_corrected))])

rm(sce)
rm(cluster_mean)

```

The `FlowSOM` clustering approach has been used by [@Hoch2022] to sub-cluster tumor
cells as measured by IMC.

### Compare between clustering approaches

Finally, we can compare the results of different clustering approaches. For
this, we visualize the number of cells that are shared between different
clustering results in a pairwise fashion. In the following heatmaps a high match
between clustering results can be seen for those clusters that are uniquely
detected in both approaches.

First, we will visualize the match between the three different approaches 
applied to the asinh-transformed counts.

```{r raw-counts, message=FALSE}
library(patchwork)
library(pheatmap)
library(gridExtra)

tab1 <- table(paste("Rphenograph", spe$pg_clusters), 
              paste("SOM", spe$som_clusters))

pheatmap(log10(tab1 + 10), color = viridis(100))

```

We observe that `Rphenograph` and the SOM approach by
`scran` show some similar results (first heatmap above). For example, Rphenograph
cluster 32 is perfectly captured by SOM cluster 6. On the
other hand, SOM cluster 11 is split into multiple Rphenograph
clusters. A common approach
is to now merge clusters that contain similar cell types and annotate them by
hand.

Below, a comparison between the clustering results of the integrated cells 
is shown.

```{r corrected, message=FALSE, fig.height=3}

tab1 <- table(paste("Rphenograph", spe$pg_clusters_corrected), 
              paste("SOM", spe$som_clusters_corrected))

pheatmap(log10(tab1 + 10), color = viridis(100))
```

In comparison to clustering on the non-integrated cells, the clustering results
of the integrated cells show higher overlap. 

Clusters 6 in both methods show good agreement. 

### Further clustering notes {#clustering-notes}

The `bluster` package provides a number of metrics to assess cluster stability
[here](https://www.bioconductor.org/packages/release/bioc/vignettes/bluster/inst/doc/diagnostics.html).
For brevity we only highlighted the use of the silhouette width but different
metrics should be tested to assess cluster stability.

To assign cell types to clusters, we manually annotate clusters based on their
marker expression. For example, SNN cluster 11 (clustering of the integrated
cells) shows high, homogeneous expression of CD20 and we might therefore label
this cluster as B cells. Full cell labeling can be seen in the following section.

Finally, we save the updated `SpatialExperiment` object.

```{r phenotyping-save-object}
saveRDS(spe, file.path(path,"data/spe_curated_pg.rds"))
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>
